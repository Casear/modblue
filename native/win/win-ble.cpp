// Copyright (c) The NodeRT Contributors
// All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License""); you may
// not use this file except in compliance with the License. You may obtain a
// copy of the License at http://www.apache.org/licenses/LICENSE-2.0
//
// THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS
// OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY
// IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
// MERCHANTABLITY OR NON-INFRINGEMENT.
//
// See the Apache Version 2.0 License for specific language governing permissions
// and limitations under the License.

// TODO: Verify that this is is still needed..
#define NTDDI_VERSION 0x06010000

#include <v8.h>
#include "nan.h"
#include <string>
#include <ppltasks.h>
#include "CollectionsConverter.h"
#include "CollectionsWrap.h"
#include "node-async.h"
#include "NodeRtUtils.h"
#include "OpaqueWrapper.h"
#include "WrapperBase.h"

#using <Windows.WinMD>

// this undefs fixes the issues of compiling Windows.Data.Json, Windows.Storag.FileProperties, and Windows.Stroage.Search
// Some of the node header files brings windows definitions with the same names as some of the WinRT methods
#undef DocumentProperties
#undef GetObject
#undef CreateEvent
#undef FindText
#undef SendMessage

const char* REGISTRATION_TOKEN_MAP_PROPERTY_NAME = "__registrationTokenMap__";

using v8::Array;
using v8::String;
using v8::Value;
using v8::Boolean;
using v8::Integer;
using v8::FunctionTemplate;
using v8::Object;
using v8::Local;
using v8::Function;
using v8::Date;
using v8::Number;
using v8::PropertyAttribute;
using v8::Primitive;
using Nan::HandleScope;
using Nan::Persistent;
using Nan::Undefined;
using Nan::True;
using Nan::False;
using Nan::Null;
using Nan::MaybeLocal;
using Nan::EscapableHandleScope;
using Nan::HandleScope;
using Nan::TryCatch;
using namespace concurrency;

namespace NodeRT { namespace Windows { namespace Devices { namespace Bluetooth { 
  v8::Local<v8::Value> WrapBluetoothAdapter(::Windows::Devices::Bluetooth::BluetoothAdapter^ wintRtInstance);
  ::Windows::Devices::Bluetooth::BluetoothAdapter^ UnwrapBluetoothAdapter(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothClassOfDevice(::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ wintRtInstance);
  ::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ UnwrapBluetoothClassOfDevice(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothDevice(::Windows::Devices::Bluetooth::BluetoothDevice^ wintRtInstance);
  ::Windows::Devices::Bluetooth::BluetoothDevice^ UnwrapBluetoothDevice(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothDeviceId(::Windows::Devices::Bluetooth::BluetoothDeviceId^ wintRtInstance);
  ::Windows::Devices::Bluetooth::BluetoothDeviceId^ UnwrapBluetoothDeviceId(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEAppearance(::Windows::Devices::Bluetooth::BluetoothLEAppearance^ wintRtInstance);
  ::Windows::Devices::Bluetooth::BluetoothLEAppearance^ UnwrapBluetoothLEAppearance(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEAppearanceCategories(::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^ wintRtInstance);
  ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^ UnwrapBluetoothLEAppearanceCategories(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEAppearanceSubcategories(::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^ wintRtInstance);
  ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^ UnwrapBluetoothLEAppearanceSubcategories(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEDevice(::Windows::Devices::Bluetooth::BluetoothLEDevice^ wintRtInstance);
  ::Windows::Devices::Bluetooth::BluetoothLEDevice^ UnwrapBluetoothLEDevice(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothSignalStrengthFilter(::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^ wintRtInstance);
  ::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^ UnwrapBluetoothSignalStrengthFilter(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothUuidHelper(::Windows::Devices::Bluetooth::BluetoothUuidHelper^ wintRtInstance);
  ::Windows::Devices::Bluetooth::BluetoothUuidHelper^ UnwrapBluetoothUuidHelper(Local<Value> value);
  



  static void InitBluetoothAddressTypeEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("BluetoothAddressType").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("public").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothAddressType::Public)));
    Nan::Set(enumObject, Nan::New<String>("random").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothAddressType::Random)));
    Nan::Set(enumObject, Nan::New<String>("unspecified").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothAddressType::Unspecified)));
  }

  static void InitBluetoothCacheModeEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("BluetoothCacheMode").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("cached").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothCacheMode::Cached)));
    Nan::Set(enumObject, Nan::New<String>("uncached").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothCacheMode::Uncached)));
  }

  static void InitBluetoothConnectionStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("BluetoothConnectionStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("disconnected").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothConnectionStatus::Disconnected)));
    Nan::Set(enumObject, Nan::New<String>("connected").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothConnectionStatus::Connected)));
  }

  static void InitBluetoothErrorEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("BluetoothError").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("success").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothError::Success)));
    Nan::Set(enumObject, Nan::New<String>("radioNotAvailable").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothError::RadioNotAvailable)));
    Nan::Set(enumObject, Nan::New<String>("resourceInUse").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothError::ResourceInUse)));
    Nan::Set(enumObject, Nan::New<String>("deviceNotConnected").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothError::DeviceNotConnected)));
    Nan::Set(enumObject, Nan::New<String>("otherError").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothError::OtherError)));
    Nan::Set(enumObject, Nan::New<String>("disabledByPolicy").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothError::DisabledByPolicy)));
    Nan::Set(enumObject, Nan::New<String>("notSupported").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothError::NotSupported)));
    Nan::Set(enumObject, Nan::New<String>("disabledByUser").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothError::DisabledByUser)));
    Nan::Set(enumObject, Nan::New<String>("consentRequired").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothError::ConsentRequired)));
    Nan::Set(enumObject, Nan::New<String>("transportNotSupported").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothError::TransportNotSupported)));
  }

  static void InitBluetoothMajorClassEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("BluetoothMajorClass").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("miscellaneous").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMajorClass::Miscellaneous)));
    Nan::Set(enumObject, Nan::New<String>("computer").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMajorClass::Computer)));
    Nan::Set(enumObject, Nan::New<String>("phone").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMajorClass::Phone)));
    Nan::Set(enumObject, Nan::New<String>("networkAccessPoint").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMajorClass::NetworkAccessPoint)));
    Nan::Set(enumObject, Nan::New<String>("audioVideo").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMajorClass::AudioVideo)));
    Nan::Set(enumObject, Nan::New<String>("peripheral").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMajorClass::Peripheral)));
    Nan::Set(enumObject, Nan::New<String>("imaging").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMajorClass::Imaging)));
    Nan::Set(enumObject, Nan::New<String>("wearable").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMajorClass::Wearable)));
    Nan::Set(enumObject, Nan::New<String>("toy").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMajorClass::Toy)));
    Nan::Set(enumObject, Nan::New<String>("health").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMajorClass::Health)));
  }

  static void InitBluetoothMinorClassEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("BluetoothMinorClass").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("uncategorized").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::Uncategorized)));
    Nan::Set(enumObject, Nan::New<String>("networkFullyAvailable").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::NetworkFullyAvailable)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoWearableHeadset").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoWearableHeadset)));
    Nan::Set(enumObject, Nan::New<String>("phoneCellular").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PhoneCellular)));
    Nan::Set(enumObject, Nan::New<String>("peripheralJoystick").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PeripheralJoystick)));
    Nan::Set(enumObject, Nan::New<String>("healthBloodPressureMonitor").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthBloodPressureMonitor)));
    Nan::Set(enumObject, Nan::New<String>("wearableWristwatch").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::WearableWristwatch)));
    Nan::Set(enumObject, Nan::New<String>("computerDesktop").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::ComputerDesktop)));
    Nan::Set(enumObject, Nan::New<String>("toyRobot").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::ToyRobot)));
    Nan::Set(enumObject, Nan::New<String>("peripheralGamepad").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PeripheralGamepad)));
    Nan::Set(enumObject, Nan::New<String>("wearablePager").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::WearablePager)));
    Nan::Set(enumObject, Nan::New<String>("computerServer").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::ComputerServer)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoHandsFree").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoHandsFree)));
    Nan::Set(enumObject, Nan::New<String>("toyVehicle").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::ToyVehicle)));
    Nan::Set(enumObject, Nan::New<String>("healthThermometer").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthThermometer)));
    Nan::Set(enumObject, Nan::New<String>("phoneCordless").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PhoneCordless)));
    Nan::Set(enumObject, Nan::New<String>("phoneSmartPhone").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PhoneSmartPhone)));
    Nan::Set(enumObject, Nan::New<String>("computerLaptop").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::ComputerLaptop)));
    Nan::Set(enumObject, Nan::New<String>("wearableJacket").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::WearableJacket)));
    Nan::Set(enumObject, Nan::New<String>("peripheralRemoteControl").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PeripheralRemoteControl)));
    Nan::Set(enumObject, Nan::New<String>("healthWeighingScale").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthWeighingScale)));
    Nan::Set(enumObject, Nan::New<String>("toyDoll").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::ToyDoll)));
    Nan::Set(enumObject, Nan::New<String>("computerHandheld").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::ComputerHandheld)));
    Nan::Set(enumObject, Nan::New<String>("toyController").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::ToyController)));
    Nan::Set(enumObject, Nan::New<String>("phoneWired").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PhoneWired)));
    Nan::Set(enumObject, Nan::New<String>("wearableHelmet").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::WearableHelmet)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoMicrophone").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoMicrophone)));
    Nan::Set(enumObject, Nan::New<String>("peripheralSensing").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PeripheralSensing)));
    Nan::Set(enumObject, Nan::New<String>("healthGlucoseMeter").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthGlucoseMeter)));
    Nan::Set(enumObject, Nan::New<String>("wearableGlasses").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::WearableGlasses)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoLoudspeaker").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoLoudspeaker)));
    Nan::Set(enumObject, Nan::New<String>("healthPulseOximeter").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthPulseOximeter)));
    Nan::Set(enumObject, Nan::New<String>("toyGame").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::ToyGame)));
    Nan::Set(enumObject, Nan::New<String>("phoneIsdn").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PhoneIsdn)));
    Nan::Set(enumObject, Nan::New<String>("peripheralDigitizerTablet").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PeripheralDigitizerTablet)));
    Nan::Set(enumObject, Nan::New<String>("computerPalmSize").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::ComputerPalmSize)));
    Nan::Set(enumObject, Nan::New<String>("peripheralCardReader").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PeripheralCardReader)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoHeadphones").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoHeadphones)));
    Nan::Set(enumObject, Nan::New<String>("computerWearable").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::ComputerWearable)));
    Nan::Set(enumObject, Nan::New<String>("healthHeartRateMonitor").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthHeartRateMonitor)));
    Nan::Set(enumObject, Nan::New<String>("peripheralDigitalPen").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PeripheralDigitalPen)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoPortableAudio").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoPortableAudio)));
    Nan::Set(enumObject, Nan::New<String>("healthHealthDataDisplay").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthHealthDataDisplay)));
    Nan::Set(enumObject, Nan::New<String>("computerTablet").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::ComputerTablet)));
    Nan::Set(enumObject, Nan::New<String>("peripheralHandheldScanner").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PeripheralHandheldScanner)));
    Nan::Set(enumObject, Nan::New<String>("networkUsed01To17Percent").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::NetworkUsed01To17Percent)));
    Nan::Set(enumObject, Nan::New<String>("healthStepCounter").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthStepCounter)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoCarAudio").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoCarAudio)));
    Nan::Set(enumObject, Nan::New<String>("peripheralHandheldGesture").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::PeripheralHandheldGesture)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoSetTopBox").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoSetTopBox)));
    Nan::Set(enumObject, Nan::New<String>("healthBodyCompositionAnalyzer").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthBodyCompositionAnalyzer)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoHifiAudioDevice").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoHifiAudioDevice)));
    Nan::Set(enumObject, Nan::New<String>("healthPeakFlowMonitor").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthPeakFlowMonitor)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoVcr").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoVcr)));
    Nan::Set(enumObject, Nan::New<String>("healthMedicationMonitor").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthMedicationMonitor)));
    Nan::Set(enumObject, Nan::New<String>("healthKneeProsthesis").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthKneeProsthesis)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoVideoCamera").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoVideoCamera)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoCamcorder").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoCamcorder)));
    Nan::Set(enumObject, Nan::New<String>("healthAnkleProsthesis").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthAnkleProsthesis)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoVideoMonitor").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoVideoMonitor)));
    Nan::Set(enumObject, Nan::New<String>("healthGenericHealthManager").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthGenericHealthManager)));
    Nan::Set(enumObject, Nan::New<String>("healthPersonalMobilityDevice").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::HealthPersonalMobilityDevice)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoVideoDisplayAndLoudspeaker").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoVideoDisplayAndLoudspeaker)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoVideoConferencing").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoVideoConferencing)));
    Nan::Set(enumObject, Nan::New<String>("networkUsed17To33Percent").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::NetworkUsed17To33Percent)));
    Nan::Set(enumObject, Nan::New<String>("audioVideoGamingOrToy").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::AudioVideoGamingOrToy)));
    Nan::Set(enumObject, Nan::New<String>("networkUsed33To50Percent").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::NetworkUsed33To50Percent)));
    Nan::Set(enumObject, Nan::New<String>("networkUsed50To67Percent").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::NetworkUsed50To67Percent)));
    Nan::Set(enumObject, Nan::New<String>("networkUsed67To83Percent").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::NetworkUsed67To83Percent)));
    Nan::Set(enumObject, Nan::New<String>("networkUsed83To99Percent").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::NetworkUsed83To99Percent)));
    Nan::Set(enumObject, Nan::New<String>("networkNoServiceAvailable").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothMinorClass::NetworkNoServiceAvailable)));
  }

  static void InitBluetoothServiceCapabilitiesEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("BluetoothServiceCapabilities").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("none").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothServiceCapabilities::None)));
    Nan::Set(enumObject, Nan::New<String>("limitedDiscoverableMode").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothServiceCapabilities::LimitedDiscoverableMode)));
    Nan::Set(enumObject, Nan::New<String>("positioningService").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothServiceCapabilities::PositioningService)));
    Nan::Set(enumObject, Nan::New<String>("networkingService").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothServiceCapabilities::NetworkingService)));
    Nan::Set(enumObject, Nan::New<String>("renderingService").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothServiceCapabilities::RenderingService)));
    Nan::Set(enumObject, Nan::New<String>("capturingService").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothServiceCapabilities::CapturingService)));
    Nan::Set(enumObject, Nan::New<String>("objectTransferService").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothServiceCapabilities::ObjectTransferService)));
    Nan::Set(enumObject, Nan::New<String>("audioService").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothServiceCapabilities::AudioService)));
    Nan::Set(enumObject, Nan::New<String>("telephoneService").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothServiceCapabilities::TelephoneService)));
    Nan::Set(enumObject, Nan::New<String>("informationService").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::BluetoothServiceCapabilities::InformationService)));
  }



  class BluetoothAdapter : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothAdapter").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;


          
            Nan::SetPrototypeMethod(localRef, "getRadioAsync", GetRadioAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("bluetoothAddress").ToLocalChecked(), BluetoothAddressGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceId").ToLocalChecked(), DeviceIdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isAdvertisementOffloadSupported").ToLocalChecked(), IsAdvertisementOffloadSupportedGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isCentralRoleSupported").ToLocalChecked(), IsCentralRoleSupportedGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isClassicSupported").ToLocalChecked(), IsClassicSupportedGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isLowEnergySupported").ToLocalChecked(), IsLowEnergySupportedGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isPeripheralRoleSupported").ToLocalChecked(), IsPeripheralRoleSupportedGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("areClassicSecureConnectionsSupported").ToLocalChecked(), AreClassicSecureConnectionsSupportedGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("areLowEnergySecureConnectionsSupported").ToLocalChecked(), AreLowEnergySecureConnectionsSupportedGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isExtendedAdvertisingSupported").ToLocalChecked(), IsExtendedAdvertisingSupportedGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("maxAdvertisementDataLength").ToLocalChecked(), MaxAdvertisementDataLengthGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "getDeviceSelector", GetDeviceSelector);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(FromIdAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("fromIdAsync").ToLocalChecked(), func);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(GetDefaultAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("getDefaultAsync").ToLocalChecked(), func);


        Nan::Set(exports, Nan::New<String>("BluetoothAdapter").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothAdapter(::Windows::Devices::Bluetooth::BluetoothAdapter^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::BluetoothAdapter^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::BluetoothAdapter^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothAdapter *wrapperInstance = new BluetoothAdapter(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::BluetoothAdapter^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::BluetoothAdapter^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothAdapter(winRtInstance));
    }

    static void GetRadioAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      BluetoothAdapter *wrapper = BluetoothAdapter::Unwrap<BluetoothAdapter>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Radios::Radio^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetRadioAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Radios::Radio^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Radios", "Radio", result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }



    static void FromIdAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::BluetoothAdapter^>^ op;


      if (info.Length() == 2
          && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
            
          op = ::Windows::Devices::Bluetooth::BluetoothAdapter::FromIdAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::BluetoothAdapter^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapBluetoothAdapter(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void GetDefaultAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::BluetoothAdapter^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = ::Windows::Devices::Bluetooth::BluetoothAdapter::GetDefaultAsync();
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::BluetoothAdapter^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapBluetoothAdapter(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void GetDeviceSelector(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0)
      {
        try
        {
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothAdapter::GetDeviceSelector();
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void BluetoothAddressGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info.This())) {
        return;
      }

      BluetoothAdapter *wrapper = BluetoothAdapter::Unwrap<BluetoothAdapter>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->BluetoothAddress;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DeviceIdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info.This())) {
        return;
      }

      BluetoothAdapter *wrapper = BluetoothAdapter::Unwrap<BluetoothAdapter>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->DeviceId;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsAdvertisementOffloadSupportedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info.This())) {
        return;
      }

      BluetoothAdapter *wrapper = BluetoothAdapter::Unwrap<BluetoothAdapter>(info.This());

      try  {
        bool result = wrapper->_instance->IsAdvertisementOffloadSupported;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsCentralRoleSupportedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info.This())) {
        return;
      }

      BluetoothAdapter *wrapper = BluetoothAdapter::Unwrap<BluetoothAdapter>(info.This());

      try  {
        bool result = wrapper->_instance->IsCentralRoleSupported;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsClassicSupportedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info.This())) {
        return;
      }

      BluetoothAdapter *wrapper = BluetoothAdapter::Unwrap<BluetoothAdapter>(info.This());

      try  {
        bool result = wrapper->_instance->IsClassicSupported;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsLowEnergySupportedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info.This())) {
        return;
      }

      BluetoothAdapter *wrapper = BluetoothAdapter::Unwrap<BluetoothAdapter>(info.This());

      try  {
        bool result = wrapper->_instance->IsLowEnergySupported;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsPeripheralRoleSupportedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info.This())) {
        return;
      }

      BluetoothAdapter *wrapper = BluetoothAdapter::Unwrap<BluetoothAdapter>(info.This());

      try  {
        bool result = wrapper->_instance->IsPeripheralRoleSupported;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void AreClassicSecureConnectionsSupportedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info.This())) {
        return;
      }

      BluetoothAdapter *wrapper = BluetoothAdapter::Unwrap<BluetoothAdapter>(info.This());

      try  {
        bool result = wrapper->_instance->AreClassicSecureConnectionsSupported;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void AreLowEnergySecureConnectionsSupportedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info.This())) {
        return;
      }

      BluetoothAdapter *wrapper = BluetoothAdapter::Unwrap<BluetoothAdapter>(info.This());

      try  {
        bool result = wrapper->_instance->AreLowEnergySecureConnectionsSupported;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsExtendedAdvertisingSupportedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info.This())) {
        return;
      }

      BluetoothAdapter *wrapper = BluetoothAdapter::Unwrap<BluetoothAdapter>(info.This());

      try  {
        bool result = wrapper->_instance->IsExtendedAdvertisingSupported;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void MaxAdvertisementDataLengthGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothAdapter^>(info.This())) {
        return;
      }

      BluetoothAdapter *wrapper = BluetoothAdapter::Unwrap<BluetoothAdapter>(info.This());

      try  {
        unsigned int result = wrapper->_instance->MaxAdvertisementDataLength;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::BluetoothAdapter^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothAdapter(::Windows::Devices::Bluetooth::BluetoothAdapter^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::BluetoothAdapter^ UnwrapBluetoothAdapter(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothAdapter::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothAdapter(::Windows::Devices::Bluetooth::BluetoothAdapter^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothAdapter::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::BluetoothAdapter^ UnwrapBluetoothAdapter(Local<Value> value) {
     return BluetoothAdapter::Unwrap<BluetoothAdapter>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothAdapter(Local<Object> exports) {
    BluetoothAdapter::Init(exports);
  }

  class BluetoothClassOfDevice : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothClassOfDevice").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("majorClass").ToLocalChecked(), MajorClassGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("minorClass").ToLocalChecked(), MinorClassGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("rawValue").ToLocalChecked(), RawValueGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("serviceCapabilities").ToLocalChecked(), ServiceCapabilitiesGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "fromRawValue", FromRawValue);
        Nan::SetMethod(constructor, "fromParts", FromParts);


        Nan::Set(exports, Nan::New<String>("BluetoothClassOfDevice").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothClassOfDevice(::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothClassOfDevice^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::BluetoothClassOfDevice^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothClassOfDevice *wrapperInstance = new BluetoothClassOfDevice(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothClassOfDevice^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::BluetoothClassOfDevice^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothClassOfDevice(winRtInstance));
    }





    static void FromRawValue(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          ::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothClassOfDevice::FromRawValue(arg0);
          info.GetReturnValue().Set(WrapBluetoothClassOfDevice(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void FromParts(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 3
        && info[0]->IsInt32()
        && info[1]->IsInt32()
        && info[2]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothMajorClass arg0 = static_cast<::Windows::Devices::Bluetooth::BluetoothMajorClass>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          ::Windows::Devices::Bluetooth::BluetoothMinorClass arg1 = static_cast<::Windows::Devices::Bluetooth::BluetoothMinorClass>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          ::Windows::Devices::Bluetooth::BluetoothServiceCapabilities arg2 = static_cast<::Windows::Devices::Bluetooth::BluetoothServiceCapabilities>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          
          ::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothClassOfDevice::FromParts(arg0, arg1, arg2);
          info.GetReturnValue().Set(WrapBluetoothClassOfDevice(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void MajorClassGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothClassOfDevice^>(info.This())) {
        return;
      }

      BluetoothClassOfDevice *wrapper = BluetoothClassOfDevice::Unwrap<BluetoothClassOfDevice>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothMajorClass result = wrapper->_instance->MajorClass;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void MinorClassGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothClassOfDevice^>(info.This())) {
        return;
      }

      BluetoothClassOfDevice *wrapper = BluetoothClassOfDevice::Unwrap<BluetoothClassOfDevice>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothMinorClass result = wrapper->_instance->MinorClass;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void RawValueGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothClassOfDevice^>(info.This())) {
        return;
      }

      BluetoothClassOfDevice *wrapper = BluetoothClassOfDevice::Unwrap<BluetoothClassOfDevice>(info.This());

      try  {
        unsigned int result = wrapper->_instance->RawValue;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ServiceCapabilitiesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothClassOfDevice^>(info.This())) {
        return;
      }

      BluetoothClassOfDevice *wrapper = BluetoothClassOfDevice::Unwrap<BluetoothClassOfDevice>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothServiceCapabilities result = wrapper->_instance->ServiceCapabilities;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothClassOfDevice(::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ UnwrapBluetoothClassOfDevice(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothClassOfDevice::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothClassOfDevice(::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothClassOfDevice::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ UnwrapBluetoothClassOfDevice(Local<Value> value) {
     return BluetoothClassOfDevice::Unwrap<BluetoothClassOfDevice>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothClassOfDevice(Local<Object> exports) {
    BluetoothClassOfDevice::Init(exports);
  }

  class BluetoothDevice : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothDevice").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "close", Close);
          

          
            Nan::SetPrototypeMethod(localRef, "requestAccessAsync", RequestAccessAsync);
            Nan::SetPrototypeMethod(localRef, "getRfcommServicesAsync", GetRfcommServicesAsync);
            Nan::SetPrototypeMethod(localRef, "getRfcommServicesForIdAsync", GetRfcommServicesForIdAsync);
          

          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("bluetoothAddress").ToLocalChecked(), BluetoothAddressGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("classOfDevice").ToLocalChecked(), ClassOfDeviceGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("connectionStatus").ToLocalChecked(), ConnectionStatusGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceId").ToLocalChecked(), DeviceIdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("hostName").ToLocalChecked(), HostNameGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("name").ToLocalChecked(), NameGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("rfcommServices").ToLocalChecked(), RfcommServicesGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("sdpRecords").ToLocalChecked(), SdpRecordsGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceInformation").ToLocalChecked(), DeviceInformationGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceAccessInformation").ToLocalChecked(), DeviceAccessInformationGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("bluetoothDeviceId").ToLocalChecked(), BluetoothDeviceIdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("wasSecureConnectionUsedForPairing").ToLocalChecked(), WasSecureConnectionUsedForPairingGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "getDeviceSelectorFromPairingState", GetDeviceSelectorFromPairingState);
        Nan::SetMethod(constructor, "getDeviceSelectorFromConnectionStatus", GetDeviceSelectorFromConnectionStatus);
        Nan::SetMethod(constructor, "getDeviceSelectorFromDeviceName", GetDeviceSelectorFromDeviceName);
        Nan::SetMethod(constructor, "getDeviceSelectorFromBluetoothAddress", GetDeviceSelectorFromBluetoothAddress);
        Nan::SetMethod(constructor, "getDeviceSelectorFromClassOfDevice", GetDeviceSelectorFromClassOfDevice);
        Nan::SetMethod(constructor, "getDeviceSelector", GetDeviceSelector);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(FromIdAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("fromIdAsync").ToLocalChecked(), func);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(FromHostNameAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("fromHostNameAsync").ToLocalChecked(), func);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(FromBluetoothAddressAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("fromBluetoothAddressAsync").ToLocalChecked(), func);


        Nan::Set(exports, Nan::New<String>("BluetoothDevice").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothDevice(::Windows::Devices::Bluetooth::BluetoothDevice^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::BluetoothDevice^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::BluetoothDevice^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothDevice *wrapperInstance = new BluetoothDevice(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::BluetoothDevice^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::BluetoothDevice^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothDevice(winRtInstance));
    }

    static void RequestAccessAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Enumeration::DeviceAccessStatus>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->RequestAccessAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Enumeration::DeviceAccessStatus> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(static_cast<int>(result));
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void GetRfcommServicesAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::Rfcomm::RfcommDeviceServicesResult^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetRfcommServicesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg0 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->GetRfcommServicesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::Rfcomm::RfcommDeviceServicesResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Bluetooth.Rfcomm", "RfcommDeviceServicesResult", result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void GetRfcommServicesForIdAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::Rfcomm::RfcommDeviceServicesResult^>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Rfcomm::RfcommServiceId^>(info[0]))
      {
        try
        {
          ::Windows::Devices::Bluetooth::Rfcomm::RfcommServiceId^ arg0 = dynamic_cast<::Windows::Devices::Bluetooth::Rfcomm::RfcommServiceId^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          op = wrapper->_instance->GetRfcommServicesForIdAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Rfcomm::RfcommServiceId^>(info[0])
        && info[1]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::Rfcomm::RfcommServiceId^ arg0 = dynamic_cast<::Windows::Devices::Bluetooth::Rfcomm::RfcommServiceId^>(NodeRT::Utils::GetObjectInstance(info[0]));
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg1 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          op = wrapper->_instance->GetRfcommServicesForIdAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::Rfcomm::RfcommDeviceServicesResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Bluetooth.Rfcomm", "RfcommDeviceServicesResult", result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }


    static void FromIdAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::BluetoothDevice^>^ op;


      if (info.Length() == 2
          && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
            
          op = ::Windows::Devices::Bluetooth::BluetoothDevice::FromIdAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::BluetoothDevice^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapBluetoothDevice(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void FromHostNameAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::BluetoothDevice^>^ op;


      if (info.Length() == 2
          && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Networking::HostName^>(info[0]))
      {
        try
        {
          ::Windows::Networking::HostName^ arg0 = dynamic_cast<::Windows::Networking::HostName^>(NodeRT::Utils::GetObjectInstance(info[0]));
            
          op = ::Windows::Devices::Bluetooth::BluetoothDevice::FromHostNameAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::BluetoothDevice^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapBluetoothDevice(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void FromBluetoothAddressAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::BluetoothDevice^>^ op;


      if (info.Length() == 2
          && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
            
          op = ::Windows::Devices::Bluetooth::BluetoothDevice::FromBluetoothAddressAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::BluetoothDevice^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapBluetoothDevice(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void GetDeviceSelectorFromPairingState(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsBoolean())
      {
        try
        {
          bool arg0 = Nan::To<bool>(info[0]).FromMaybe(false);
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromPairingState(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelectorFromConnectionStatus(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothConnectionStatus arg0 = static_cast<::Windows::Devices::Bluetooth::BluetoothConnectionStatus>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromConnectionStatus(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelectorFromDeviceName(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromDeviceName(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelectorFromBluetoothAddress(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromBluetoothAddress(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelectorFromClassOfDevice(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothClassOfDevice^>(info[0]))
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ arg0 = UnwrapBluetoothClassOfDevice(info[0]);
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromClassOfDevice(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelector(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0)
      {
        try
        {
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelector();
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void BluetoothAddressGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->BluetoothAddress;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ClassOfDeviceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothClassOfDevice^ result = wrapper->_instance->ClassOfDevice;
        info.GetReturnValue().Set(WrapBluetoothClassOfDevice(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ConnectionStatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothConnectionStatus result = wrapper->_instance->ConnectionStatus;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DeviceIdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->DeviceId;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void HostNameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      try  {
        ::Windows::Networking::HostName^ result = wrapper->_instance->HostName;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Networking", "HostName", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void NameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Name;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void RfcommServicesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::Rfcomm::RfcommDeviceService^>^ result = wrapper->_instance->RfcommServices;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::Rfcomm::RfcommDeviceService^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::Rfcomm::RfcommDeviceService^ val) -> Local<Value> {
              return NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Bluetooth.Rfcomm", "RfcommDeviceService", val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Rfcomm::RfcommDeviceService^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::Rfcomm::RfcommDeviceService^ {
              return dynamic_cast<::Windows::Devices::Bluetooth::Rfcomm::RfcommDeviceService^>(NodeRT::Utils::GetObjectInstance(value));
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SdpRecordsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Storage::Streams::IBuffer^>^ result = wrapper->_instance->SdpRecords;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Storage::Streams::IBuffer^>::CreateVectorViewWrapper(result, 
            [](::Windows::Storage::Streams::IBuffer^ val) -> Local<Value> {
              return NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(value);
            },
            [](Local<Value> value) -> ::Windows::Storage::Streams::IBuffer^ {
              return dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(value));
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DeviceInformationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceInformation^ result = wrapper->_instance->DeviceInformation;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Enumeration", "DeviceInformation", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DeviceAccessInformationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceAccessInformation^ result = wrapper->_instance->DeviceAccessInformation;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Enumeration", "DeviceAccessInformation", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void BluetoothDeviceIdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothDeviceId^ result = wrapper->_instance->BluetoothDeviceId;
        info.GetReturnValue().Set(WrapBluetoothDeviceId(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void WasSecureConnectionUsedForPairingGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This())) {
        return;
      }

      BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());

      try  {
        bool result = wrapper->_instance->WasSecureConnectionUsedForPairing;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"connectionStatusChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->ConnectionStatusChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::BluetoothDevice^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::BluetoothDevice^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapBluetoothDevice(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"nameChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->NameChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::BluetoothDevice^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::BluetoothDevice^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapBluetoothDevice(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"sdpRecordsChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->SdpRecordsChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::BluetoothDevice^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::BluetoothDevice^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapBluetoothDevice(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"connectionStatusChanged", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"nameChanged", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"sdpRecordsChanged", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"connectionStatusChanged", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());
          wrapper->_instance->ConnectionStatusChanged::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"nameChanged", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());
          wrapper->_instance->NameChanged::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"sdpRecordsChanged", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDevice^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          BluetoothDevice *wrapper = BluetoothDevice::Unwrap<BluetoothDevice>(info.This());
          wrapper->_instance->SdpRecordsChanged::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Bluetooth::BluetoothDevice^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothDevice(::Windows::Devices::Bluetooth::BluetoothDevice^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::BluetoothDevice^ UnwrapBluetoothDevice(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothDevice::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothDevice(::Windows::Devices::Bluetooth::BluetoothDevice^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothDevice::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::BluetoothDevice^ UnwrapBluetoothDevice(Local<Value> value) {
     return BluetoothDevice::Unwrap<BluetoothDevice>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothDevice(Local<Object> exports) {
    BluetoothDevice::Init(exports);
  }

  class BluetoothDeviceId : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothDeviceId").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("id").ToLocalChecked(), IdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isClassicDevice").ToLocalChecked(), IsClassicDeviceGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isLowEnergyDevice").ToLocalChecked(), IsLowEnergyDeviceGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "fromId", FromId);


        Nan::Set(exports, Nan::New<String>("BluetoothDeviceId").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothDeviceId(::Windows::Devices::Bluetooth::BluetoothDeviceId^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::BluetoothDeviceId^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::BluetoothDeviceId^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothDeviceId *wrapperInstance = new BluetoothDeviceId(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::BluetoothDeviceId^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::BluetoothDeviceId^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothDeviceId(winRtInstance));
    }





    static void FromId(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          ::Windows::Devices::Bluetooth::BluetoothDeviceId^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothDeviceId::FromId(arg0);
          info.GetReturnValue().Set(WrapBluetoothDeviceId(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void IdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(info.This())) {
        return;
      }

      BluetoothDeviceId *wrapper = BluetoothDeviceId::Unwrap<BluetoothDeviceId>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Id;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsClassicDeviceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(info.This())) {
        return;
      }

      BluetoothDeviceId *wrapper = BluetoothDeviceId::Unwrap<BluetoothDeviceId>(info.This());

      try  {
        bool result = wrapper->_instance->IsClassicDevice;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsLowEnergyDeviceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(info.This())) {
        return;
      }

      BluetoothDeviceId *wrapper = BluetoothDeviceId::Unwrap<BluetoothDeviceId>(info.This());

      try  {
        bool result = wrapper->_instance->IsLowEnergyDevice;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::BluetoothDeviceId^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothDeviceId(::Windows::Devices::Bluetooth::BluetoothDeviceId^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::BluetoothDeviceId^ UnwrapBluetoothDeviceId(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothDeviceId::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothDeviceId(::Windows::Devices::Bluetooth::BluetoothDeviceId^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothDeviceId::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::BluetoothDeviceId^ UnwrapBluetoothDeviceId(Local<Value> value) {
     return BluetoothDeviceId::Unwrap<BluetoothDeviceId>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothDeviceId(Local<Object> exports) {
    BluetoothDeviceId::Init(exports);
  }

  class BluetoothLEAppearance : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAppearance").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("category").ToLocalChecked(), CategoryGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("rawValue").ToLocalChecked(), RawValueGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("subCategory").ToLocalChecked(), SubCategoryGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "fromRawValue", FromRawValue);
        Nan::SetMethod(constructor, "fromParts", FromParts);


        Nan::Set(exports, Nan::New<String>("BluetoothLEAppearance").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAppearance(::Windows::Devices::Bluetooth::BluetoothLEAppearance^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::BluetoothLEAppearance^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEAppearance^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::BluetoothLEAppearance^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAppearance *wrapperInstance = new BluetoothLEAppearance(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEAppearance^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::BluetoothLEAppearance^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::BluetoothLEAppearance^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAppearance(winRtInstance));
    }





    static void FromRawValue(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          ::Windows::Devices::Bluetooth::BluetoothLEAppearance^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothLEAppearance::FromRawValue(arg0);
          info.GetReturnValue().Set(WrapBluetoothLEAppearance(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void FromParts(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 2
        && info[0]->IsInt32()
        && info[1]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          unsigned short arg1 = static_cast<unsigned short>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          ::Windows::Devices::Bluetooth::BluetoothLEAppearance^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothLEAppearance::FromParts(arg0, arg1);
          info.GetReturnValue().Set(WrapBluetoothLEAppearance(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CategoryGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEAppearance^>(info.This())) {
        return;
      }

      BluetoothLEAppearance *wrapper = BluetoothLEAppearance::Unwrap<BluetoothLEAppearance>(info.This());

      try  {
        unsigned short result = wrapper->_instance->Category;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void RawValueGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEAppearance^>(info.This())) {
        return;
      }

      BluetoothLEAppearance *wrapper = BluetoothLEAppearance::Unwrap<BluetoothLEAppearance>(info.This());

      try  {
        unsigned short result = wrapper->_instance->RawValue;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SubCategoryGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEAppearance^>(info.This())) {
        return;
      }

      BluetoothLEAppearance *wrapper = BluetoothLEAppearance::Unwrap<BluetoothLEAppearance>(info.This());

      try  {
        unsigned short result = wrapper->_instance->SubCategory;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::BluetoothLEAppearance^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAppearance(::Windows::Devices::Bluetooth::BluetoothLEAppearance^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::BluetoothLEAppearance^ UnwrapBluetoothLEAppearance(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAppearance::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAppearance(::Windows::Devices::Bluetooth::BluetoothLEAppearance^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAppearance::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::BluetoothLEAppearance^ UnwrapBluetoothLEAppearance(Local<Value> value) {
     return BluetoothLEAppearance::Unwrap<BluetoothLEAppearance>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAppearance(Local<Object> exports) {
    BluetoothLEAppearance::Init(exports);
  }

  class BluetoothLEAppearanceCategories : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAppearanceCategories").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetAccessor(constructor, Nan::New<String>("barcodeScanner").ToLocalChecked(), BarcodeScannerGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("bloodPressure").ToLocalChecked(), BloodPressureGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("clock").ToLocalChecked(), ClockGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("computer").ToLocalChecked(), ComputerGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cycling").ToLocalChecked(), CyclingGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("display").ToLocalChecked(), DisplayGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("eyeGlasses").ToLocalChecked(), EyeGlassesGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("glucoseMeter").ToLocalChecked(), GlucoseMeterGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("heartRate").ToLocalChecked(), HeartRateGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("humanInterfaceDevice").ToLocalChecked(), HumanInterfaceDeviceGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("keyring").ToLocalChecked(), KeyringGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("mediaPlayer").ToLocalChecked(), MediaPlayerGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("outdoorSportActivity").ToLocalChecked(), OutdoorSportActivityGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("phone").ToLocalChecked(), PhoneGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("pulseOximeter").ToLocalChecked(), PulseOximeterGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("remoteControl").ToLocalChecked(), RemoteControlGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("runningWalking").ToLocalChecked(), RunningWalkingGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("tag").ToLocalChecked(), TagGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("thermometer").ToLocalChecked(), ThermometerGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("uncategorized").ToLocalChecked(), UncategorizedGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("watch").ToLocalChecked(), WatchGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("weightScale").ToLocalChecked(), WeightScaleGetter);


        Nan::Set(exports, Nan::New<String>("BluetoothLEAppearanceCategories").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAppearanceCategories(::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAppearanceCategories *wrapperInstance = new BluetoothLEAppearanceCategories(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAppearanceCategories(winRtInstance));
    }







    static void BarcodeScannerGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::BarcodeScanner;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void BloodPressureGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::BloodPressure;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ClockGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Clock;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ComputerGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Computer;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CyclingGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Cycling;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void DisplayGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Display;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void EyeGlassesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::EyeGlasses;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GlucoseMeterGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::GlucoseMeter;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void HeartRateGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::HeartRate;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void HumanInterfaceDeviceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::HumanInterfaceDevice;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void KeyringGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Keyring;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void MediaPlayerGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::MediaPlayer;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void OutdoorSportActivityGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::OutdoorSportActivity;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void PhoneGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Phone;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void PulseOximeterGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::PulseOximeter;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RemoteControlGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::RemoteControl;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RunningWalkingGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::RunningWalking;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void TagGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Tag;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ThermometerGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Thermometer;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void UncategorizedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Uncategorized;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void WatchGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Watch;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void WeightScaleGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::WeightScale;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    private:
      ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAppearanceCategories(::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^ UnwrapBluetoothLEAppearanceCategories(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAppearanceCategories::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAppearanceCategories(::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAppearanceCategories::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories^ UnwrapBluetoothLEAppearanceCategories(Local<Value> value) {
     return BluetoothLEAppearanceCategories::Unwrap<BluetoothLEAppearanceCategories>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAppearanceCategories(Local<Object> exports) {
    BluetoothLEAppearanceCategories::Init(exports);
  }

  class BluetoothLEAppearanceSubcategories : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAppearanceSubcategories").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetAccessor(constructor, Nan::New<String>("barcodeScanner").ToLocalChecked(), BarcodeScannerGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("bloodPressureArm").ToLocalChecked(), BloodPressureArmGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("bloodPressureWrist").ToLocalChecked(), BloodPressureWristGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cardReader").ToLocalChecked(), CardReaderGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cyclingCadenceSensor").ToLocalChecked(), CyclingCadenceSensorGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cyclingComputer").ToLocalChecked(), CyclingComputerGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cyclingPowerSensor").ToLocalChecked(), CyclingPowerSensorGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cyclingSpeedCadenceSensor").ToLocalChecked(), CyclingSpeedCadenceSensorGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cyclingSpeedSensor").ToLocalChecked(), CyclingSpeedSensorGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("digitalPen").ToLocalChecked(), DigitalPenGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("digitizerTablet").ToLocalChecked(), DigitizerTabletGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("gamepad").ToLocalChecked(), GamepadGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("generic").ToLocalChecked(), GenericGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("heartRateBelt").ToLocalChecked(), HeartRateBeltGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("joystick").ToLocalChecked(), JoystickGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("keyboard").ToLocalChecked(), KeyboardGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("locationDisplay").ToLocalChecked(), LocationDisplayGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("locationNavigationDisplay").ToLocalChecked(), LocationNavigationDisplayGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("locationNavigationPod").ToLocalChecked(), LocationNavigationPodGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("locationPod").ToLocalChecked(), LocationPodGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("mouse").ToLocalChecked(), MouseGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("oximeterFingertip").ToLocalChecked(), OximeterFingertipGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("oximeterWristWorn").ToLocalChecked(), OximeterWristWornGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("runningWalkingInShoe").ToLocalChecked(), RunningWalkingInShoeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("runningWalkingOnHip").ToLocalChecked(), RunningWalkingOnHipGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("runningWalkingOnShoe").ToLocalChecked(), RunningWalkingOnShoeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("sportsWatch").ToLocalChecked(), SportsWatchGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("thermometerEar").ToLocalChecked(), ThermometerEarGetter);


        Nan::Set(exports, Nan::New<String>("BluetoothLEAppearanceSubcategories").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAppearanceSubcategories(::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAppearanceSubcategories *wrapperInstance = new BluetoothLEAppearanceSubcategories(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAppearanceSubcategories(winRtInstance));
    }







    static void BarcodeScannerGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::BarcodeScanner;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void BloodPressureArmGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::BloodPressureArm;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void BloodPressureWristGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::BloodPressureWrist;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CardReaderGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CardReader;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CyclingCadenceSensorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingCadenceSensor;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CyclingComputerGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingComputer;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CyclingPowerSensorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingPowerSensor;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CyclingSpeedCadenceSensorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingSpeedCadenceSensor;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CyclingSpeedSensorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingSpeedSensor;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void DigitalPenGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::DigitalPen;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void DigitizerTabletGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::DigitizerTablet;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GamepadGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Gamepad;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GenericGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Generic;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void HeartRateBeltGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::HeartRateBelt;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void JoystickGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Joystick;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void KeyboardGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Keyboard;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void LocationDisplayGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationDisplay;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void LocationNavigationDisplayGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationNavigationDisplay;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void LocationNavigationPodGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationNavigationPod;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void LocationPodGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationPod;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void MouseGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Mouse;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void OximeterFingertipGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::OximeterFingertip;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void OximeterWristWornGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::OximeterWristWorn;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RunningWalkingInShoeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::RunningWalkingInShoe;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RunningWalkingOnHipGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::RunningWalkingOnHip;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RunningWalkingOnShoeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::RunningWalkingOnShoe;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SportsWatchGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::SportsWatch;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ThermometerEarGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned short result = ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::ThermometerEar;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    private:
      ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAppearanceSubcategories(::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^ UnwrapBluetoothLEAppearanceSubcategories(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAppearanceSubcategories::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAppearanceSubcategories(::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAppearanceSubcategories::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories^ UnwrapBluetoothLEAppearanceSubcategories(Local<Value> value) {
     return BluetoothLEAppearanceSubcategories::Unwrap<BluetoothLEAppearanceSubcategories>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAppearanceSubcategories(Local<Object> exports) {
    BluetoothLEAppearanceSubcategories::Init(exports);
  }

  class BluetoothLEDevice : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEDevice").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "getGattService", GetGattService);
            Nan::SetPrototypeMethod(localRef, "close", Close);
          

          
            Nan::SetPrototypeMethod(localRef, "requestAccessAsync", RequestAccessAsync);
            Nan::SetPrototypeMethod(localRef, "getGattServicesAsync", GetGattServicesAsync);
            Nan::SetPrototypeMethod(localRef, "getGattServicesForUuidAsync", GetGattServicesForUuidAsync);
          

          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("bluetoothAddress").ToLocalChecked(), BluetoothAddressGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("connectionStatus").ToLocalChecked(), ConnectionStatusGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceId").ToLocalChecked(), DeviceIdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("gattServices").ToLocalChecked(), GattServicesGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("name").ToLocalChecked(), NameGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("appearance").ToLocalChecked(), AppearanceGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("bluetoothAddressType").ToLocalChecked(), BluetoothAddressTypeGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceInformation").ToLocalChecked(), DeviceInformationGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceAccessInformation").ToLocalChecked(), DeviceAccessInformationGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("bluetoothDeviceId").ToLocalChecked(), BluetoothDeviceIdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("wasSecureConnectionUsedForPairing").ToLocalChecked(), WasSecureConnectionUsedForPairingGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "getDeviceSelectorFromPairingState", GetDeviceSelectorFromPairingState);
        Nan::SetMethod(constructor, "getDeviceSelectorFromConnectionStatus", GetDeviceSelectorFromConnectionStatus);
        Nan::SetMethod(constructor, "getDeviceSelectorFromDeviceName", GetDeviceSelectorFromDeviceName);
        Nan::SetMethod(constructor, "getDeviceSelectorFromBluetoothAddress", GetDeviceSelectorFromBluetoothAddress);
        Nan::SetMethod(constructor, "getDeviceSelectorFromAppearance", GetDeviceSelectorFromAppearance);
        Nan::SetMethod(constructor, "getDeviceSelector", GetDeviceSelector);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(FromBluetoothAddressAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("fromBluetoothAddressAsync").ToLocalChecked(), func);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(FromIdAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("fromIdAsync").ToLocalChecked(), func);


        Nan::Set(exports, Nan::New<String>("BluetoothLEDevice").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEDevice(::Windows::Devices::Bluetooth::BluetoothLEDevice^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::BluetoothLEDevice^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::BluetoothLEDevice^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEDevice *wrapperInstance = new BluetoothLEDevice(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::BluetoothLEDevice^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::BluetoothLEDevice^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEDevice(winRtInstance));
    }

    static void RequestAccessAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Enumeration::DeviceAccessStatus>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->RequestAccessAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Enumeration::DeviceAccessStatus> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(static_cast<int>(result));
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void GetGattServicesAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetGattServicesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg0 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->GetGattServicesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Bluetooth.GenericAttributeProfile", "GattDeviceServicesResult", result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void GetGattServicesForUuidAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          op = wrapper->_instance->GetGattServicesForUuidAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && NodeRT::Utils::IsGuid(info[0])
        && info[1]->IsInt32())
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg1 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          op = wrapper->_instance->GetGattServicesForUuidAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Bluetooth.GenericAttributeProfile", "GattDeviceServicesResult", result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void GetGattService(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ result;
          result = wrapper->_instance->GetGattService(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Bluetooth.GenericAttributeProfile", "GattDeviceService", result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }


    static void FromBluetoothAddressAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::BluetoothLEDevice^>^ op;


      if (info.Length() == 3
          && info[0]->IsNumber()
          && info[1]->IsInt32())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          ::Windows::Devices::Bluetooth::BluetoothAddressType arg1 = static_cast<::Windows::Devices::Bluetooth::BluetoothAddressType>(Nan::To<int32_t>(info[1]).FromMaybe(0));
            
          op = ::Windows::Devices::Bluetooth::BluetoothLEDevice::FromBluetoothAddressAsync(arg0,arg1);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 2
          && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
            
          op = ::Windows::Devices::Bluetooth::BluetoothLEDevice::FromBluetoothAddressAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::BluetoothLEDevice^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapBluetoothLEDevice(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void FromIdAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::BluetoothLEDevice^>^ op;


      if (info.Length() == 2
          && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
            
          op = ::Windows::Devices::Bluetooth::BluetoothLEDevice::FromIdAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::BluetoothLEDevice^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapBluetoothLEDevice(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void GetDeviceSelectorFromPairingState(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsBoolean())
      {
        try
        {
          bool arg0 = Nan::To<bool>(info[0]).FromMaybe(false);
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromPairingState(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelectorFromConnectionStatus(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothConnectionStatus arg0 = static_cast<::Windows::Devices::Bluetooth::BluetoothConnectionStatus>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromConnectionStatus(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelectorFromDeviceName(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromDeviceName(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelectorFromBluetoothAddress(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromBluetoothAddress(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsNumber()
        && info[1]->IsInt32())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          ::Windows::Devices::Bluetooth::BluetoothAddressType arg1 = static_cast<::Windows::Devices::Bluetooth::BluetoothAddressType>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromBluetoothAddress(arg0, arg1);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelectorFromAppearance(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEAppearance^>(info[0]))
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothLEAppearance^ arg0 = UnwrapBluetoothLEAppearance(info[0]);
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromAppearance(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelector(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0)
      {
        try
        {
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelector();
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void BluetoothAddressGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->BluetoothAddress;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ConnectionStatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothConnectionStatus result = wrapper->_instance->ConnectionStatus;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DeviceIdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->DeviceId;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void GattServicesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>^ result = wrapper->_instance->GattServices;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ val) -> Local<Value> {
              return NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Bluetooth.GenericAttributeProfile", "GattDeviceService", val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ {
              return dynamic_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(NodeRT::Utils::GetObjectInstance(value));
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void NameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Name;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void AppearanceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothLEAppearance^ result = wrapper->_instance->Appearance;
        info.GetReturnValue().Set(WrapBluetoothLEAppearance(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void BluetoothAddressTypeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothAddressType result = wrapper->_instance->BluetoothAddressType;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DeviceInformationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceInformation^ result = wrapper->_instance->DeviceInformation;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Enumeration", "DeviceInformation", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DeviceAccessInformationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceAccessInformation^ result = wrapper->_instance->DeviceAccessInformation;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Enumeration", "DeviceAccessInformation", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void BluetoothDeviceIdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothDeviceId^ result = wrapper->_instance->BluetoothDeviceId;
        info.GetReturnValue().Set(WrapBluetoothDeviceId(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void WasSecureConnectionUsedForPairingGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This())) {
        return;
      }

      BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());

      try  {
        bool result = wrapper->_instance->WasSecureConnectionUsedForPairing;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"connectionStatusChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->ConnectionStatusChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::BluetoothLEDevice^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::BluetoothLEDevice^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapBluetoothLEDevice(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"gattServicesChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->GattServicesChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::BluetoothLEDevice^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::BluetoothLEDevice^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapBluetoothLEDevice(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"nameChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->NameChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::BluetoothLEDevice^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::BluetoothLEDevice^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapBluetoothLEDevice(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"connectionStatusChanged", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"gattServicesChanged", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"nameChanged", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"connectionStatusChanged", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());
          wrapper->_instance->ConnectionStatusChanged::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"gattServicesChanged", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());
          wrapper->_instance->GattServicesChanged::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"nameChanged", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothLEDevice^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          BluetoothLEDevice *wrapper = BluetoothLEDevice::Unwrap<BluetoothLEDevice>(info.This());
          wrapper->_instance->NameChanged::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Bluetooth::BluetoothLEDevice^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEDevice(::Windows::Devices::Bluetooth::BluetoothLEDevice^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::BluetoothLEDevice^ UnwrapBluetoothLEDevice(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEDevice::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEDevice(::Windows::Devices::Bluetooth::BluetoothLEDevice^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEDevice::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::BluetoothLEDevice^ UnwrapBluetoothLEDevice(Local<Value> value) {
     return BluetoothLEDevice::Unwrap<BluetoothLEDevice>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEDevice(Local<Object> exports) {
    BluetoothLEDevice::Init(exports);
  }

  class BluetoothSignalStrengthFilter : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothSignalStrengthFilter").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("samplingInterval").ToLocalChecked(), SamplingIntervalGetter, SamplingIntervalSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("outOfRangeTimeout").ToLocalChecked(), OutOfRangeTimeoutGetter, OutOfRangeTimeoutSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("outOfRangeThresholdInDBm").ToLocalChecked(), OutOfRangeThresholdInDBmGetter, OutOfRangeThresholdInDBmSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("inRangeThresholdInDBm").ToLocalChecked(), InRangeThresholdInDBmGetter, InRangeThresholdInDBmSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("BluetoothSignalStrengthFilter").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothSignalStrengthFilter(::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothSignalStrengthFilter *wrapperInstance = new BluetoothSignalStrengthFilter(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothSignalStrengthFilter(winRtInstance));
    }





    static void SamplingIntervalGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^>(info.This())) {
        return;
      }

      BluetoothSignalStrengthFilter *wrapper = BluetoothSignalStrengthFilter::Unwrap<BluetoothSignalStrengthFilter>(info.This());

      try  {
        ::Platform::IBox<::Windows::Foundation::TimeSpan>^ result = wrapper->_instance->SamplingInterval;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Number>(result->Value.Duration/10000.0)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SamplingIntervalSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsNumber()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^>(info.This())) {
        return;
      }

      BluetoothSignalStrengthFilter *wrapper = BluetoothSignalStrengthFilter::Unwrap<BluetoothSignalStrengthFilter>(info.This());

      try {

        ::Platform::IBox<::Windows::Foundation::TimeSpan>^ winRtValue = ref new ::Platform::Box<::Windows::Foundation::TimeSpan>(NodeRT::Utils::TimeSpanFromMilli(Nan::To<int64_t>(value).FromMaybe(0)));

        wrapper->_instance->SamplingInterval = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void OutOfRangeTimeoutGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^>(info.This())) {
        return;
      }

      BluetoothSignalStrengthFilter *wrapper = BluetoothSignalStrengthFilter::Unwrap<BluetoothSignalStrengthFilter>(info.This());

      try  {
        ::Platform::IBox<::Windows::Foundation::TimeSpan>^ result = wrapper->_instance->OutOfRangeTimeout;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Number>(result->Value.Duration/10000.0)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void OutOfRangeTimeoutSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsNumber()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^>(info.This())) {
        return;
      }

      BluetoothSignalStrengthFilter *wrapper = BluetoothSignalStrengthFilter::Unwrap<BluetoothSignalStrengthFilter>(info.This());

      try {

        ::Platform::IBox<::Windows::Foundation::TimeSpan>^ winRtValue = ref new ::Platform::Box<::Windows::Foundation::TimeSpan>(NodeRT::Utils::TimeSpanFromMilli(Nan::To<int64_t>(value).FromMaybe(0)));

        wrapper->_instance->OutOfRangeTimeout = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void OutOfRangeThresholdInDBmGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^>(info.This())) {
        return;
      }

      BluetoothSignalStrengthFilter *wrapper = BluetoothSignalStrengthFilter::Unwrap<BluetoothSignalStrengthFilter>(info.This());

      try  {
        ::Platform::IBox<short>^ result = wrapper->_instance->OutOfRangeThresholdInDBm;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void OutOfRangeThresholdInDBmSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^>(info.This())) {
        return;
      }

      BluetoothSignalStrengthFilter *wrapper = BluetoothSignalStrengthFilter::Unwrap<BluetoothSignalStrengthFilter>(info.This());

      try {

        ::Platform::IBox<short>^ winRtValue = ref new ::Platform::Box<short>(static_cast<short>(Nan::To<int32_t>(value).FromMaybe(0)));

        wrapper->_instance->OutOfRangeThresholdInDBm = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void InRangeThresholdInDBmGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^>(info.This())) {
        return;
      }

      BluetoothSignalStrengthFilter *wrapper = BluetoothSignalStrengthFilter::Unwrap<BluetoothSignalStrengthFilter>(info.This());

      try  {
        ::Platform::IBox<short>^ result = wrapper->_instance->InRangeThresholdInDBm;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void InRangeThresholdInDBmSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^>(info.This())) {
        return;
      }

      BluetoothSignalStrengthFilter *wrapper = BluetoothSignalStrengthFilter::Unwrap<BluetoothSignalStrengthFilter>(info.This());

      try {

        ::Platform::IBox<short>^ winRtValue = ref new ::Platform::Box<short>(static_cast<short>(Nan::To<int32_t>(value).FromMaybe(0)));

        wrapper->_instance->InRangeThresholdInDBm = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothSignalStrengthFilter(::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^ UnwrapBluetoothSignalStrengthFilter(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothSignalStrengthFilter::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothSignalStrengthFilter(::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothSignalStrengthFilter::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^ UnwrapBluetoothSignalStrengthFilter(Local<Value> value) {
     return BluetoothSignalStrengthFilter::Unwrap<BluetoothSignalStrengthFilter>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothSignalStrengthFilter(Local<Object> exports) {
    BluetoothSignalStrengthFilter::Init(exports);
  }

  class BluetoothUuidHelper : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothUuidHelper").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "fromShortId", FromShortId);
        Nan::SetMethod(constructor, "tryGetShortId", TryGetShortId);


        Nan::Set(exports, Nan::New<String>("BluetoothUuidHelper").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothUuidHelper(::Windows::Devices::Bluetooth::BluetoothUuidHelper^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::BluetoothUuidHelper^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothUuidHelper^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::BluetoothUuidHelper^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothUuidHelper *wrapperInstance = new BluetoothUuidHelper(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothUuidHelper^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::BluetoothUuidHelper^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::BluetoothUuidHelper^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothUuidHelper(winRtInstance));
    }





    static void FromShortId(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          ::Platform::Guid result;
          result = ::Windows::Devices::Bluetooth::BluetoothUuidHelper::FromShortId(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void TryGetShortId(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          ::Platform::IBox<unsigned int>^ result;
          result = ::Windows::Devices::Bluetooth::BluetoothUuidHelper::TryGetShortId(arg0);
          info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    private:
      ::Windows::Devices::Bluetooth::BluetoothUuidHelper^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothUuidHelper(::Windows::Devices::Bluetooth::BluetoothUuidHelper^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::BluetoothUuidHelper^ UnwrapBluetoothUuidHelper(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothUuidHelper::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothUuidHelper(::Windows::Devices::Bluetooth::BluetoothUuidHelper^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothUuidHelper::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::BluetoothUuidHelper^ UnwrapBluetoothUuidHelper(Local<Value> value) {
     return BluetoothUuidHelper::Unwrap<BluetoothUuidHelper>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothUuidHelper(Local<Object> exports) {
    BluetoothUuidHelper::Init(exports);
  }

} } } }

namespace NodeRT { namespace Windows { namespace Devices { namespace Bluetooth { namespace Advertisement { 
  v8::Local<v8::Value> WrapBluetoothLEAdvertisement(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ wintRtInstance);
  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ UnwrapBluetoothLEAdvertisement(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEAdvertisementBytePattern(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^ wintRtInstance);
  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^ UnwrapBluetoothLEAdvertisementBytePattern(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEAdvertisementDataSection(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ wintRtInstance);
  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ UnwrapBluetoothLEAdvertisementDataSection(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEAdvertisementDataTypes(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^ wintRtInstance);
  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^ UnwrapBluetoothLEAdvertisementDataTypes(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEAdvertisementFilter(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ wintRtInstance);
  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ UnwrapBluetoothLEAdvertisementFilter(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEAdvertisementPublisher(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^ wintRtInstance);
  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^ UnwrapBluetoothLEAdvertisementPublisher(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEAdvertisementPublisherStatusChangedEventArgs(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^ wintRtInstance);
  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^ UnwrapBluetoothLEAdvertisementPublisherStatusChangedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEAdvertisementReceivedEventArgs(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^ wintRtInstance);
  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^ UnwrapBluetoothLEAdvertisementReceivedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEAdvertisementWatcher(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^ wintRtInstance);
  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^ UnwrapBluetoothLEAdvertisementWatcher(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEAdvertisementWatcherStoppedEventArgs(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^ wintRtInstance);
  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^ UnwrapBluetoothLEAdvertisementWatcherStoppedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapBluetoothLEManufacturerData(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ wintRtInstance);
  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ UnwrapBluetoothLEManufacturerData(Local<Value> value);
  



  static void InitBluetoothLEAdvertisementFlagsEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementFlags").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("none").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFlags::None)));
    Nan::Set(enumObject, Nan::New<String>("limitedDiscoverableMode").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFlags::LimitedDiscoverableMode)));
    Nan::Set(enumObject, Nan::New<String>("generalDiscoverableMode").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFlags::GeneralDiscoverableMode)));
    Nan::Set(enumObject, Nan::New<String>("classicNotSupported").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFlags::ClassicNotSupported)));
    Nan::Set(enumObject, Nan::New<String>("dualModeControllerCapable").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFlags::DualModeControllerCapable)));
    Nan::Set(enumObject, Nan::New<String>("dualModeHostCapable").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFlags::DualModeHostCapable)));
  }

  static void InitBluetoothLEAdvertisementPublisherStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementPublisherStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("created").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatus::Created)));
    Nan::Set(enumObject, Nan::New<String>("waiting").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatus::Waiting)));
    Nan::Set(enumObject, Nan::New<String>("started").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatus::Started)));
    Nan::Set(enumObject, Nan::New<String>("stopping").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatus::Stopping)));
    Nan::Set(enumObject, Nan::New<String>("stopped").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatus::Stopped)));
    Nan::Set(enumObject, Nan::New<String>("aborted").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatus::Aborted)));
  }

  static void InitBluetoothLEAdvertisementTypeEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementType").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("connectableUndirected").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementType::ConnectableUndirected)));
    Nan::Set(enumObject, Nan::New<String>("connectableDirected").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementType::ConnectableDirected)));
    Nan::Set(enumObject, Nan::New<String>("scannableUndirected").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementType::ScannableUndirected)));
    Nan::Set(enumObject, Nan::New<String>("nonConnectableUndirected").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementType::NonConnectableUndirected)));
    Nan::Set(enumObject, Nan::New<String>("scanResponse").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementType::ScanResponse)));
    Nan::Set(enumObject, Nan::New<String>("extended").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementType::Extended)));
  }

  static void InitBluetoothLEAdvertisementWatcherStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementWatcherStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("created").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStatus::Created)));
    Nan::Set(enumObject, Nan::New<String>("started").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStatus::Started)));
    Nan::Set(enumObject, Nan::New<String>("stopping").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStatus::Stopping)));
    Nan::Set(enumObject, Nan::New<String>("stopped").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStatus::Stopped)));
    Nan::Set(enumObject, Nan::New<String>("aborted").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStatus::Aborted)));
  }

  static void InitBluetoothLEScanningModeEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("BluetoothLEScanningMode").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("passive").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEScanningMode::Passive)));
    Nan::Set(enumObject, Nan::New<String>("active").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEScanningMode::Active)));
    Nan::Set(enumObject, Nan::New<String>("none").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEScanningMode::None)));
  }



  class BluetoothLEAdvertisement : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAdvertisement").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "getManufacturerDataByCompanyId", GetManufacturerDataByCompanyId);
            Nan::SetPrototypeMethod(localRef, "getSectionsByType", GetSectionsByType);
          



          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("localName").ToLocalChecked(), LocalNameGetter, LocalNameSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("flags").ToLocalChecked(), FlagsGetter, FlagsSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("dataSections").ToLocalChecked(), DataSectionsGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("manufacturerData").ToLocalChecked(), ManufacturerDataGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("serviceUuids").ToLocalChecked(), ServiceUuidsGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisement").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAdvertisement(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAdvertisement *wrapperInstance = new BluetoothLEAdvertisement(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAdvertisement(winRtInstance));
    }


    static void GetManufacturerDataByCompanyId(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisement *wrapper = BluetoothLEAdvertisement::Unwrap<BluetoothLEAdvertisement>(info.This());

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^>^ result;
          result = wrapper->_instance->GetManufacturerDataByCompanyId(arg0);
          info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ val) -> Local<Value> {
              return WrapBluetoothLEManufacturerData(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ {
              return UnwrapBluetoothLEManufacturerData(value);
            }
          ));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetSectionsByType(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisement *wrapper = BluetoothLEAdvertisement::Unwrap<BluetoothLEAdvertisement>(info.This());

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned char arg0 = static_cast<unsigned char>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^>^ result;
          result = wrapper->_instance->GetSectionsByType(arg0);
          info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ val) -> Local<Value> {
              return WrapBluetoothLEAdvertisementDataSection(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ {
              return UnwrapBluetoothLEAdvertisementDataSection(value);
            }
          ));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void LocalNameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisement *wrapper = BluetoothLEAdvertisement::Unwrap<BluetoothLEAdvertisement>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->LocalName;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void LocalNameSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsString()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisement *wrapper = BluetoothLEAdvertisement::Unwrap<BluetoothLEAdvertisement>(info.This());

      try {

        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));

        wrapper->_instance->LocalName = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void FlagsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisement *wrapper = BluetoothLEAdvertisement::Unwrap<BluetoothLEAdvertisement>(info.This());

      try  {
        ::Platform::IBox<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFlags>^ result = wrapper->_instance->Flags;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(static_cast<int>(result->Value))) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void FlagsSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisement *wrapper = BluetoothLEAdvertisement::Unwrap<BluetoothLEAdvertisement>(info.This());

      try {

        ::Platform::IBox<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFlags>^ winRtValue = ref new ::Platform::Box<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFlags>(static_cast<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFlags>(Nan::To<int32_t>(value).FromMaybe(0)));

        wrapper->_instance->Flags = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void DataSectionsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisement *wrapper = BluetoothLEAdvertisement::Unwrap<BluetoothLEAdvertisement>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVector<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^>^ result = wrapper->_instance->DataSections;
        info.GetReturnValue().Set(NodeRT::Collections::VectorWrapper<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^>::CreateVectorWrapper(result, 
            [](::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ val) -> Local<Value> {
              return WrapBluetoothLEAdvertisementDataSection(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ {
              return UnwrapBluetoothLEAdvertisementDataSection(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ManufacturerDataGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisement *wrapper = BluetoothLEAdvertisement::Unwrap<BluetoothLEAdvertisement>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVector<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^>^ result = wrapper->_instance->ManufacturerData;
        info.GetReturnValue().Set(NodeRT::Collections::VectorWrapper<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^>::CreateVectorWrapper(result, 
            [](::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ val) -> Local<Value> {
              return WrapBluetoothLEManufacturerData(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ {
              return UnwrapBluetoothLEManufacturerData(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ServiceUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisement *wrapper = BluetoothLEAdvertisement::Unwrap<BluetoothLEAdvertisement>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVector<::Platform::Guid>^ result = wrapper->_instance->ServiceUuids;
        info.GetReturnValue().Set(NodeRT::Collections::VectorWrapper<::Platform::Guid>::CreateVectorWrapper(result, 
            [](::Platform::Guid val) -> Local<Value> {
              return NodeRT::Utils::GuidToJs(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsGuid(value);
            },
            [](Local<Value> value) -> ::Platform::Guid {
              return NodeRT::Utils::GuidFromJs(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAdvertisement(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ UnwrapBluetoothLEAdvertisement(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAdvertisement::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAdvertisement(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAdvertisement::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ UnwrapBluetoothLEAdvertisement(Local<Value> value) {
     return BluetoothLEAdvertisement::Unwrap<BluetoothLEAdvertisement>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAdvertisement(Local<Object> exports) {
    BluetoothLEAdvertisement::Init(exports);
  }

  class BluetoothLEAdvertisementBytePattern : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAdvertisementBytePattern").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("offset").ToLocalChecked(), OffsetGetter, OffsetSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("dataType").ToLocalChecked(), DataTypeGetter, DataTypeSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("data").ToLocalChecked(), DataGetter, DataSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementBytePattern").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAdvertisementBytePattern(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && info[0]->IsInt32()
        && info[1]->IsInt32()
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[2]))
      {
        try {
          unsigned char arg0 = static_cast<unsigned char>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          short arg1 = static_cast<short>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          ::Windows::Storage::Streams::IBuffer^ arg2 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[2]));
          
          winRtInstance = ref new ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern(arg0,arg1,arg2);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAdvertisementBytePattern *wrapperInstance = new BluetoothLEAdvertisementBytePattern(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAdvertisementBytePattern(winRtInstance));
    }





    static void OffsetGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementBytePattern *wrapper = BluetoothLEAdvertisementBytePattern::Unwrap<BluetoothLEAdvertisementBytePattern>(info.This());

      try  {
        short result = wrapper->_instance->Offset;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void OffsetSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementBytePattern *wrapper = BluetoothLEAdvertisementBytePattern::Unwrap<BluetoothLEAdvertisementBytePattern>(info.This());

      try {

        short winRtValue = static_cast<short>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->Offset = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void DataTypeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementBytePattern *wrapper = BluetoothLEAdvertisementBytePattern::Unwrap<BluetoothLEAdvertisementBytePattern>(info.This());

      try  {
        unsigned char result = wrapper->_instance->DataType;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DataTypeSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementBytePattern *wrapper = BluetoothLEAdvertisementBytePattern::Unwrap<BluetoothLEAdvertisementBytePattern>(info.This());

      try {

        unsigned char winRtValue = static_cast<unsigned char>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->DataType = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void DataGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementBytePattern *wrapper = BluetoothLEAdvertisementBytePattern::Unwrap<BluetoothLEAdvertisementBytePattern>(info.This());

      try  {
        ::Windows::Storage::Streams::IBuffer^ result = wrapper->_instance->Data;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DataSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementBytePattern *wrapper = BluetoothLEAdvertisementBytePattern::Unwrap<BluetoothLEAdvertisementBytePattern>(info.This());

      try {

        ::Windows::Storage::Streams::IBuffer^ winRtValue = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->Data = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAdvertisementBytePattern(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^ UnwrapBluetoothLEAdvertisementBytePattern(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAdvertisementBytePattern::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAdvertisementBytePattern(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAdvertisementBytePattern::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^ UnwrapBluetoothLEAdvertisementBytePattern(Local<Value> value) {
     return BluetoothLEAdvertisementBytePattern::Unwrap<BluetoothLEAdvertisementBytePattern>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAdvertisementBytePattern(Local<Object> exports) {
    BluetoothLEAdvertisementBytePattern::Init(exports);
  }

  class BluetoothLEAdvertisementDataSection : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAdvertisementDataSection").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("dataType").ToLocalChecked(), DataTypeGetter, DataTypeSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("data").ToLocalChecked(), DataGetter, DataSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementDataSection").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAdvertisementDataSection(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsInt32()
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[1]))
      {
        try {
          unsigned char arg0 = static_cast<unsigned char>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          ::Windows::Storage::Streams::IBuffer^ arg1 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[1]));
          
          winRtInstance = ref new ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection(arg0,arg1);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAdvertisementDataSection *wrapperInstance = new BluetoothLEAdvertisementDataSection(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAdvertisementDataSection(winRtInstance));
    }





    static void DataTypeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementDataSection *wrapper = BluetoothLEAdvertisementDataSection::Unwrap<BluetoothLEAdvertisementDataSection>(info.This());

      try  {
        unsigned char result = wrapper->_instance->DataType;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DataTypeSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementDataSection *wrapper = BluetoothLEAdvertisementDataSection::Unwrap<BluetoothLEAdvertisementDataSection>(info.This());

      try {

        unsigned char winRtValue = static_cast<unsigned char>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->DataType = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void DataGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementDataSection *wrapper = BluetoothLEAdvertisementDataSection::Unwrap<BluetoothLEAdvertisementDataSection>(info.This());

      try  {
        ::Windows::Storage::Streams::IBuffer^ result = wrapper->_instance->Data;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DataSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementDataSection *wrapper = BluetoothLEAdvertisementDataSection::Unwrap<BluetoothLEAdvertisementDataSection>(info.This());

      try {

        ::Windows::Storage::Streams::IBuffer^ winRtValue = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->Data = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAdvertisementDataSection(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ UnwrapBluetoothLEAdvertisementDataSection(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAdvertisementDataSection::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAdvertisementDataSection(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAdvertisementDataSection::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection^ UnwrapBluetoothLEAdvertisementDataSection(Local<Value> value) {
     return BluetoothLEAdvertisementDataSection::Unwrap<BluetoothLEAdvertisementDataSection>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAdvertisementDataSection(Local<Object> exports) {
    BluetoothLEAdvertisementDataSection::Init(exports);
  }

  class BluetoothLEAdvertisementDataTypes : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAdvertisementDataTypes").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetAccessor(constructor, Nan::New<String>("advertisingInterval").ToLocalChecked(), AdvertisingIntervalGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("appearance").ToLocalChecked(), AppearanceGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("completeLocalName").ToLocalChecked(), CompleteLocalNameGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("completeService128BitUuids").ToLocalChecked(), CompleteService128BitUuidsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("completeService16BitUuids").ToLocalChecked(), CompleteService16BitUuidsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("completeService32BitUuids").ToLocalChecked(), CompleteService32BitUuidsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("flags").ToLocalChecked(), FlagsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("incompleteService128BitUuids").ToLocalChecked(), IncompleteService128BitUuidsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("incompleteService16BitUuids").ToLocalChecked(), IncompleteService16BitUuidsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("incompleteService32BitUuids").ToLocalChecked(), IncompleteService32BitUuidsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("manufacturerSpecificData").ToLocalChecked(), ManufacturerSpecificDataGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("publicTargetAddress").ToLocalChecked(), PublicTargetAddressGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("randomTargetAddress").ToLocalChecked(), RandomTargetAddressGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("serviceData128BitUuids").ToLocalChecked(), ServiceData128BitUuidsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("serviceData16BitUuids").ToLocalChecked(), ServiceData16BitUuidsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("serviceData32BitUuids").ToLocalChecked(), ServiceData32BitUuidsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("serviceSolicitation128BitUuids").ToLocalChecked(), ServiceSolicitation128BitUuidsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("serviceSolicitation16BitUuids").ToLocalChecked(), ServiceSolicitation16BitUuidsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("serviceSolicitation32BitUuids").ToLocalChecked(), ServiceSolicitation32BitUuidsGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("shortenedLocalName").ToLocalChecked(), ShortenedLocalNameGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("slaveConnectionIntervalRange").ToLocalChecked(), SlaveConnectionIntervalRangeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("txPowerLevel").ToLocalChecked(), TxPowerLevelGetter);


        Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementDataTypes").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAdvertisementDataTypes(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAdvertisementDataTypes *wrapperInstance = new BluetoothLEAdvertisementDataTypes(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAdvertisementDataTypes(winRtInstance));
    }







    static void AdvertisingIntervalGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::AdvertisingInterval;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void AppearanceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::Appearance;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CompleteLocalNameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::CompleteLocalName;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CompleteService128BitUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::CompleteService128BitUuids;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CompleteService16BitUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::CompleteService16BitUuids;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CompleteService32BitUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::CompleteService32BitUuids;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void FlagsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::Flags;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void IncompleteService128BitUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::IncompleteService128BitUuids;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void IncompleteService16BitUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::IncompleteService16BitUuids;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void IncompleteService32BitUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::IncompleteService32BitUuids;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ManufacturerSpecificDataGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ManufacturerSpecificData;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void PublicTargetAddressGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::PublicTargetAddress;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RandomTargetAddressGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::RandomTargetAddress;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ServiceData128BitUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ServiceData128BitUuids;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ServiceData16BitUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ServiceData16BitUuids;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ServiceData32BitUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ServiceData32BitUuids;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ServiceSolicitation128BitUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ServiceSolicitation128BitUuids;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ServiceSolicitation16BitUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ServiceSolicitation16BitUuids;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ServiceSolicitation32BitUuidsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ServiceSolicitation32BitUuids;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ShortenedLocalNameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ShortenedLocalName;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SlaveConnectionIntervalRangeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::SlaveConnectionIntervalRange;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void TxPowerLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::TxPowerLevel;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    private:
      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAdvertisementDataTypes(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^ UnwrapBluetoothLEAdvertisementDataTypes(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAdvertisementDataTypes::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAdvertisementDataTypes(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAdvertisementDataTypes::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes^ UnwrapBluetoothLEAdvertisementDataTypes(Local<Value> value) {
     return BluetoothLEAdvertisementDataTypes::Unwrap<BluetoothLEAdvertisementDataTypes>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAdvertisementDataTypes(Local<Object> exports) {
    BluetoothLEAdvertisementDataTypes::Init(exports);
  }

  class BluetoothLEAdvertisementFilter : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAdvertisementFilter").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("advertisement").ToLocalChecked(), AdvertisementGetter, AdvertisementSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("bytePatterns").ToLocalChecked(), BytePatternsGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementFilter").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAdvertisementFilter(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAdvertisementFilter *wrapperInstance = new BluetoothLEAdvertisementFilter(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAdvertisementFilter(winRtInstance));
    }





    static void AdvertisementGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementFilter *wrapper = BluetoothLEAdvertisementFilter::Unwrap<BluetoothLEAdvertisementFilter>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ result = wrapper->_instance->Advertisement;
        info.GetReturnValue().Set(WrapBluetoothLEAdvertisement(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void AdvertisementSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementFilter *wrapper = BluetoothLEAdvertisementFilter::Unwrap<BluetoothLEAdvertisementFilter>(info.This());

      try {

        ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ winRtValue = dynamic_cast<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->Advertisement = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void BytePatternsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementFilter *wrapper = BluetoothLEAdvertisementFilter::Unwrap<BluetoothLEAdvertisementFilter>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVector<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^>^ result = wrapper->_instance->BytePatterns;
        info.GetReturnValue().Set(NodeRT::Collections::VectorWrapper<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^>::CreateVectorWrapper(result, 
            [](::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^ val) -> Local<Value> {
              return WrapBluetoothLEAdvertisementBytePattern(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern^ {
              return UnwrapBluetoothLEAdvertisementBytePattern(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAdvertisementFilter(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ UnwrapBluetoothLEAdvertisementFilter(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAdvertisementFilter::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAdvertisementFilter(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAdvertisementFilter::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ UnwrapBluetoothLEAdvertisementFilter(Local<Value> value) {
     return BluetoothLEAdvertisementFilter::Unwrap<BluetoothLEAdvertisementFilter>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAdvertisementFilter(Local<Object> exports) {
    BluetoothLEAdvertisementFilter::Init(exports);
  }

  class BluetoothLEAdvertisementPublisher : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAdvertisementPublisher").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "start", Start);
            Nan::SetPrototypeMethod(localRef, "stop", Stop);
          


          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("advertisement").ToLocalChecked(), AdvertisementGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("useExtendedAdvertisement").ToLocalChecked(), UseExtendedAdvertisementGetter, UseExtendedAdvertisementSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("preferredTransmitPowerLevelInDBm").ToLocalChecked(), PreferredTransmitPowerLevelInDBmGetter, PreferredTransmitPowerLevelInDBmSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isAnonymous").ToLocalChecked(), IsAnonymousGetter, IsAnonymousSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("includeTransmitPowerLevel").ToLocalChecked(), IncludeTransmitPowerLevelGetter, IncludeTransmitPowerLevelSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementPublisher").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAdvertisementPublisher(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^>(info[0]))
      {
        try {
          ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ arg0 = UnwrapBluetoothLEAdvertisement(info[0]);
          
          winRtInstance = ref new ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher(arg0);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAdvertisementPublisher *wrapperInstance = new BluetoothLEAdvertisementPublisher(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAdvertisementPublisher(winRtInstance));
    }


    static void Start(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Start();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Stop(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Stop();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void AdvertisementGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ result = wrapper->_instance->Advertisement;
        info.GetReturnValue().Set(WrapBluetoothLEAdvertisement(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UseExtendedAdvertisementGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());

      try  {
        bool result = wrapper->_instance->UseExtendedAdvertisement;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UseExtendedAdvertisementSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsBoolean()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());

      try {

        bool winRtValue = Nan::To<bool>(value).FromMaybe(false);

        wrapper->_instance->UseExtendedAdvertisement = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void PreferredTransmitPowerLevelInDBmGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());

      try  {
        ::Platform::IBox<short>^ result = wrapper->_instance->PreferredTransmitPowerLevelInDBm;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PreferredTransmitPowerLevelInDBmSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());

      try {

        ::Platform::IBox<short>^ winRtValue = ref new ::Platform::Box<short>(static_cast<short>(Nan::To<int32_t>(value).FromMaybe(0)));

        wrapper->_instance->PreferredTransmitPowerLevelInDBm = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void IsAnonymousGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());

      try  {
        bool result = wrapper->_instance->IsAnonymous;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsAnonymousSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsBoolean()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());

      try {

        bool winRtValue = Nan::To<bool>(value).FromMaybe(false);

        wrapper->_instance->IsAnonymous = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void IncludeTransmitPowerLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());

      try  {
        bool result = wrapper->_instance->IncludeTransmitPowerLevel;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IncludeTransmitPowerLevelSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsBoolean()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());

      try {

        bool winRtValue = Nan::To<bool>(value).FromMaybe(false);

        wrapper->_instance->IncludeTransmitPowerLevel = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"statusChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->StatusChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^, ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^ arg0, ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapBluetoothLEAdvertisementPublisher(arg0);
                  wrappedArg1 = WrapBluetoothLEAdvertisementPublisherStatusChangedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"statusChanged", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"statusChanged", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          BluetoothLEAdvertisementPublisher *wrapper = BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(info.This());
          wrapper->_instance->StatusChanged::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAdvertisementPublisher(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^ UnwrapBluetoothLEAdvertisementPublisher(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAdvertisementPublisher::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAdvertisementPublisher(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAdvertisementPublisher::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher^ UnwrapBluetoothLEAdvertisementPublisher(Local<Value> value) {
     return BluetoothLEAdvertisementPublisher::Unwrap<BluetoothLEAdvertisementPublisher>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAdvertisementPublisher(Local<Object> exports) {
    BluetoothLEAdvertisementPublisher::Init(exports);
  }

  class BluetoothLEAdvertisementPublisherStatusChangedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAdvertisementPublisherStatusChangedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("error").ToLocalChecked(), ErrorGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("selectedTransmitPowerLevelInDBm").ToLocalChecked(), SelectedTransmitPowerLevelInDBmGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementPublisherStatusChangedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAdvertisementPublisherStatusChangedEventArgs(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAdvertisementPublisherStatusChangedEventArgs *wrapperInstance = new BluetoothLEAdvertisementPublisherStatusChangedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAdvertisementPublisherStatusChangedEventArgs(winRtInstance));
    }





    static void ErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisherStatusChangedEventArgs *wrapper = BluetoothLEAdvertisementPublisherStatusChangedEventArgs::Unwrap<BluetoothLEAdvertisementPublisherStatusChangedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothError result = wrapper->_instance->Error;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisherStatusChangedEventArgs *wrapper = BluetoothLEAdvertisementPublisherStatusChangedEventArgs::Unwrap<BluetoothLEAdvertisementPublisherStatusChangedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SelectedTransmitPowerLevelInDBmGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementPublisherStatusChangedEventArgs *wrapper = BluetoothLEAdvertisementPublisherStatusChangedEventArgs::Unwrap<BluetoothLEAdvertisementPublisherStatusChangedEventArgs>(info.This());

      try  {
        ::Platform::IBox<short>^ result = wrapper->_instance->SelectedTransmitPowerLevelInDBm;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAdvertisementPublisherStatusChangedEventArgs(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^ UnwrapBluetoothLEAdvertisementPublisherStatusChangedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAdvertisementPublisherStatusChangedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAdvertisementPublisherStatusChangedEventArgs(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAdvertisementPublisherStatusChangedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs^ UnwrapBluetoothLEAdvertisementPublisherStatusChangedEventArgs(Local<Value> value) {
     return BluetoothLEAdvertisementPublisherStatusChangedEventArgs::Unwrap<BluetoothLEAdvertisementPublisherStatusChangedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAdvertisementPublisherStatusChangedEventArgs(Local<Object> exports) {
    BluetoothLEAdvertisementPublisherStatusChangedEventArgs::Init(exports);
  }

  class BluetoothLEAdvertisementReceivedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAdvertisementReceivedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("advertisement").ToLocalChecked(), AdvertisementGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("advertisementType").ToLocalChecked(), AdvertisementTypeGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("bluetoothAddress").ToLocalChecked(), BluetoothAddressGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("rawSignalStrengthInDBm").ToLocalChecked(), RawSignalStrengthInDBmGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("timestamp").ToLocalChecked(), TimestampGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("bluetoothAddressType").ToLocalChecked(), BluetoothAddressTypeGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isAnonymous").ToLocalChecked(), IsAnonymousGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isConnectable").ToLocalChecked(), IsConnectableGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isDirected").ToLocalChecked(), IsDirectedGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isScanResponse").ToLocalChecked(), IsScanResponseGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isScannable").ToLocalChecked(), IsScannableGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("transmitPowerLevelInDBm").ToLocalChecked(), TransmitPowerLevelInDBmGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementReceivedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAdvertisementReceivedEventArgs(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAdvertisementReceivedEventArgs *wrapperInstance = new BluetoothLEAdvertisementReceivedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAdvertisementReceivedEventArgs(winRtInstance));
    }





    static void AdvertisementGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementReceivedEventArgs *wrapper = BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement^ result = wrapper->_instance->Advertisement;
        info.GetReturnValue().Set(WrapBluetoothLEAdvertisement(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void AdvertisementTypeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementReceivedEventArgs *wrapper = BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementType result = wrapper->_instance->AdvertisementType;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void BluetoothAddressGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementReceivedEventArgs *wrapper = BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->BluetoothAddress;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void RawSignalStrengthInDBmGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementReceivedEventArgs *wrapper = BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(info.This());

      try  {
        short result = wrapper->_instance->RawSignalStrengthInDBm;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void TimestampGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementReceivedEventArgs *wrapper = BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(info.This());

      try  {
        ::Windows::Foundation::DateTime result = wrapper->_instance->Timestamp;
        info.GetReturnValue().Set(NodeRT::Utils::DateTimeToJS(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void BluetoothAddressTypeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementReceivedEventArgs *wrapper = BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothAddressType result = wrapper->_instance->BluetoothAddressType;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsAnonymousGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementReceivedEventArgs *wrapper = BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(info.This());

      try  {
        bool result = wrapper->_instance->IsAnonymous;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsConnectableGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementReceivedEventArgs *wrapper = BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(info.This());

      try  {
        bool result = wrapper->_instance->IsConnectable;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsDirectedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementReceivedEventArgs *wrapper = BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(info.This());

      try  {
        bool result = wrapper->_instance->IsDirected;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsScanResponseGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementReceivedEventArgs *wrapper = BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(info.This());

      try  {
        bool result = wrapper->_instance->IsScanResponse;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsScannableGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementReceivedEventArgs *wrapper = BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(info.This());

      try  {
        bool result = wrapper->_instance->IsScannable;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void TransmitPowerLevelInDBmGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementReceivedEventArgs *wrapper = BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(info.This());

      try  {
        ::Platform::IBox<short>^ result = wrapper->_instance->TransmitPowerLevelInDBm;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAdvertisementReceivedEventArgs(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^ UnwrapBluetoothLEAdvertisementReceivedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAdvertisementReceivedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAdvertisementReceivedEventArgs(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAdvertisementReceivedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^ UnwrapBluetoothLEAdvertisementReceivedEventArgs(Local<Value> value) {
     return BluetoothLEAdvertisementReceivedEventArgs::Unwrap<BluetoothLEAdvertisementReceivedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAdvertisementReceivedEventArgs(Local<Object> exports) {
    BluetoothLEAdvertisementReceivedEventArgs::Init(exports);
  }

  class BluetoothLEAdvertisementWatcher : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAdvertisementWatcher").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "start", Start);
            Nan::SetPrototypeMethod(localRef, "stop", Stop);
          


          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("signalStrengthFilter").ToLocalChecked(), SignalStrengthFilterGetter, SignalStrengthFilterSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("scanningMode").ToLocalChecked(), ScanningModeGetter, ScanningModeSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("advertisementFilter").ToLocalChecked(), AdvertisementFilterGetter, AdvertisementFilterSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("maxOutOfRangeTimeout").ToLocalChecked(), MaxOutOfRangeTimeoutGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("maxSamplingInterval").ToLocalChecked(), MaxSamplingIntervalGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("minOutOfRangeTimeout").ToLocalChecked(), MinOutOfRangeTimeoutGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("minSamplingInterval").ToLocalChecked(), MinSamplingIntervalGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("allowExtendedAdvertisements").ToLocalChecked(), AllowExtendedAdvertisementsGetter, AllowExtendedAdvertisementsSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementWatcher").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAdvertisementWatcher(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^>(info[0]))
      {
        try {
          ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ arg0 = UnwrapBluetoothLEAdvertisementFilter(info[0]);
          
          winRtInstance = ref new ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher(arg0);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAdvertisementWatcher *wrapperInstance = new BluetoothLEAdvertisementWatcher(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAdvertisementWatcher(winRtInstance));
    }


    static void Start(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Start();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Stop(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Stop();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void SignalStrengthFilterGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^ result = wrapper->_instance->SignalStrengthFilter;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Bluetooth", "BluetoothSignalStrengthFilter", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SignalStrengthFilterSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^>(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try {

        ::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^ winRtValue = dynamic_cast<::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->SignalStrengthFilter = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void ScanningModeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEScanningMode result = wrapper->_instance->ScanningMode;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ScanningModeSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try {

        ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEScanningMode winRtValue = static_cast<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEScanningMode>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->ScanningMode = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void AdvertisementFilterGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ result = wrapper->_instance->AdvertisementFilter;
        info.GetReturnValue().Set(WrapBluetoothLEAdvertisementFilter(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void AdvertisementFilterSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^>(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try {

        ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^ winRtValue = dynamic_cast<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->AdvertisementFilter = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void MaxOutOfRangeTimeoutGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try  {
        ::Windows::Foundation::TimeSpan result = wrapper->_instance->MaxOutOfRangeTimeout;
        info.GetReturnValue().Set(Nan::New<Number>(result.Duration/10000.0));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void MaxSamplingIntervalGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try  {
        ::Windows::Foundation::TimeSpan result = wrapper->_instance->MaxSamplingInterval;
        info.GetReturnValue().Set(Nan::New<Number>(result.Duration/10000.0));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void MinOutOfRangeTimeoutGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try  {
        ::Windows::Foundation::TimeSpan result = wrapper->_instance->MinOutOfRangeTimeout;
        info.GetReturnValue().Set(Nan::New<Number>(result.Duration/10000.0));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void MinSamplingIntervalGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try  {
        ::Windows::Foundation::TimeSpan result = wrapper->_instance->MinSamplingInterval;
        info.GetReturnValue().Set(Nan::New<Number>(result.Duration/10000.0));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void AllowExtendedAdvertisementsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try  {
        bool result = wrapper->_instance->AllowExtendedAdvertisements;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void AllowExtendedAdvertisementsSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsBoolean()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());

      try {

        bool winRtValue = Nan::To<bool>(value).FromMaybe(false);

        wrapper->_instance->AllowExtendedAdvertisements = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"received", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->Received::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^, ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^ arg0, ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapBluetoothLEAdvertisementWatcher(arg0);
                  wrappedArg1 = WrapBluetoothLEAdvertisementReceivedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"stopped", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->Stopped::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^, ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^ arg0, ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapBluetoothLEAdvertisementWatcher(arg0);
                  wrappedArg1 = WrapBluetoothLEAdvertisementWatcherStoppedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"received", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"stopped", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"received", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());
          wrapper->_instance->Received::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"stopped", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          BluetoothLEAdvertisementWatcher *wrapper = BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(info.This());
          wrapper->_instance->Stopped::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAdvertisementWatcher(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^ UnwrapBluetoothLEAdvertisementWatcher(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAdvertisementWatcher::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAdvertisementWatcher(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAdvertisementWatcher::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher^ UnwrapBluetoothLEAdvertisementWatcher(Local<Value> value) {
     return BluetoothLEAdvertisementWatcher::Unwrap<BluetoothLEAdvertisementWatcher>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAdvertisementWatcher(Local<Object> exports) {
    BluetoothLEAdvertisementWatcher::Init(exports);
  }

  class BluetoothLEAdvertisementWatcherStoppedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEAdvertisementWatcherStoppedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("error").ToLocalChecked(), ErrorGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("BluetoothLEAdvertisementWatcherStoppedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEAdvertisementWatcherStoppedEventArgs(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEAdvertisementWatcherStoppedEventArgs *wrapperInstance = new BluetoothLEAdvertisementWatcherStoppedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEAdvertisementWatcherStoppedEventArgs(winRtInstance));
    }





    static void ErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^>(info.This())) {
        return;
      }

      BluetoothLEAdvertisementWatcherStoppedEventArgs *wrapper = BluetoothLEAdvertisementWatcherStoppedEventArgs::Unwrap<BluetoothLEAdvertisementWatcherStoppedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothError result = wrapper->_instance->Error;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEAdvertisementWatcherStoppedEventArgs(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^ UnwrapBluetoothLEAdvertisementWatcherStoppedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEAdvertisementWatcherStoppedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEAdvertisementWatcherStoppedEventArgs(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEAdvertisementWatcherStoppedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs^ UnwrapBluetoothLEAdvertisementWatcherStoppedEventArgs(Local<Value> value) {
     return BluetoothLEAdvertisementWatcherStoppedEventArgs::Unwrap<BluetoothLEAdvertisementWatcherStoppedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEAdvertisementWatcherStoppedEventArgs(Local<Object> exports) {
    BluetoothLEAdvertisementWatcherStoppedEventArgs::Init(exports);
  }

  class BluetoothLEManufacturerData : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("BluetoothLEManufacturerData").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("data").ToLocalChecked(), DataGetter, DataSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("companyId").ToLocalChecked(), CompanyIdGetter, CompanyIdSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("BluetoothLEManufacturerData").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      BluetoothLEManufacturerData(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsInt32()
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[1]))
      {
        try {
          unsigned short arg0 = static_cast<unsigned short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          ::Windows::Storage::Streams::IBuffer^ arg1 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[1]));
          
          winRtInstance = ref new ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData(arg0,arg1);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      BluetoothLEManufacturerData *wrapperInstance = new BluetoothLEManufacturerData(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBluetoothLEManufacturerData(winRtInstance));
    }





    static void DataGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^>(info.This())) {
        return;
      }

      BluetoothLEManufacturerData *wrapper = BluetoothLEManufacturerData::Unwrap<BluetoothLEManufacturerData>(info.This());

      try  {
        ::Windows::Storage::Streams::IBuffer^ result = wrapper->_instance->Data;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DataSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^>(info.This())) {
        return;
      }

      BluetoothLEManufacturerData *wrapper = BluetoothLEManufacturerData::Unwrap<BluetoothLEManufacturerData>(info.This());

      try {

        ::Windows::Storage::Streams::IBuffer^ winRtValue = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->Data = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void CompanyIdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^>(info.This())) {
        return;
      }

      BluetoothLEManufacturerData *wrapper = BluetoothLEManufacturerData::Unwrap<BluetoothLEManufacturerData>(info.This());

      try  {
        unsigned short result = wrapper->_instance->CompanyId;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CompanyIdSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^>(info.This())) {
        return;
      }

      BluetoothLEManufacturerData *wrapper = BluetoothLEManufacturerData::Unwrap<BluetoothLEManufacturerData>(info.This());

      try {

        unsigned short winRtValue = static_cast<unsigned short>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->CompanyId = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBluetoothLEManufacturerData(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ UnwrapBluetoothLEManufacturerData(Local<Value> value);
  };

  Persistent<FunctionTemplate> BluetoothLEManufacturerData::s_constructorTemplate;

  v8::Local<v8::Value> WrapBluetoothLEManufacturerData(::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(BluetoothLEManufacturerData::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData^ UnwrapBluetoothLEManufacturerData(Local<Value> value) {
     return BluetoothLEManufacturerData::Unwrap<BluetoothLEManufacturerData>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBluetoothLEManufacturerData(Local<Object> exports) {
    BluetoothLEManufacturerData::Init(exports);
  }

} } } } }

namespace NodeRT { namespace Windows { namespace Devices { namespace Bluetooth { namespace GenericAttributeProfile { 
  v8::Local<v8::Value> WrapGattCharacteristic(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ UnwrapGattCharacteristic(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattCharacteristicUuids(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^ UnwrapGattCharacteristicUuids(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattCharacteristicsResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^ UnwrapGattCharacteristicsResult(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattClientNotificationResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^ UnwrapGattClientNotificationResult(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattDescriptor(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ UnwrapGattDescriptor(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattDescriptorUuids(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^ UnwrapGattDescriptorUuids(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattDescriptorsResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^ UnwrapGattDescriptorsResult(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattDeviceService(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ UnwrapGattDeviceService(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattDeviceServicesResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^ UnwrapGattDeviceServicesResult(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattLocalCharacteristic(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ UnwrapGattLocalCharacteristic(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattLocalCharacteristicParameters(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^ UnwrapGattLocalCharacteristicParameters(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattLocalCharacteristicResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^ UnwrapGattLocalCharacteristicResult(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattLocalDescriptor(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ UnwrapGattLocalDescriptor(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattLocalDescriptorParameters(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^ UnwrapGattLocalDescriptorParameters(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattLocalDescriptorResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^ UnwrapGattLocalDescriptorResult(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattLocalService(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^ UnwrapGattLocalService(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattPresentationFormat(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ UnwrapGattPresentationFormat(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattPresentationFormatTypes(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^ UnwrapGattPresentationFormatTypes(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattProtocolError(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^ UnwrapGattProtocolError(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattReadClientCharacteristicConfigurationDescriptorResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^ UnwrapGattReadClientCharacteristicConfigurationDescriptorResult(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattReadRequest(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^ UnwrapGattReadRequest(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattReadRequestedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^ UnwrapGattReadRequestedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattReadResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^ UnwrapGattReadResult(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattReliableWriteTransaction(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^ UnwrapGattReliableWriteTransaction(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattRequestStateChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^ UnwrapGattRequestStateChangedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattServiceProvider(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^ UnwrapGattServiceProvider(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattServiceProviderAdvertisementStatusChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^ UnwrapGattServiceProviderAdvertisementStatusChangedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattServiceProviderAdvertisingParameters(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^ UnwrapGattServiceProviderAdvertisingParameters(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattServiceProviderResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^ UnwrapGattServiceProviderResult(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattServiceUuids(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^ UnwrapGattServiceUuids(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattSession(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ UnwrapGattSession(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattSessionStatusChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^ UnwrapGattSessionStatusChangedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattSubscribedClient(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ UnwrapGattSubscribedClient(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattValueChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^ UnwrapGattValueChangedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattWriteRequest(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^ UnwrapGattWriteRequest(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattWriteRequestedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^ UnwrapGattWriteRequestedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapGattWriteResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^ wintRtInstance);
  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^ UnwrapGattWriteResult(Local<Value> value);
  



  static void InitGattCharacteristicPropertiesEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("GattCharacteristicProperties").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("none").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties::None)));
    Nan::Set(enumObject, Nan::New<String>("broadcast").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties::Broadcast)));
    Nan::Set(enumObject, Nan::New<String>("read").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties::Read)));
    Nan::Set(enumObject, Nan::New<String>("writeWithoutResponse").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties::WriteWithoutResponse)));
    Nan::Set(enumObject, Nan::New<String>("write").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties::Write)));
    Nan::Set(enumObject, Nan::New<String>("notify").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties::Notify)));
    Nan::Set(enumObject, Nan::New<String>("indicate").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties::Indicate)));
    Nan::Set(enumObject, Nan::New<String>("authenticatedSignedWrites").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties::AuthenticatedSignedWrites)));
    Nan::Set(enumObject, Nan::New<String>("extendedProperties").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties::ExtendedProperties)));
    Nan::Set(enumObject, Nan::New<String>("reliableWrites").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties::ReliableWrites)));
    Nan::Set(enumObject, Nan::New<String>("writableAuxiliaries").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties::WritableAuxiliaries)));
  }

  static void InitGattClientCharacteristicConfigurationDescriptorValueEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("GattClientCharacteristicConfigurationDescriptorValue").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("none").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientCharacteristicConfigurationDescriptorValue::None)));
    Nan::Set(enumObject, Nan::New<String>("notify").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientCharacteristicConfigurationDescriptorValue::Notify)));
    Nan::Set(enumObject, Nan::New<String>("indicate").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientCharacteristicConfigurationDescriptorValue::Indicate)));
  }

  static void InitGattCommunicationStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("GattCommunicationStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("success").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus::Success)));
    Nan::Set(enumObject, Nan::New<String>("unreachable").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus::Unreachable)));
    Nan::Set(enumObject, Nan::New<String>("protocolError").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus::ProtocolError)));
    Nan::Set(enumObject, Nan::New<String>("accessDenied").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus::AccessDenied)));
  }

  static void InitGattOpenStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("GattOpenStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("unspecified").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattOpenStatus::Unspecified)));
    Nan::Set(enumObject, Nan::New<String>("success").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattOpenStatus::Success)));
    Nan::Set(enumObject, Nan::New<String>("alreadyOpened").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattOpenStatus::AlreadyOpened)));
    Nan::Set(enumObject, Nan::New<String>("notFound").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattOpenStatus::NotFound)));
    Nan::Set(enumObject, Nan::New<String>("sharingViolation").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattOpenStatus::SharingViolation)));
    Nan::Set(enumObject, Nan::New<String>("accessDenied").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattOpenStatus::AccessDenied)));
  }

  static void InitGattProtectionLevelEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("GattProtectionLevel").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("plain").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel::Plain)));
    Nan::Set(enumObject, Nan::New<String>("authenticationRequired").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel::AuthenticationRequired)));
    Nan::Set(enumObject, Nan::New<String>("encryptionRequired").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel::EncryptionRequired)));
    Nan::Set(enumObject, Nan::New<String>("encryptionAndAuthenticationRequired").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel::EncryptionAndAuthenticationRequired)));
  }

  static void InitGattRequestStateEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("GattRequestState").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("pending").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestState::Pending)));
    Nan::Set(enumObject, Nan::New<String>("completed").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestState::Completed)));
    Nan::Set(enumObject, Nan::New<String>("canceled").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestState::Canceled)));
  }

  static void InitGattServiceProviderAdvertisementStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("GattServiceProviderAdvertisementStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("created").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatus::Created)));
    Nan::Set(enumObject, Nan::New<String>("stopped").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatus::Stopped)));
    Nan::Set(enumObject, Nan::New<String>("started").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatus::Started)));
    Nan::Set(enumObject, Nan::New<String>("aborted").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatus::Aborted)));
    Nan::Set(enumObject, Nan::New<String>("startedWithoutAllAdvertisementData").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatus::StartedWithoutAllAdvertisementData)));
  }

  static void InitGattSessionStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("GattSessionStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("closed").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatus::Closed)));
    Nan::Set(enumObject, Nan::New<String>("active").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatus::Active)));
  }

  static void InitGattSharingModeEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("GattSharingMode").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("unspecified").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSharingMode::Unspecified)));
    Nan::Set(enumObject, Nan::New<String>("exclusive").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSharingMode::Exclusive)));
    Nan::Set(enumObject, Nan::New<String>("sharedReadOnly").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSharingMode::SharedReadOnly)));
    Nan::Set(enumObject, Nan::New<String>("sharedReadAndWrite").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSharingMode::SharedReadAndWrite)));
  }

  static void InitGattWriteOptionEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("GattWriteOption").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("writeWithResponse").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteOption::WriteWithResponse)));
    Nan::Set(enumObject, Nan::New<String>("writeWithoutResponse").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteOption::WriteWithoutResponse)));
  }



  class GattCharacteristic : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattCharacteristic").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "getDescriptors", GetDescriptors);
            Nan::SetPrototypeMethod(localRef, "getAllDescriptors", GetAllDescriptors);
          

          
            Nan::SetPrototypeMethod(localRef, "readValueAsync", ReadValueAsync);
            Nan::SetPrototypeMethod(localRef, "writeValueAsync", WriteValueAsync);
            Nan::SetPrototypeMethod(localRef, "readClientCharacteristicConfigurationDescriptorAsync", ReadClientCharacteristicConfigurationDescriptorAsync);
            Nan::SetPrototypeMethod(localRef, "writeClientCharacteristicConfigurationDescriptorAsync", WriteClientCharacteristicConfigurationDescriptorAsync);
            Nan::SetPrototypeMethod(localRef, "getDescriptorsAsync", GetDescriptorsAsync);
            Nan::SetPrototypeMethod(localRef, "getDescriptorsForUuidAsync", GetDescriptorsForUuidAsync);
            Nan::SetPrototypeMethod(localRef, "writeValueWithResultAsync", WriteValueWithResultAsync);
            Nan::SetPrototypeMethod(localRef, "writeClientCharacteristicConfigurationDescriptorWithResultAsync", WriteClientCharacteristicConfigurationDescriptorWithResultAsync);
          

          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("protectionLevel").ToLocalChecked(), ProtectionLevelGetter, ProtectionLevelSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("attributeHandle").ToLocalChecked(), AttributeHandleGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("characteristicProperties").ToLocalChecked(), CharacteristicPropertiesGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("presentationFormats").ToLocalChecked(), PresentationFormatsGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("userDescription").ToLocalChecked(), UserDescriptionGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("uuid").ToLocalChecked(), UuidGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("service").ToLocalChecked(), ServiceGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "convertShortIdToUuid", ConvertShortIdToUuid);


        Nan::Set(exports, Nan::New<String>("GattCharacteristic").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattCharacteristic(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattCharacteristic *wrapperInstance = new GattCharacteristic(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattCharacteristic(winRtInstance));
    }

    static void ReadValueAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->ReadValueAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg0 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->ReadValueAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattReadResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void WriteValueAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          op = wrapper->_instance->WriteValueAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])
        && info[1]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[0]));
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteOption arg1 = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteOption>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          op = wrapper->_instance->WriteValueAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(static_cast<int>(result));
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void ReadClientCharacteristicConfigurationDescriptorAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->ReadClientCharacteristicConfigurationDescriptorAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattReadClientCharacteristicConfigurationDescriptorResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void WriteClientCharacteristicConfigurationDescriptorAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus>^ op;


      if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientCharacteristicConfigurationDescriptorValue arg0 = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientCharacteristicConfigurationDescriptorValue>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->WriteClientCharacteristicConfigurationDescriptorAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(static_cast<int>(result));
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void GetDescriptorsAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetDescriptorsAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg0 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->GetDescriptorsAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattDescriptorsResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void GetDescriptorsForUuidAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          op = wrapper->_instance->GetDescriptorsForUuidAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && NodeRT::Utils::IsGuid(info[0])
        && info[1]->IsInt32())
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg1 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          op = wrapper->_instance->GetDescriptorsForUuidAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattDescriptorsResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void WriteValueWithResultAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          op = wrapper->_instance->WriteValueWithResultAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])
        && info[1]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[0]));
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteOption arg1 = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteOption>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          op = wrapper->_instance->WriteValueWithResultAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattWriteResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void WriteClientCharacteristicConfigurationDescriptorWithResultAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^>^ op;


      if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientCharacteristicConfigurationDescriptorValue arg0 = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientCharacteristicConfigurationDescriptorValue>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->WriteClientCharacteristicConfigurationDescriptorWithResultAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattWriteResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void GetDescriptors(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>^ result;
          result = wrapper->_instance->GetDescriptors(arg0);
          info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ val) -> Local<Value> {
              return WrapGattDescriptor(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ {
              return UnwrapGattDescriptor(value);
            }
          ));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetAllDescriptors(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>^ result;
          result = wrapper->_instance->GetAllDescriptors();
          info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ val) -> Local<Value> {
              return WrapGattDescriptor(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ {
              return UnwrapGattDescriptor(value);
            }
          ));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void ConvertShortIdToUuid(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          ::Platform::Guid result;
          result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic::ConvertShortIdToUuid(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void ProtectionLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel result = wrapper->_instance->ProtectionLevel;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ProtectionLevelSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      try {

        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel winRtValue = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->ProtectionLevel = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void AttributeHandleGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      try  {
        unsigned short result = wrapper->_instance->AttributeHandle;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CharacteristicPropertiesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties result = wrapper->_instance->CharacteristicProperties;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PresentationFormatsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>^ result = wrapper->_instance->PresentationFormats;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ val) -> Local<Value> {
              return WrapGattPresentationFormat(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ {
              return UnwrapGattPresentationFormat(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UserDescriptionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->UserDescription;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UuidGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      try  {
        ::Platform::Guid result = wrapper->_instance->Uuid;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ServiceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This())) {
        return;
      }

      GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ result = wrapper->_instance->Service;
        info.GetReturnValue().Set(WrapGattDeviceService(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"valueChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->ValueChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ arg0, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapGattCharacteristic(arg0);
                  wrappedArg1 = WrapGattValueChangedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"valueChanged", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"valueChanged", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          GattCharacteristic *wrapper = GattCharacteristic::Unwrap<GattCharacteristic>(info.This());
          wrapper->_instance->ValueChanged::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattCharacteristic(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ UnwrapGattCharacteristic(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattCharacteristic::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattCharacteristic(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattCharacteristic::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ UnwrapGattCharacteristic(Local<Value> value) {
     return GattCharacteristic::Unwrap<GattCharacteristic>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattCharacteristic(Local<Object> exports) {
    GattCharacteristic::Init(exports);
  }

  class GattCharacteristicUuids : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattCharacteristicUuids").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetAccessor(constructor, Nan::New<String>("heartRateMeasurement").ToLocalChecked(), HeartRateMeasurementGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("batteryLevel").ToLocalChecked(), BatteryLevelGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("bloodPressureFeature").ToLocalChecked(), BloodPressureFeatureGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("bloodPressureMeasurement").ToLocalChecked(), BloodPressureMeasurementGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("bodySensorLocation").ToLocalChecked(), BodySensorLocationGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cscFeature").ToLocalChecked(), CscFeatureGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cscMeasurement").ToLocalChecked(), CscMeasurementGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("glucoseFeature").ToLocalChecked(), GlucoseFeatureGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("glucoseMeasurement").ToLocalChecked(), GlucoseMeasurementGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("glucoseMeasurementContext").ToLocalChecked(), GlucoseMeasurementContextGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("heartRateControlPoint").ToLocalChecked(), HeartRateControlPointGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("intermediateCuffPressure").ToLocalChecked(), IntermediateCuffPressureGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("intermediateTemperature").ToLocalChecked(), IntermediateTemperatureGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("measurementInterval").ToLocalChecked(), MeasurementIntervalGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("recordAccessControlPoint").ToLocalChecked(), RecordAccessControlPointGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("rscFeature").ToLocalChecked(), RscFeatureGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("rscMeasurement").ToLocalChecked(), RscMeasurementGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("sCControlPoint").ToLocalChecked(), SCControlPointGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("sensorLocation").ToLocalChecked(), SensorLocationGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("temperatureMeasurement").ToLocalChecked(), TemperatureMeasurementGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("temperatureType").ToLocalChecked(), TemperatureTypeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("gapPeripheralPreferredConnectionParameters").ToLocalChecked(), GapPeripheralPreferredConnectionParametersGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("gapPeripheralPrivacyFlag").ToLocalChecked(), GapPeripheralPrivacyFlagGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("gapReconnectionAddress").ToLocalChecked(), GapReconnectionAddressGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("gattServiceChanged").ToLocalChecked(), GattServiceChangedGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("hardwareRevisionString").ToLocalChecked(), HardwareRevisionStringGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("hidControlPoint").ToLocalChecked(), HidControlPointGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("hidInformation").ToLocalChecked(), HidInformationGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("ieee1107320601RegulatoryCertificationDataList").ToLocalChecked(), Ieee1107320601RegulatoryCertificationDataListGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("lnControlPoint").ToLocalChecked(), LnControlPointGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("lnFeature").ToLocalChecked(), LnFeatureGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("localTimeInformation").ToLocalChecked(), LocalTimeInformationGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("locationAndSpeed").ToLocalChecked(), LocationAndSpeedGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("manufacturerNameString").ToLocalChecked(), ManufacturerNameStringGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("modelNumberString").ToLocalChecked(), ModelNumberStringGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("navigation").ToLocalChecked(), NavigationGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("newAlert").ToLocalChecked(), NewAlertGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("pnpId").ToLocalChecked(), PnpIdGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("positionQuality").ToLocalChecked(), PositionQualityGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("protocolMode").ToLocalChecked(), ProtocolModeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cyclingPowerFeature").ToLocalChecked(), CyclingPowerFeatureGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("report").ToLocalChecked(), ReportGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("reportMap").ToLocalChecked(), ReportMapGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("ringerControlPoint").ToLocalChecked(), RingerControlPointGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("ringerSetting").ToLocalChecked(), RingerSettingGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("scanIntervalWindow").ToLocalChecked(), ScanIntervalWindowGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("scanRefresh").ToLocalChecked(), ScanRefreshGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("serialNumberString").ToLocalChecked(), SerialNumberStringGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("softwareRevisionString").ToLocalChecked(), SoftwareRevisionStringGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("supportUnreadAlertCategory").ToLocalChecked(), SupportUnreadAlertCategoryGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("supportedNewAlertCategory").ToLocalChecked(), SupportedNewAlertCategoryGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("systemId").ToLocalChecked(), SystemIdGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("timeAccuracy").ToLocalChecked(), TimeAccuracyGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("timeSource").ToLocalChecked(), TimeSourceGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("timeUpdateControlPoint").ToLocalChecked(), TimeUpdateControlPointGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("timeUpdateState").ToLocalChecked(), TimeUpdateStateGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("timeWithDst").ToLocalChecked(), TimeWithDstGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("timeZone").ToLocalChecked(), TimeZoneGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("txPowerLevel").ToLocalChecked(), TxPowerLevelGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("unreadAlertStatus").ToLocalChecked(), UnreadAlertStatusGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("alertCategoryId").ToLocalChecked(), AlertCategoryIdGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("alertCategoryIdBitMask").ToLocalChecked(), AlertCategoryIdBitMaskGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("alertLevel").ToLocalChecked(), AlertLevelGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("alertNotificationControlPoint").ToLocalChecked(), AlertNotificationControlPointGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("alertStatus").ToLocalChecked(), AlertStatusGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("bootKeyboardInputReport").ToLocalChecked(), BootKeyboardInputReportGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("bootKeyboardOutputReport").ToLocalChecked(), BootKeyboardOutputReportGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("bootMouseInputReport").ToLocalChecked(), BootMouseInputReportGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("currentTime").ToLocalChecked(), CurrentTimeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cyclingPowerControlPoint").ToLocalChecked(), CyclingPowerControlPointGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("referenceTimeInformation").ToLocalChecked(), ReferenceTimeInformationGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cyclingPowerMeasurement").ToLocalChecked(), CyclingPowerMeasurementGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cyclingPowerVector").ToLocalChecked(), CyclingPowerVectorGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("dateTime").ToLocalChecked(), DateTimeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("dayDateTime").ToLocalChecked(), DayDateTimeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("dayOfWeek").ToLocalChecked(), DayOfWeekGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("dstOffset").ToLocalChecked(), DstOffsetGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("exactTime256").ToLocalChecked(), ExactTime256Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("firmwareRevisionString").ToLocalChecked(), FirmwareRevisionStringGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("gapAppearance").ToLocalChecked(), GapAppearanceGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("gapDeviceName").ToLocalChecked(), GapDeviceNameGetter);


        Nan::Set(exports, Nan::New<String>("GattCharacteristicUuids").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattCharacteristicUuids(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattCharacteristicUuids *wrapperInstance = new GattCharacteristicUuids(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattCharacteristicUuids(winRtInstance));
    }







    static void HeartRateMeasurementGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::HeartRateMeasurement;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void BatteryLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BatteryLevel;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void BloodPressureFeatureGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BloodPressureFeature;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void BloodPressureMeasurementGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BloodPressureMeasurement;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void BodySensorLocationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BodySensorLocation;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CscFeatureGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CscFeature;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CscMeasurementGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CscMeasurement;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GlucoseFeatureGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GlucoseFeature;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GlucoseMeasurementGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GlucoseMeasurement;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GlucoseMeasurementContextGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GlucoseMeasurementContext;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void HeartRateControlPointGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::HeartRateControlPoint;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void IntermediateCuffPressureGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::IntermediateCuffPressure;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void IntermediateTemperatureGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::IntermediateTemperature;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void MeasurementIntervalGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::MeasurementInterval;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RecordAccessControlPointGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::RecordAccessControlPoint;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RscFeatureGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::RscFeature;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RscMeasurementGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::RscMeasurement;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SCControlPointGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SCControlPoint;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SensorLocationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SensorLocation;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void TemperatureMeasurementGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TemperatureMeasurement;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void TemperatureTypeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TemperatureType;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GapPeripheralPreferredConnectionParametersGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GapPeripheralPreferredConnectionParameters;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GapPeripheralPrivacyFlagGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GapPeripheralPrivacyFlag;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GapReconnectionAddressGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GapReconnectionAddress;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GattServiceChangedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GattServiceChanged;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void HardwareRevisionStringGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::HardwareRevisionString;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void HidControlPointGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::HidControlPoint;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void HidInformationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::HidInformation;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void Ieee1107320601RegulatoryCertificationDataListGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::Ieee1107320601RegulatoryCertificationDataList;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void LnControlPointGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::LnControlPoint;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void LnFeatureGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::LnFeature;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void LocalTimeInformationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::LocalTimeInformation;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void LocationAndSpeedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::LocationAndSpeed;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ManufacturerNameStringGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ManufacturerNameString;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ModelNumberStringGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ModelNumberString;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void NavigationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::Navigation;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void NewAlertGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::NewAlert;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void PnpIdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::PnpId;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void PositionQualityGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::PositionQuality;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ProtocolModeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ProtocolMode;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CyclingPowerFeatureGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CyclingPowerFeature;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ReportGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::Report;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ReportMapGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ReportMap;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RingerControlPointGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::RingerControlPoint;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RingerSettingGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::RingerSetting;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ScanIntervalWindowGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ScanIntervalWindow;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ScanRefreshGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ScanRefresh;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SerialNumberStringGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SerialNumberString;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SoftwareRevisionStringGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SoftwareRevisionString;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SupportUnreadAlertCategoryGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SupportUnreadAlertCategory;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SupportedNewAlertCategoryGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SupportedNewAlertCategory;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SystemIdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SystemId;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void TimeAccuracyGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TimeAccuracy;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void TimeSourceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TimeSource;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void TimeUpdateControlPointGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TimeUpdateControlPoint;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void TimeUpdateStateGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TimeUpdateState;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void TimeWithDstGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TimeWithDst;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void TimeZoneGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TimeZone;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void TxPowerLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TxPowerLevel;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void UnreadAlertStatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::UnreadAlertStatus;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void AlertCategoryIdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::AlertCategoryId;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void AlertCategoryIdBitMaskGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::AlertCategoryIdBitMask;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void AlertLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::AlertLevel;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void AlertNotificationControlPointGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::AlertNotificationControlPoint;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void AlertStatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::AlertStatus;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void BootKeyboardInputReportGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BootKeyboardInputReport;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void BootKeyboardOutputReportGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BootKeyboardOutputReport;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void BootMouseInputReportGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BootMouseInputReport;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CurrentTimeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CurrentTime;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CyclingPowerControlPointGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CyclingPowerControlPoint;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ReferenceTimeInformationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ReferenceTimeInformation;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CyclingPowerMeasurementGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CyclingPowerMeasurement;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CyclingPowerVectorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CyclingPowerVector;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void DateTimeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::DateTime;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void DayDateTimeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::DayDateTime;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void DayOfWeekGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::DayOfWeek;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void DstOffsetGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::DstOffset;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ExactTime256Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ExactTime256;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void FirmwareRevisionStringGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::FirmwareRevisionString;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GapAppearanceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GapAppearance;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GapDeviceNameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GapDeviceName;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattCharacteristicUuids(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^ UnwrapGattCharacteristicUuids(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattCharacteristicUuids::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattCharacteristicUuids(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattCharacteristicUuids::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids^ UnwrapGattCharacteristicUuids(Local<Value> value) {
     return GattCharacteristicUuids::Unwrap<GattCharacteristicUuids>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattCharacteristicUuids(Local<Object> exports) {
    GattCharacteristicUuids::Init(exports);
  }

  class GattCharacteristicsResult : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattCharacteristicsResult").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("characteristics").ToLocalChecked(), CharacteristicsGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("protocolError").ToLocalChecked(), ProtocolErrorGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattCharacteristicsResult").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattCharacteristicsResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattCharacteristicsResult *wrapperInstance = new GattCharacteristicsResult(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattCharacteristicsResult(winRtInstance));
    }





    static void CharacteristicsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^>(info.This())) {
        return;
      }

      GattCharacteristicsResult *wrapper = GattCharacteristicsResult::Unwrap<GattCharacteristicsResult>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>^ result = wrapper->_instance->Characteristics;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ val) -> Local<Value> {
              return WrapGattCharacteristic(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ {
              return UnwrapGattCharacteristic(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ProtocolErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^>(info.This())) {
        return;
      }

      GattCharacteristicsResult *wrapper = GattCharacteristicsResult::Unwrap<GattCharacteristicsResult>(info.This());

      try  {
        ::Platform::IBox<unsigned char>^ result = wrapper->_instance->ProtocolError;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^>(info.This())) {
        return;
      }

      GattCharacteristicsResult *wrapper = GattCharacteristicsResult::Unwrap<GattCharacteristicsResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattCharacteristicsResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^ UnwrapGattCharacteristicsResult(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattCharacteristicsResult::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattCharacteristicsResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattCharacteristicsResult::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^ UnwrapGattCharacteristicsResult(Local<Value> value) {
     return GattCharacteristicsResult::Unwrap<GattCharacteristicsResult>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattCharacteristicsResult(Local<Object> exports) {
    GattCharacteristicsResult::Init(exports);
  }

  class GattClientNotificationResult : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattClientNotificationResult").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("protocolError").ToLocalChecked(), ProtocolErrorGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("subscribedClient").ToLocalChecked(), SubscribedClientGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("bytesSent").ToLocalChecked(), BytesSentGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattClientNotificationResult").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattClientNotificationResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattClientNotificationResult *wrapperInstance = new GattClientNotificationResult(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattClientNotificationResult(winRtInstance));
    }





    static void ProtocolErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^>(info.This())) {
        return;
      }

      GattClientNotificationResult *wrapper = GattClientNotificationResult::Unwrap<GattClientNotificationResult>(info.This());

      try  {
        ::Platform::IBox<unsigned char>^ result = wrapper->_instance->ProtocolError;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^>(info.This())) {
        return;
      }

      GattClientNotificationResult *wrapper = GattClientNotificationResult::Unwrap<GattClientNotificationResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SubscribedClientGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^>(info.This())) {
        return;
      }

      GattClientNotificationResult *wrapper = GattClientNotificationResult::Unwrap<GattClientNotificationResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ result = wrapper->_instance->SubscribedClient;
        info.GetReturnValue().Set(WrapGattSubscribedClient(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void BytesSentGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^>(info.This())) {
        return;
      }

      GattClientNotificationResult *wrapper = GattClientNotificationResult::Unwrap<GattClientNotificationResult>(info.This());

      try  {
        unsigned short result = wrapper->_instance->BytesSent;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattClientNotificationResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^ UnwrapGattClientNotificationResult(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattClientNotificationResult::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattClientNotificationResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattClientNotificationResult::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^ UnwrapGattClientNotificationResult(Local<Value> value) {
     return GattClientNotificationResult::Unwrap<GattClientNotificationResult>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattClientNotificationResult(Local<Object> exports) {
    GattClientNotificationResult::Init(exports);
  }

  class GattDescriptor : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattDescriptor").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;


          
            Nan::SetPrototypeMethod(localRef, "readValueAsync", ReadValueAsync);
            Nan::SetPrototypeMethod(localRef, "writeValueAsync", WriteValueAsync);
            Nan::SetPrototypeMethod(localRef, "writeValueWithResultAsync", WriteValueWithResultAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("protectionLevel").ToLocalChecked(), ProtectionLevelGetter, ProtectionLevelSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("attributeHandle").ToLocalChecked(), AttributeHandleGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("uuid").ToLocalChecked(), UuidGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "convertShortIdToUuid", ConvertShortIdToUuid);


        Nan::Set(exports, Nan::New<String>("GattDescriptor").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattDescriptor(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattDescriptor *wrapperInstance = new GattDescriptor(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattDescriptor(winRtInstance));
    }

    static void ReadValueAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattDescriptor *wrapper = GattDescriptor::Unwrap<GattDescriptor>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->ReadValueAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg0 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->ReadValueAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattReadResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void WriteValueAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattDescriptor *wrapper = GattDescriptor::Unwrap<GattDescriptor>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          op = wrapper->_instance->WriteValueAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(static_cast<int>(result));
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void WriteValueWithResultAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattDescriptor *wrapper = GattDescriptor::Unwrap<GattDescriptor>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          op = wrapper->_instance->WriteValueWithResultAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattWriteResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }




    static void ConvertShortIdToUuid(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          ::Platform::Guid result;
          result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor::ConvertShortIdToUuid(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void ProtectionLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>(info.This())) {
        return;
      }

      GattDescriptor *wrapper = GattDescriptor::Unwrap<GattDescriptor>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel result = wrapper->_instance->ProtectionLevel;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ProtectionLevelSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>(info.This())) {
        return;
      }

      GattDescriptor *wrapper = GattDescriptor::Unwrap<GattDescriptor>(info.This());

      try {

        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel winRtValue = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->ProtectionLevel = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void AttributeHandleGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>(info.This())) {
        return;
      }

      GattDescriptor *wrapper = GattDescriptor::Unwrap<GattDescriptor>(info.This());

      try  {
        unsigned short result = wrapper->_instance->AttributeHandle;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UuidGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>(info.This())) {
        return;
      }

      GattDescriptor *wrapper = GattDescriptor::Unwrap<GattDescriptor>(info.This());

      try  {
        ::Platform::Guid result = wrapper->_instance->Uuid;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattDescriptor(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ UnwrapGattDescriptor(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattDescriptor::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattDescriptor(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattDescriptor::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ UnwrapGattDescriptor(Local<Value> value) {
     return GattDescriptor::Unwrap<GattDescriptor>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattDescriptor(Local<Object> exports) {
    GattDescriptor::Init(exports);
  }

  class GattDescriptorUuids : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattDescriptorUuids").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetAccessor(constructor, Nan::New<String>("characteristicAggregateFormat").ToLocalChecked(), CharacteristicAggregateFormatGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("characteristicExtendedProperties").ToLocalChecked(), CharacteristicExtendedPropertiesGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("characteristicPresentationFormat").ToLocalChecked(), CharacteristicPresentationFormatGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("characteristicUserDescription").ToLocalChecked(), CharacteristicUserDescriptionGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("clientCharacteristicConfiguration").ToLocalChecked(), ClientCharacteristicConfigurationGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("serverCharacteristicConfiguration").ToLocalChecked(), ServerCharacteristicConfigurationGetter);


        Nan::Set(exports, Nan::New<String>("GattDescriptorUuids").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattDescriptorUuids(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattDescriptorUuids *wrapperInstance = new GattDescriptorUuids(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattDescriptorUuids(winRtInstance));
    }







    static void CharacteristicAggregateFormatGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids::CharacteristicAggregateFormat;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CharacteristicExtendedPropertiesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids::CharacteristicExtendedProperties;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CharacteristicPresentationFormatGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids::CharacteristicPresentationFormat;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CharacteristicUserDescriptionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids::CharacteristicUserDescription;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ClientCharacteristicConfigurationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids::ClientCharacteristicConfiguration;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ServerCharacteristicConfigurationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids::ServerCharacteristicConfiguration;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattDescriptorUuids(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^ UnwrapGattDescriptorUuids(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattDescriptorUuids::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattDescriptorUuids(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattDescriptorUuids::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids^ UnwrapGattDescriptorUuids(Local<Value> value) {
     return GattDescriptorUuids::Unwrap<GattDescriptorUuids>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattDescriptorUuids(Local<Object> exports) {
    GattDescriptorUuids::Init(exports);
  }

  class GattDescriptorsResult : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattDescriptorsResult").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("descriptors").ToLocalChecked(), DescriptorsGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("protocolError").ToLocalChecked(), ProtocolErrorGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattDescriptorsResult").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattDescriptorsResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattDescriptorsResult *wrapperInstance = new GattDescriptorsResult(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattDescriptorsResult(winRtInstance));
    }





    static void DescriptorsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^>(info.This())) {
        return;
      }

      GattDescriptorsResult *wrapper = GattDescriptorsResult::Unwrap<GattDescriptorsResult>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>^ result = wrapper->_instance->Descriptors;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ val) -> Local<Value> {
              return WrapGattDescriptor(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor^ {
              return UnwrapGattDescriptor(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ProtocolErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^>(info.This())) {
        return;
      }

      GattDescriptorsResult *wrapper = GattDescriptorsResult::Unwrap<GattDescriptorsResult>(info.This());

      try  {
        ::Platform::IBox<unsigned char>^ result = wrapper->_instance->ProtocolError;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^>(info.This())) {
        return;
      }

      GattDescriptorsResult *wrapper = GattDescriptorsResult::Unwrap<GattDescriptorsResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattDescriptorsResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^ UnwrapGattDescriptorsResult(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattDescriptorsResult::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattDescriptorsResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattDescriptorsResult::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult^ UnwrapGattDescriptorsResult(Local<Value> value) {
     return GattDescriptorsResult::Unwrap<GattDescriptorsResult>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattDescriptorsResult(Local<Object> exports) {
    GattDescriptorsResult::Init(exports);
  }

  class GattDeviceService : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattDeviceService").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "getCharacteristics", GetCharacteristics);
            Nan::SetPrototypeMethod(localRef, "getIncludedServices", GetIncludedServices);
            Nan::SetPrototypeMethod(localRef, "close", Close);
            Nan::SetPrototypeMethod(localRef, "getAllCharacteristics", GetAllCharacteristics);
            Nan::SetPrototypeMethod(localRef, "getAllIncludedServices", GetAllIncludedServices);
          

          
            Nan::SetPrototypeMethod(localRef, "requestAccessAsync", RequestAccessAsync);
            Nan::SetPrototypeMethod(localRef, "openAsync", OpenAsync);
            Nan::SetPrototypeMethod(localRef, "getCharacteristicsAsync", GetCharacteristicsAsync);
            Nan::SetPrototypeMethod(localRef, "getCharacteristicsForUuidAsync", GetCharacteristicsForUuidAsync);
            Nan::SetPrototypeMethod(localRef, "getIncludedServicesAsync", GetIncludedServicesAsync);
            Nan::SetPrototypeMethod(localRef, "getIncludedServicesForUuidAsync", GetIncludedServicesForUuidAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("attributeHandle").ToLocalChecked(), AttributeHandleGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceId").ToLocalChecked(), DeviceIdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("uuid").ToLocalChecked(), UuidGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("device").ToLocalChecked(), DeviceGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("parentServices").ToLocalChecked(), ParentServicesGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceAccessInformation").ToLocalChecked(), DeviceAccessInformationGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("session").ToLocalChecked(), SessionGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("sharingMode").ToLocalChecked(), SharingModeGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "getDeviceSelectorForBluetoothDeviceId", GetDeviceSelectorForBluetoothDeviceId);
        Nan::SetMethod(constructor, "getDeviceSelectorForBluetoothDeviceIdAndUuid", GetDeviceSelectorForBluetoothDeviceIdAndUuid);
        Nan::SetMethod(constructor, "getDeviceSelectorFromUuid", GetDeviceSelectorFromUuid);
        Nan::SetMethod(constructor, "getDeviceSelectorFromShortId", GetDeviceSelectorFromShortId);
        Nan::SetMethod(constructor, "convertShortIdToUuid", ConvertShortIdToUuid);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(FromIdAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("fromIdAsync").ToLocalChecked(), func);


        Nan::Set(exports, Nan::New<String>("GattDeviceService").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattDeviceService(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattDeviceService *wrapperInstance = new GattDeviceService(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattDeviceService(winRtInstance));
    }

    static void RequestAccessAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Enumeration::DeviceAccessStatus>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->RequestAccessAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Enumeration::DeviceAccessStatus> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(static_cast<int>(result));
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void OpenAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattOpenStatus>^ op;


      if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSharingMode arg0 = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSharingMode>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->OpenAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattOpenStatus> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(static_cast<int>(result));
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void GetCharacteristicsAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetCharacteristicsAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg0 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->GetCharacteristicsAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattCharacteristicsResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void GetCharacteristicsForUuidAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          op = wrapper->_instance->GetCharacteristicsForUuidAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && NodeRT::Utils::IsGuid(info[0])
        && info[1]->IsInt32())
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg1 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          op = wrapper->_instance->GetCharacteristicsForUuidAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattCharacteristicsResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void GetIncludedServicesAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetIncludedServicesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg0 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->GetIncludedServicesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattDeviceServicesResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void GetIncludedServicesForUuidAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          op = wrapper->_instance->GetIncludedServicesForUuidAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && NodeRT::Utils::IsGuid(info[0])
        && info[1]->IsInt32())
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg1 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          op = wrapper->_instance->GetIncludedServicesForUuidAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattDeviceServicesResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void GetCharacteristics(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>^ result;
          result = wrapper->_instance->GetCharacteristics(arg0);
          info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ val) -> Local<Value> {
              return WrapGattCharacteristic(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ {
              return UnwrapGattCharacteristic(value);
            }
          ));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetIncludedServices(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>^ result;
          result = wrapper->_instance->GetIncludedServices(arg0);
          info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ val) -> Local<Value> {
              return WrapGattDeviceService(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ {
              return UnwrapGattDeviceService(value);
            }
          ));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetAllCharacteristics(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>^ result;
          result = wrapper->_instance->GetAllCharacteristics();
          info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ val) -> Local<Value> {
              return WrapGattCharacteristic(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ {
              return UnwrapGattCharacteristic(value);
            }
          ));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetAllIncludedServices(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>^ result;
          result = wrapper->_instance->GetAllIncludedServices();
          info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ val) -> Local<Value> {
              return WrapGattDeviceService(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ {
              return UnwrapGattDeviceService(value);
            }
          ));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }


    static void FromIdAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>^ op;


      if (info.Length() == 3
          && info[0]->IsString()
          && info[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSharingMode arg1 = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSharingMode>(Nan::To<int32_t>(info[1]).FromMaybe(0));
            
          op = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::FromIdAsync(arg0,arg1);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 2
          && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
            
          op = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::FromIdAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattDeviceService(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void GetDeviceSelectorForBluetoothDeviceId(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(info[0]))
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothDeviceId^ arg0 = dynamic_cast<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::GetDeviceSelectorForBluetoothDeviceId(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(info[0])
        && info[1]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothDeviceId^ arg0 = dynamic_cast<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(NodeRT::Utils::GetObjectInstance(info[0]));
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg1 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::GetDeviceSelectorForBluetoothDeviceId(arg0, arg1);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelectorForBluetoothDeviceIdAndUuid(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(info[0])
        && NodeRT::Utils::IsGuid(info[1]))
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothDeviceId^ arg0 = dynamic_cast<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(NodeRT::Utils::GetObjectInstance(info[0]));
          ::Platform::Guid arg1 = NodeRT::Utils::GuidFromJs(info[1]);
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::GetDeviceSelectorForBluetoothDeviceIdAndUuid(arg0, arg1);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(info[0])
        && NodeRT::Utils::IsGuid(info[1])
        && info[2]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothDeviceId^ arg0 = dynamic_cast<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(NodeRT::Utils::GetObjectInstance(info[0]));
          ::Platform::Guid arg1 = NodeRT::Utils::GuidFromJs(info[1]);
          ::Windows::Devices::Bluetooth::BluetoothCacheMode arg2 = static_cast<::Windows::Devices::Bluetooth::BluetoothCacheMode>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::GetDeviceSelectorForBluetoothDeviceIdAndUuid(arg0, arg1, arg2);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelectorFromUuid(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::GetDeviceSelectorFromUuid(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void GetDeviceSelectorFromShortId(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          Platform::String^ result;
          result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::GetDeviceSelectorFromShortId(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void ConvertShortIdToUuid(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          ::Platform::Guid result;
          result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::ConvertShortIdToUuid(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void AttributeHandleGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      try  {
        unsigned short result = wrapper->_instance->AttributeHandle;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DeviceIdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->DeviceId;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UuidGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      try  {
        ::Platform::Guid result = wrapper->_instance->Uuid;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DeviceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothLEDevice^ result = wrapper->_instance->Device;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Bluetooth", "BluetoothLEDevice", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ParentServicesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>^ result = wrapper->_instance->ParentServices;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ val) -> Local<Value> {
              return WrapGattDeviceService(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ {
              return UnwrapGattDeviceService(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DeviceAccessInformationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceAccessInformation^ result = wrapper->_instance->DeviceAccessInformation;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Enumeration", "DeviceAccessInformation", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SessionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ result = wrapper->_instance->Session;
        info.GetReturnValue().Set(WrapGattSession(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SharingModeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(info.This())) {
        return;
      }

      GattDeviceService *wrapper = GattDeviceService::Unwrap<GattDeviceService>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSharingMode result = wrapper->_instance->SharingMode;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattDeviceService(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ UnwrapGattDeviceService(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattDeviceService::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattDeviceService(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattDeviceService::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ UnwrapGattDeviceService(Local<Value> value) {
     return GattDeviceService::Unwrap<GattDeviceService>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattDeviceService(Local<Object> exports) {
    GattDeviceService::Init(exports);
  }

  class GattDeviceServicesResult : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattDeviceServicesResult").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("protocolError").ToLocalChecked(), ProtocolErrorGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("services").ToLocalChecked(), ServicesGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattDeviceServicesResult").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattDeviceServicesResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattDeviceServicesResult *wrapperInstance = new GattDeviceServicesResult(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattDeviceServicesResult(winRtInstance));
    }





    static void ProtocolErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^>(info.This())) {
        return;
      }

      GattDeviceServicesResult *wrapper = GattDeviceServicesResult::Unwrap<GattDeviceServicesResult>(info.This());

      try  {
        ::Platform::IBox<unsigned char>^ result = wrapper->_instance->ProtocolError;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ServicesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^>(info.This())) {
        return;
      }

      GattDeviceServicesResult *wrapper = GattDeviceServicesResult::Unwrap<GattDeviceServicesResult>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>^ result = wrapper->_instance->Services;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ val) -> Local<Value> {
              return WrapGattDeviceService(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService^ {
              return UnwrapGattDeviceService(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^>(info.This())) {
        return;
      }

      GattDeviceServicesResult *wrapper = GattDeviceServicesResult::Unwrap<GattDeviceServicesResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattDeviceServicesResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^ UnwrapGattDeviceServicesResult(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattDeviceServicesResult::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattDeviceServicesResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattDeviceServicesResult::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult^ UnwrapGattDeviceServicesResult(Local<Value> value) {
     return GattDeviceServicesResult::Unwrap<GattDeviceServicesResult>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattDeviceServicesResult(Local<Object> exports) {
    GattDeviceServicesResult::Init(exports);
  }

  class GattLocalCharacteristic : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattLocalCharacteristic").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;


          
            Nan::SetPrototypeMethod(localRef, "createDescriptorAsync", CreateDescriptorAsync);
            Nan::SetPrototypeMethod(localRef, "notifyValueAsync", NotifyValueAsync);
          

          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("characteristicProperties").ToLocalChecked(), CharacteristicPropertiesGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("descriptors").ToLocalChecked(), DescriptorsGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("presentationFormats").ToLocalChecked(), PresentationFormatsGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("readProtectionLevel").ToLocalChecked(), ReadProtectionLevelGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("staticValue").ToLocalChecked(), StaticValueGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("subscribedClients").ToLocalChecked(), SubscribedClientsGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("userDescription").ToLocalChecked(), UserDescriptionGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("uuid").ToLocalChecked(), UuidGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("writeProtectionLevel").ToLocalChecked(), WriteProtectionLevelGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattLocalCharacteristic").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattLocalCharacteristic(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattLocalCharacteristic *wrapperInstance = new GattLocalCharacteristic(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattLocalCharacteristic(winRtInstance));
    }

    static void CreateDescriptorAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^>^ op;


      if (info.Length() == 3
        && NodeRT::Utils::IsGuid(info[0])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^>(info[1]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^ arg1 = UnwrapGattLocalDescriptorParameters(info[1]);
          
          op = wrapper->_instance->CreateDescriptorAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattLocalDescriptorResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void NotifyValueAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());

      // (jasongin) Hand-patched generated code due to NodeRT bug for method overloads having different return types.
      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^>^>^ op1 = nullptr;
      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^>^ op2 = nullptr;

      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          op1 = wrapper->_instance->NotifyValueAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^>(info[1]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[0]));
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ arg1 = UnwrapGattSubscribedClient(info[1]);
          
          op2 = wrapper->_instance->NotifyValueAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() - 1].As<Function>());

      if (op1 != nullptr)
      {
          auto opTask = create_task(op1);
          opTask.then([asyncToken](task<::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^>^> t)
              {
                  try
                  {
                      auto result = t.get();
                      NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


                          Local<Value> error;
                          Local<Value> arg1;
                          {
                              TryCatch tryCatch;
                              arg1 = NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^>::CreateVectorViewWrapper(result,
                                  [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^ val) -> Local<Value> {
                                      return WrapGattClientNotificationResult(val);
                                  },
                                  [](Local<Value> value) -> bool {
                                      return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^>(value);
                                  },
                                      [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^ {
                                      return UnwrapGattClientNotificationResult(value);
                                  }
                                  );
                              if (tryCatch.HasCaught())
                              {
                                  error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
                              }
                              else
                              {
                                  error = Undefined();
                              }
                              if (arg1.IsEmpty()) arg1 = Undefined();
                          }
                          Local<Value> args[] = { error, arg1 };


                          invokeCallback(_countof(args), args);
                          });
                  }
                  catch (Platform::Exception^ exception)
                  {
                      NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

                          Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

                          Local<Value> args[] = { error };
                          invokeCallback(_countof(args), args);
                          });
                  }
              });
      }
      else
      {
          auto opTask = create_task(op2);
          opTask.then([asyncToken](task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult^> t)
              {
                  try
                  {
                      auto result = t.get();
                      NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

                          Local<Value> error;
                          Local<Value> arg1;
                          {
                              TryCatch tryCatch;
                              arg1 = WrapGattClientNotificationResult(result);
                              if (tryCatch.HasCaught())
                              {
                                  error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
                              }
                              else
                              {
                                  error = Undefined();
                              }
                              if (arg1.IsEmpty()) arg1 = Undefined();
                          }
                          Local<Value> args[] = { error, arg1 };


                          invokeCallback(_countof(args), args);
                          });
                  }
                  catch (Platform::Exception^ exception)
                  {
                      NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

                          Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

                          Local<Value> args[] = { error };
                          invokeCallback(_countof(args), args);
                          });
                  }
              });
      }
    }




    static void CharacteristicPropertiesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This())) {
        return;
      }

      GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties result = wrapper->_instance->CharacteristicProperties;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DescriptorsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This())) {
        return;
      }

      GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>^ result = wrapper->_instance->Descriptors;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ val) -> Local<Value> {
              return WrapGattLocalDescriptor(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ {
              return UnwrapGattLocalDescriptor(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PresentationFormatsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This())) {
        return;
      }

      GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>^ result = wrapper->_instance->PresentationFormats;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ val) -> Local<Value> {
              return WrapGattPresentationFormat(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ {
              return UnwrapGattPresentationFormat(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ReadProtectionLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This())) {
        return;
      }

      GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel result = wrapper->_instance->ReadProtectionLevel;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StaticValueGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This())) {
        return;
      }

      GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());

      try  {
        ::Windows::Storage::Streams::IBuffer^ result = wrapper->_instance->StaticValue;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SubscribedClientsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This())) {
        return;
      }

      GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^>^ result = wrapper->_instance->SubscribedClients;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ val) -> Local<Value> {
              return WrapGattSubscribedClient(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ {
              return UnwrapGattSubscribedClient(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UserDescriptionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This())) {
        return;
      }

      GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->UserDescription;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UuidGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This())) {
        return;
      }

      GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());

      try  {
        ::Platform::Guid result = wrapper->_instance->Uuid;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void WriteProtectionLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This())) {
        return;
      }

      GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel result = wrapper->_instance->WriteProtectionLevel;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"readRequested", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->ReadRequested::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ arg0, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapGattLocalCharacteristic(arg0);
                  wrappedArg1 = WrapGattReadRequestedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"subscribedClientsChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->SubscribedClientsChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapGattLocalCharacteristic(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"writeRequested", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->WriteRequested::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ arg0, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapGattLocalCharacteristic(arg0);
                  wrappedArg1 = WrapGattWriteRequestedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"readRequested", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"subscribedClientsChanged", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"writeRequested", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"readRequested", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());
          wrapper->_instance->ReadRequested::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"subscribedClientsChanged", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());
          wrapper->_instance->SubscribedClientsChanged::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"writeRequested", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          GattLocalCharacteristic *wrapper = GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(info.This());
          wrapper->_instance->WriteRequested::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattLocalCharacteristic(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ UnwrapGattLocalCharacteristic(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattLocalCharacteristic::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattLocalCharacteristic(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattLocalCharacteristic::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ UnwrapGattLocalCharacteristic(Local<Value> value) {
     return GattLocalCharacteristic::Unwrap<GattLocalCharacteristic>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattLocalCharacteristic(Local<Object> exports) {
    GattLocalCharacteristic::Init(exports);
  }

  class GattLocalCharacteristicParameters : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattLocalCharacteristicParameters").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("writeProtectionLevel").ToLocalChecked(), WriteProtectionLevelGetter, WriteProtectionLevelSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("userDescription").ToLocalChecked(), UserDescriptionGetter, UserDescriptionSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("staticValue").ToLocalChecked(), StaticValueGetter, StaticValueSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("readProtectionLevel").ToLocalChecked(), ReadProtectionLevelGetter, ReadProtectionLevelSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("characteristicProperties").ToLocalChecked(), CharacteristicPropertiesGetter, CharacteristicPropertiesSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("presentationFormats").ToLocalChecked(), PresentationFormatsGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattLocalCharacteristicParameters").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattLocalCharacteristicParameters(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattLocalCharacteristicParameters *wrapperInstance = new GattLocalCharacteristicParameters(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattLocalCharacteristicParameters(winRtInstance));
    }





    static void WriteProtectionLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info.This())) {
        return;
      }

      GattLocalCharacteristicParameters *wrapper = GattLocalCharacteristicParameters::Unwrap<GattLocalCharacteristicParameters>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel result = wrapper->_instance->WriteProtectionLevel;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void WriteProtectionLevelSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info.This())) {
        return;
      }

      GattLocalCharacteristicParameters *wrapper = GattLocalCharacteristicParameters::Unwrap<GattLocalCharacteristicParameters>(info.This());

      try {

        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel winRtValue = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->WriteProtectionLevel = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void UserDescriptionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info.This())) {
        return;
      }

      GattLocalCharacteristicParameters *wrapper = GattLocalCharacteristicParameters::Unwrap<GattLocalCharacteristicParameters>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->UserDescription;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UserDescriptionSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsString()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info.This())) {
        return;
      }

      GattLocalCharacteristicParameters *wrapper = GattLocalCharacteristicParameters::Unwrap<GattLocalCharacteristicParameters>(info.This());

      try {

        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));

        wrapper->_instance->UserDescription = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void StaticValueGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info.This())) {
        return;
      }

      GattLocalCharacteristicParameters *wrapper = GattLocalCharacteristicParameters::Unwrap<GattLocalCharacteristicParameters>(info.This());

      try  {
        ::Windows::Storage::Streams::IBuffer^ result = wrapper->_instance->StaticValue;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StaticValueSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info.This())) {
        return;
      }

      GattLocalCharacteristicParameters *wrapper = GattLocalCharacteristicParameters::Unwrap<GattLocalCharacteristicParameters>(info.This());

      try {

        ::Windows::Storage::Streams::IBuffer^ winRtValue = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->StaticValue = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void ReadProtectionLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info.This())) {
        return;
      }

      GattLocalCharacteristicParameters *wrapper = GattLocalCharacteristicParameters::Unwrap<GattLocalCharacteristicParameters>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel result = wrapper->_instance->ReadProtectionLevel;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ReadProtectionLevelSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info.This())) {
        return;
      }

      GattLocalCharacteristicParameters *wrapper = GattLocalCharacteristicParameters::Unwrap<GattLocalCharacteristicParameters>(info.This());

      try {

        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel winRtValue = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->ReadProtectionLevel = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void CharacteristicPropertiesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info.This())) {
        return;
      }

      GattLocalCharacteristicParameters *wrapper = GattLocalCharacteristicParameters::Unwrap<GattLocalCharacteristicParameters>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties result = wrapper->_instance->CharacteristicProperties;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CharacteristicPropertiesSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info.This())) {
        return;
      }

      GattLocalCharacteristicParameters *wrapper = GattLocalCharacteristicParameters::Unwrap<GattLocalCharacteristicParameters>(info.This());

      try {

        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties winRtValue = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->CharacteristicProperties = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void PresentationFormatsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info.This())) {
        return;
      }

      GattLocalCharacteristicParameters *wrapper = GattLocalCharacteristicParameters::Unwrap<GattLocalCharacteristicParameters>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVector<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>^ result = wrapper->_instance->PresentationFormats;
        info.GetReturnValue().Set(NodeRT::Collections::VectorWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>::CreateVectorWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ val) -> Local<Value> {
              return WrapGattPresentationFormat(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ {
              return UnwrapGattPresentationFormat(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattLocalCharacteristicParameters(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^ UnwrapGattLocalCharacteristicParameters(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattLocalCharacteristicParameters::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattLocalCharacteristicParameters(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattLocalCharacteristicParameters::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^ UnwrapGattLocalCharacteristicParameters(Local<Value> value) {
     return GattLocalCharacteristicParameters::Unwrap<GattLocalCharacteristicParameters>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattLocalCharacteristicParameters(Local<Object> exports) {
    GattLocalCharacteristicParameters::Init(exports);
  }

  class GattLocalCharacteristicResult : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattLocalCharacteristicResult").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("characteristic").ToLocalChecked(), CharacteristicGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("error").ToLocalChecked(), ErrorGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattLocalCharacteristicResult").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattLocalCharacteristicResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattLocalCharacteristicResult *wrapperInstance = new GattLocalCharacteristicResult(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattLocalCharacteristicResult(winRtInstance));
    }





    static void CharacteristicGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^>(info.This())) {
        return;
      }

      GattLocalCharacteristicResult *wrapper = GattLocalCharacteristicResult::Unwrap<GattLocalCharacteristicResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ result = wrapper->_instance->Characteristic;
        info.GetReturnValue().Set(WrapGattLocalCharacteristic(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^>(info.This())) {
        return;
      }

      GattLocalCharacteristicResult *wrapper = GattLocalCharacteristicResult::Unwrap<GattLocalCharacteristicResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothError result = wrapper->_instance->Error;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattLocalCharacteristicResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^ UnwrapGattLocalCharacteristicResult(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattLocalCharacteristicResult::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattLocalCharacteristicResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattLocalCharacteristicResult::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^ UnwrapGattLocalCharacteristicResult(Local<Value> value) {
     return GattLocalCharacteristicResult::Unwrap<GattLocalCharacteristicResult>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattLocalCharacteristicResult(Local<Object> exports) {
    GattLocalCharacteristicResult::Init(exports);
  }

  class GattLocalDescriptor : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattLocalDescriptor").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);




          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("readProtectionLevel").ToLocalChecked(), ReadProtectionLevelGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("staticValue").ToLocalChecked(), StaticValueGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("uuid").ToLocalChecked(), UuidGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("writeProtectionLevel").ToLocalChecked(), WriteProtectionLevelGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattLocalDescriptor").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattLocalDescriptor(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattLocalDescriptor *wrapperInstance = new GattLocalDescriptor(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattLocalDescriptor(winRtInstance));
    }





    static void ReadProtectionLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>(info.This())) {
        return;
      }

      GattLocalDescriptor *wrapper = GattLocalDescriptor::Unwrap<GattLocalDescriptor>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel result = wrapper->_instance->ReadProtectionLevel;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StaticValueGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>(info.This())) {
        return;
      }

      GattLocalDescriptor *wrapper = GattLocalDescriptor::Unwrap<GattLocalDescriptor>(info.This());

      try  {
        ::Windows::Storage::Streams::IBuffer^ result = wrapper->_instance->StaticValue;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UuidGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>(info.This())) {
        return;
      }

      GattLocalDescriptor *wrapper = GattLocalDescriptor::Unwrap<GattLocalDescriptor>(info.This());

      try  {
        ::Platform::Guid result = wrapper->_instance->Uuid;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void WriteProtectionLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>(info.This())) {
        return;
      }

      GattLocalDescriptor *wrapper = GattLocalDescriptor::Unwrap<GattLocalDescriptor>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel result = wrapper->_instance->WriteProtectionLevel;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"readRequested", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        GattLocalDescriptor *wrapper = GattLocalDescriptor::Unwrap<GattLocalDescriptor>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->ReadRequested::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ arg0, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapGattLocalDescriptor(arg0);
                  wrappedArg1 = WrapGattReadRequestedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"writeRequested", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        GattLocalDescriptor *wrapper = GattLocalDescriptor::Unwrap<GattLocalDescriptor>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->WriteRequested::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ arg0, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapGattLocalDescriptor(arg0);
                  wrappedArg1 = WrapGattWriteRequestedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"readRequested", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"writeRequested", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"readRequested", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          GattLocalDescriptor *wrapper = GattLocalDescriptor::Unwrap<GattLocalDescriptor>(info.This());
          wrapper->_instance->ReadRequested::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"writeRequested", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          GattLocalDescriptor *wrapper = GattLocalDescriptor::Unwrap<GattLocalDescriptor>(info.This());
          wrapper->_instance->WriteRequested::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattLocalDescriptor(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ UnwrapGattLocalDescriptor(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattLocalDescriptor::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattLocalDescriptor(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattLocalDescriptor::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ UnwrapGattLocalDescriptor(Local<Value> value) {
     return GattLocalDescriptor::Unwrap<GattLocalDescriptor>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattLocalDescriptor(Local<Object> exports) {
    GattLocalDescriptor::Init(exports);
  }

  class GattLocalDescriptorParameters : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattLocalDescriptorParameters").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("writeProtectionLevel").ToLocalChecked(), WriteProtectionLevelGetter, WriteProtectionLevelSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("staticValue").ToLocalChecked(), StaticValueGetter, StaticValueSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("readProtectionLevel").ToLocalChecked(), ReadProtectionLevelGetter, ReadProtectionLevelSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattLocalDescriptorParameters").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattLocalDescriptorParameters(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattLocalDescriptorParameters *wrapperInstance = new GattLocalDescriptorParameters(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattLocalDescriptorParameters(winRtInstance));
    }





    static void WriteProtectionLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^>(info.This())) {
        return;
      }

      GattLocalDescriptorParameters *wrapper = GattLocalDescriptorParameters::Unwrap<GattLocalDescriptorParameters>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel result = wrapper->_instance->WriteProtectionLevel;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void WriteProtectionLevelSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^>(info.This())) {
        return;
      }

      GattLocalDescriptorParameters *wrapper = GattLocalDescriptorParameters::Unwrap<GattLocalDescriptorParameters>(info.This());

      try {

        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel winRtValue = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->WriteProtectionLevel = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void StaticValueGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^>(info.This())) {
        return;
      }

      GattLocalDescriptorParameters *wrapper = GattLocalDescriptorParameters::Unwrap<GattLocalDescriptorParameters>(info.This());

      try  {
        ::Windows::Storage::Streams::IBuffer^ result = wrapper->_instance->StaticValue;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StaticValueSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^>(info.This())) {
        return;
      }

      GattLocalDescriptorParameters *wrapper = GattLocalDescriptorParameters::Unwrap<GattLocalDescriptorParameters>(info.This());

      try {

        ::Windows::Storage::Streams::IBuffer^ winRtValue = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->StaticValue = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void ReadProtectionLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^>(info.This())) {
        return;
      }

      GattLocalDescriptorParameters *wrapper = GattLocalDescriptorParameters::Unwrap<GattLocalDescriptorParameters>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel result = wrapper->_instance->ReadProtectionLevel;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ReadProtectionLevelSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^>(info.This())) {
        return;
      }

      GattLocalDescriptorParameters *wrapper = GattLocalDescriptorParameters::Unwrap<GattLocalDescriptorParameters>(info.This());

      try {

        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel winRtValue = static_cast<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->ReadProtectionLevel = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattLocalDescriptorParameters(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^ UnwrapGattLocalDescriptorParameters(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattLocalDescriptorParameters::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattLocalDescriptorParameters(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattLocalDescriptorParameters::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters^ UnwrapGattLocalDescriptorParameters(Local<Value> value) {
     return GattLocalDescriptorParameters::Unwrap<GattLocalDescriptorParameters>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattLocalDescriptorParameters(Local<Object> exports) {
    GattLocalDescriptorParameters::Init(exports);
  }

  class GattLocalDescriptorResult : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattLocalDescriptorResult").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("descriptor").ToLocalChecked(), DescriptorGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("error").ToLocalChecked(), ErrorGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattLocalDescriptorResult").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattLocalDescriptorResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattLocalDescriptorResult *wrapperInstance = new GattLocalDescriptorResult(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattLocalDescriptorResult(winRtInstance));
    }





    static void DescriptorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^>(info.This())) {
        return;
      }

      GattLocalDescriptorResult *wrapper = GattLocalDescriptorResult::Unwrap<GattLocalDescriptorResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor^ result = wrapper->_instance->Descriptor;
        info.GetReturnValue().Set(WrapGattLocalDescriptor(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^>(info.This())) {
        return;
      }

      GattLocalDescriptorResult *wrapper = GattLocalDescriptorResult::Unwrap<GattLocalDescriptorResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothError result = wrapper->_instance->Error;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattLocalDescriptorResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^ UnwrapGattLocalDescriptorResult(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattLocalDescriptorResult::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattLocalDescriptorResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattLocalDescriptorResult::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult^ UnwrapGattLocalDescriptorResult(Local<Value> value) {
     return GattLocalDescriptorResult::Unwrap<GattLocalDescriptorResult>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattLocalDescriptorResult(Local<Object> exports) {
    GattLocalDescriptorResult::Init(exports);
  }

  class GattLocalService : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattLocalService").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;


          
            Nan::SetPrototypeMethod(localRef, "createCharacteristicAsync", CreateCharacteristicAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("characteristics").ToLocalChecked(), CharacteristicsGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("uuid").ToLocalChecked(), UuidGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattLocalService").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattLocalService(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattLocalService *wrapperInstance = new GattLocalService(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattLocalService(winRtInstance));
    }

    static void CreateCharacteristicAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattLocalService *wrapper = GattLocalService::Unwrap<GattLocalService>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^>^ op;


      if (info.Length() == 3
        && NodeRT::Utils::IsGuid(info[0])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^>(info[1]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters^ arg1 = UnwrapGattLocalCharacteristicParameters(info[1]);
          
          op = wrapper->_instance->CreateCharacteristicAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattLocalCharacteristicResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }




    static void CharacteristicsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^>(info.This())) {
        return;
      }

      GattLocalService *wrapper = GattLocalService::Unwrap<GattLocalService>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>^ result = wrapper->_instance->Characteristics;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ val) -> Local<Value> {
              return WrapGattLocalCharacteristic(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic^ {
              return UnwrapGattLocalCharacteristic(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UuidGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^>(info.This())) {
        return;
      }

      GattLocalService *wrapper = GattLocalService::Unwrap<GattLocalService>(info.This());

      try  {
        ::Platform::Guid result = wrapper->_instance->Uuid;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattLocalService(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^ UnwrapGattLocalService(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattLocalService::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattLocalService(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattLocalService::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^ UnwrapGattLocalService(Local<Value> value) {
     return GattLocalService::Unwrap<GattLocalService>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattLocalService(Local<Object> exports) {
    GattLocalService::Init(exports);
  }

  class GattPresentationFormat : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattPresentationFormat").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("description").ToLocalChecked(), DescriptionGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("exponent").ToLocalChecked(), ExponentGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("formatType").ToLocalChecked(), FormatTypeGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("namespace").ToLocalChecked(), NamespaceGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("unit").ToLocalChecked(), UnitGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "fromParts", FromParts);
        Nan::SetAccessor(constructor, Nan::New<String>("bluetoothSigAssignedNumbers").ToLocalChecked(), BluetoothSigAssignedNumbersGetter);


        Nan::Set(exports, Nan::New<String>("GattPresentationFormat").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattPresentationFormat(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattPresentationFormat *wrapperInstance = new GattPresentationFormat(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattPresentationFormat(winRtInstance));
    }





    static void FromParts(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 5
        && info[0]->IsInt32()
        && info[1]->IsInt32()
        && info[2]->IsInt32()
        && info[3]->IsInt32()
        && info[4]->IsInt32())
      {
        try
        {
          unsigned char arg0 = static_cast<unsigned char>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          int arg1 = static_cast<int>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          unsigned short arg2 = static_cast<unsigned short>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          unsigned char arg3 = static_cast<unsigned char>(Nan::To<int32_t>(info[3]).FromMaybe(0));
          unsigned short arg4 = static_cast<unsigned short>(Nan::To<int32_t>(info[4]).FromMaybe(0));
          
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ result;
          result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat::FromParts(arg0, arg1, arg2, arg3, arg4);
          info.GetReturnValue().Set(WrapGattPresentationFormat(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void DescriptionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>(info.This())) {
        return;
      }

      GattPresentationFormat *wrapper = GattPresentationFormat::Unwrap<GattPresentationFormat>(info.This());

      try  {
        unsigned short result = wrapper->_instance->Description;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ExponentGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>(info.This())) {
        return;
      }

      GattPresentationFormat *wrapper = GattPresentationFormat::Unwrap<GattPresentationFormat>(info.This());

      try  {
        int result = wrapper->_instance->Exponent;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void FormatTypeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>(info.This())) {
        return;
      }

      GattPresentationFormat *wrapper = GattPresentationFormat::Unwrap<GattPresentationFormat>(info.This());

      try  {
        unsigned char result = wrapper->_instance->FormatType;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void NamespaceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>(info.This())) {
        return;
      }

      GattPresentationFormat *wrapper = GattPresentationFormat::Unwrap<GattPresentationFormat>(info.This());

      try  {
        unsigned char result = wrapper->_instance->Namespace;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UnitGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^>(info.This())) {
        return;
      }

      GattPresentationFormat *wrapper = GattPresentationFormat::Unwrap<GattPresentationFormat>(info.This());

      try  {
        unsigned short result = wrapper->_instance->Unit;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void BluetoothSigAssignedNumbersGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat::BluetoothSigAssignedNumbers;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattPresentationFormat(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ UnwrapGattPresentationFormat(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattPresentationFormat::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattPresentationFormat(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattPresentationFormat::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat^ UnwrapGattPresentationFormat(Local<Value> value) {
     return GattPresentationFormat::Unwrap<GattPresentationFormat>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattPresentationFormat(Local<Object> exports) {
    GattPresentationFormat::Init(exports);
  }

  class GattPresentationFormatTypes : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattPresentationFormatTypes").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetAccessor(constructor, Nan::New<String>("bit2").ToLocalChecked(), Bit2Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("boolean").ToLocalChecked(), BooleanGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("dUInt16").ToLocalChecked(), DUInt16Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("float").ToLocalChecked(), FloatGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("float32").ToLocalChecked(), Float32Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("float64").ToLocalChecked(), Float64Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("nibble").ToLocalChecked(), NibbleGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("sFloat").ToLocalChecked(), SFloatGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("sInt12").ToLocalChecked(), SInt12Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("sInt128").ToLocalChecked(), SInt128Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("sInt16").ToLocalChecked(), SInt16Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("sInt24").ToLocalChecked(), SInt24Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("sInt32").ToLocalChecked(), SInt32Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("sInt48").ToLocalChecked(), SInt48Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("sInt64").ToLocalChecked(), SInt64Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("sInt8").ToLocalChecked(), SInt8Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("struct").ToLocalChecked(), StructGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("uInt12").ToLocalChecked(), UInt12Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("uInt128").ToLocalChecked(), UInt128Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("uInt16").ToLocalChecked(), UInt16Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("uInt24").ToLocalChecked(), UInt24Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("uInt32").ToLocalChecked(), UInt32Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("uInt48").ToLocalChecked(), UInt48Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("uInt64").ToLocalChecked(), UInt64Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("uInt8").ToLocalChecked(), UInt8Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("utf16").ToLocalChecked(), Utf16Getter);
        Nan::SetAccessor(constructor, Nan::New<String>("utf8").ToLocalChecked(), Utf8Getter);


        Nan::Set(exports, Nan::New<String>("GattPresentationFormatTypes").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattPresentationFormatTypes(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattPresentationFormatTypes *wrapperInstance = new GattPresentationFormatTypes(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattPresentationFormatTypes(winRtInstance));
    }







    static void Bit2Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Bit2;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void BooleanGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Boolean;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void DUInt16Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::DUInt16;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void FloatGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Float;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void Float32Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Float32;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void Float64Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Float64;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void NibbleGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Nibble;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SFloatGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SFloat;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SInt12Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt12;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SInt128Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt128;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SInt16Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt16;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SInt24Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt24;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SInt32Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt32;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SInt48Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt48;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SInt64Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt64;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void SInt8Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt8;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void StructGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Struct;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void UInt12Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt12;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void UInt128Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt128;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void UInt16Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt16;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void UInt24Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt24;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void UInt32Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt32;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void UInt48Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt48;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void UInt64Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt64;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void UInt8Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt8;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void Utf16Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Utf16;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void Utf8Getter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Utf8;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattPresentationFormatTypes(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^ UnwrapGattPresentationFormatTypes(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattPresentationFormatTypes::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattPresentationFormatTypes(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattPresentationFormatTypes::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes^ UnwrapGattPresentationFormatTypes(Local<Value> value) {
     return GattPresentationFormatTypes::Unwrap<GattPresentationFormatTypes>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattPresentationFormatTypes(Local<Object> exports) {
    GattPresentationFormatTypes::Init(exports);
  }

  class GattProtocolError : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattProtocolError").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetAccessor(constructor, Nan::New<String>("attributeNotFound").ToLocalChecked(), AttributeNotFoundGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("attributeNotLong").ToLocalChecked(), AttributeNotLongGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("insufficientAuthentication").ToLocalChecked(), InsufficientAuthenticationGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("insufficientAuthorization").ToLocalChecked(), InsufficientAuthorizationGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("insufficientEncryption").ToLocalChecked(), InsufficientEncryptionGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("insufficientEncryptionKeySize").ToLocalChecked(), InsufficientEncryptionKeySizeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("insufficientResources").ToLocalChecked(), InsufficientResourcesGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("invalidAttributeValueLength").ToLocalChecked(), InvalidAttributeValueLengthGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("invalidHandle").ToLocalChecked(), InvalidHandleGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("invalidOffset").ToLocalChecked(), InvalidOffsetGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("invalidPdu").ToLocalChecked(), InvalidPduGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("prepareQueueFull").ToLocalChecked(), PrepareQueueFullGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("readNotPermitted").ToLocalChecked(), ReadNotPermittedGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("requestNotSupported").ToLocalChecked(), RequestNotSupportedGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("unlikelyError").ToLocalChecked(), UnlikelyErrorGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("unsupportedGroupType").ToLocalChecked(), UnsupportedGroupTypeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("writeNotPermitted").ToLocalChecked(), WriteNotPermittedGetter);


        Nan::Set(exports, Nan::New<String>("GattProtocolError").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattProtocolError(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattProtocolError *wrapperInstance = new GattProtocolError(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattProtocolError(winRtInstance));
    }







    static void AttributeNotFoundGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::AttributeNotFound;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void AttributeNotLongGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::AttributeNotLong;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void InsufficientAuthenticationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InsufficientAuthentication;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void InsufficientAuthorizationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InsufficientAuthorization;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void InsufficientEncryptionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InsufficientEncryption;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void InsufficientEncryptionKeySizeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InsufficientEncryptionKeySize;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void InsufficientResourcesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InsufficientResources;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void InvalidAttributeValueLengthGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InvalidAttributeValueLength;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void InvalidHandleGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InvalidHandle;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void InvalidOffsetGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InvalidOffset;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void InvalidPduGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InvalidPdu;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void PrepareQueueFullGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::PrepareQueueFull;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ReadNotPermittedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::ReadNotPermitted;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RequestNotSupportedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::RequestNotSupported;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void UnlikelyErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::UnlikelyError;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void UnsupportedGroupTypeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::UnsupportedGroupType;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void WriteNotPermittedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        unsigned char result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::WriteNotPermitted;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattProtocolError(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^ UnwrapGattProtocolError(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattProtocolError::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattProtocolError(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattProtocolError::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError^ UnwrapGattProtocolError(Local<Value> value) {
     return GattProtocolError::Unwrap<GattProtocolError>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattProtocolError(Local<Object> exports) {
    GattProtocolError::Init(exports);
  }

  class GattReadClientCharacteristicConfigurationDescriptorResult : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattReadClientCharacteristicConfigurationDescriptorResult").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("clientCharacteristicConfigurationDescriptor").ToLocalChecked(), ClientCharacteristicConfigurationDescriptorGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("protocolError").ToLocalChecked(), ProtocolErrorGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattReadClientCharacteristicConfigurationDescriptorResult").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattReadClientCharacteristicConfigurationDescriptorResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattReadClientCharacteristicConfigurationDescriptorResult *wrapperInstance = new GattReadClientCharacteristicConfigurationDescriptorResult(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattReadClientCharacteristicConfigurationDescriptorResult(winRtInstance));
    }





    static void ClientCharacteristicConfigurationDescriptorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^>(info.This())) {
        return;
      }

      GattReadClientCharacteristicConfigurationDescriptorResult *wrapper = GattReadClientCharacteristicConfigurationDescriptorResult::Unwrap<GattReadClientCharacteristicConfigurationDescriptorResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientCharacteristicConfigurationDescriptorValue result = wrapper->_instance->ClientCharacteristicConfigurationDescriptor;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^>(info.This())) {
        return;
      }

      GattReadClientCharacteristicConfigurationDescriptorResult *wrapper = GattReadClientCharacteristicConfigurationDescriptorResult::Unwrap<GattReadClientCharacteristicConfigurationDescriptorResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ProtocolErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^>(info.This())) {
        return;
      }

      GattReadClientCharacteristicConfigurationDescriptorResult *wrapper = GattReadClientCharacteristicConfigurationDescriptorResult::Unwrap<GattReadClientCharacteristicConfigurationDescriptorResult>(info.This());

      try  {
        ::Platform::IBox<unsigned char>^ result = wrapper->_instance->ProtocolError;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattReadClientCharacteristicConfigurationDescriptorResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^ UnwrapGattReadClientCharacteristicConfigurationDescriptorResult(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattReadClientCharacteristicConfigurationDescriptorResult::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattReadClientCharacteristicConfigurationDescriptorResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattReadClientCharacteristicConfigurationDescriptorResult::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult^ UnwrapGattReadClientCharacteristicConfigurationDescriptorResult(Local<Value> value) {
     return GattReadClientCharacteristicConfigurationDescriptorResult::Unwrap<GattReadClientCharacteristicConfigurationDescriptorResult>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattReadClientCharacteristicConfigurationDescriptorResult(Local<Object> exports) {
    GattReadClientCharacteristicConfigurationDescriptorResult::Init(exports);
  }

  class GattReadRequest : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattReadRequest").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "respondWithValue", RespondWithValue);
            Nan::SetPrototypeMethod(localRef, "respondWithProtocolError", RespondWithProtocolError);
          


          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("length").ToLocalChecked(), LengthGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("offset").ToLocalChecked(), OffsetGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("state").ToLocalChecked(), StateGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattReadRequest").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattReadRequest(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattReadRequest *wrapperInstance = new GattReadRequest(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattReadRequest(winRtInstance));
    }


    static void RespondWithValue(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^>(info.This())) {
        return;
      }

      GattReadRequest *wrapper = GattReadRequest::Unwrap<GattReadRequest>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          wrapper->_instance->RespondWithValue(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void RespondWithProtocolError(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^>(info.This())) {
        return;
      }

      GattReadRequest *wrapper = GattReadRequest::Unwrap<GattReadRequest>(info.This());

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned char arg0 = static_cast<unsigned char>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->RespondWithProtocolError(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void LengthGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^>(info.This())) {
        return;
      }

      GattReadRequest *wrapper = GattReadRequest::Unwrap<GattReadRequest>(info.This());

      try  {
        unsigned int result = wrapper->_instance->Length;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void OffsetGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^>(info.This())) {
        return;
      }

      GattReadRequest *wrapper = GattReadRequest::Unwrap<GattReadRequest>(info.This());

      try  {
        unsigned int result = wrapper->_instance->Offset;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StateGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^>(info.This())) {
        return;
      }

      GattReadRequest *wrapper = GattReadRequest::Unwrap<GattReadRequest>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestState result = wrapper->_instance->State;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"stateChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        GattReadRequest *wrapper = GattReadRequest::Unwrap<GattReadRequest>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->StateChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^ arg0, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapGattReadRequest(arg0);
                  wrappedArg1 = WrapGattRequestStateChangedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"stateChanged", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"stateChanged", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          GattReadRequest *wrapper = GattReadRequest::Unwrap<GattReadRequest>(info.This());
          wrapper->_instance->StateChanged::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattReadRequest(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^ UnwrapGattReadRequest(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattReadRequest::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattReadRequest(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattReadRequest::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^ UnwrapGattReadRequest(Local<Value> value) {
     return GattReadRequest::Unwrap<GattReadRequest>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattReadRequest(Local<Object> exports) {
    GattReadRequest::Init(exports);
  }

  class GattReadRequestedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattReadRequestedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "getDeferral", GetDeferral);
          

          
            Nan::SetPrototypeMethod(localRef, "getRequestAsync", GetRequestAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("session").ToLocalChecked(), SessionGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattReadRequestedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattReadRequestedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattReadRequestedEventArgs *wrapperInstance = new GattReadRequestedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattReadRequestedEventArgs(winRtInstance));
    }

    static void GetRequestAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattReadRequestedEventArgs *wrapper = GattReadRequestedEventArgs::Unwrap<GattReadRequestedEventArgs>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetRequestAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattReadRequest(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void GetDeferral(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^>(info.This())) {
        return;
      }

      GattReadRequestedEventArgs *wrapper = GattReadRequestedEventArgs::Unwrap<GattReadRequestedEventArgs>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Deferral^ result;
          result = wrapper->_instance->GetDeferral();
          info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation", "Deferral", result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void SessionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^>(info.This())) {
        return;
      }

      GattReadRequestedEventArgs *wrapper = GattReadRequestedEventArgs::Unwrap<GattReadRequestedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ result = wrapper->_instance->Session;
        info.GetReturnValue().Set(WrapGattSession(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattReadRequestedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^ UnwrapGattReadRequestedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattReadRequestedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattReadRequestedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattReadRequestedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs^ UnwrapGattReadRequestedEventArgs(Local<Value> value) {
     return GattReadRequestedEventArgs::Unwrap<GattReadRequestedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattReadRequestedEventArgs(Local<Object> exports) {
    GattReadRequestedEventArgs::Init(exports);
  }

  class GattReadResult : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattReadResult").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("value").ToLocalChecked(), ValueGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("protocolError").ToLocalChecked(), ProtocolErrorGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattReadResult").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattReadResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattReadResult *wrapperInstance = new GattReadResult(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattReadResult(winRtInstance));
    }





    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^>(info.This())) {
        return;
      }

      GattReadResult *wrapper = GattReadResult::Unwrap<GattReadResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ValueGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^>(info.This())) {
        return;
      }

      GattReadResult *wrapper = GattReadResult::Unwrap<GattReadResult>(info.This());

      try  {
        ::Windows::Storage::Streams::IBuffer^ result = wrapper->_instance->Value;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ProtocolErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^>(info.This())) {
        return;
      }

      GattReadResult *wrapper = GattReadResult::Unwrap<GattReadResult>(info.This());

      try  {
        ::Platform::IBox<unsigned char>^ result = wrapper->_instance->ProtocolError;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattReadResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^ UnwrapGattReadResult(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattReadResult::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattReadResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattReadResult::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult^ UnwrapGattReadResult(Local<Value> value) {
     return GattReadResult::Unwrap<GattReadResult>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattReadResult(Local<Object> exports) {
    GattReadResult::Init(exports);
  }

  class GattReliableWriteTransaction : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattReliableWriteTransaction").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "writeValue", WriteValue);
          

          
            Nan::SetPrototypeMethod(localRef, "commitAsync", CommitAsync);
            Nan::SetPrototypeMethod(localRef, "commitWithResultAsync", CommitWithResultAsync);
          



        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattReliableWriteTransaction").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattReliableWriteTransaction(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattReliableWriteTransaction *wrapperInstance = new GattReliableWriteTransaction(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattReliableWriteTransaction(winRtInstance));
    }

    static void CommitAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattReliableWriteTransaction *wrapper = GattReliableWriteTransaction::Unwrap<GattReliableWriteTransaction>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->CommitAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(static_cast<int>(result));
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void CommitWithResultAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattReliableWriteTransaction *wrapper = GattReliableWriteTransaction::Unwrap<GattReliableWriteTransaction>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->CommitWithResultAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattWriteResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void WriteValue(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^>(info.This())) {
        return;
      }

      GattReliableWriteTransaction *wrapper = GattReliableWriteTransaction::Unwrap<GattReliableWriteTransaction>(info.This());

      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^>(info[0])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[1]))
      {
        try
        {
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic^ arg0 = UnwrapGattCharacteristic(info[0]);
          ::Windows::Storage::Streams::IBuffer^ arg1 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[1]));
          
          wrapper->_instance->WriteValue(arg0, arg1);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }





    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattReliableWriteTransaction(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^ UnwrapGattReliableWriteTransaction(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattReliableWriteTransaction::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattReliableWriteTransaction(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattReliableWriteTransaction::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction^ UnwrapGattReliableWriteTransaction(Local<Value> value) {
     return GattReliableWriteTransaction::Unwrap<GattReliableWriteTransaction>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattReliableWriteTransaction(Local<Object> exports) {
    GattReliableWriteTransaction::Init(exports);
  }

  class GattRequestStateChangedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattRequestStateChangedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("error").ToLocalChecked(), ErrorGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("state").ToLocalChecked(), StateGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattRequestStateChangedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattRequestStateChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattRequestStateChangedEventArgs *wrapperInstance = new GattRequestStateChangedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattRequestStateChangedEventArgs(winRtInstance));
    }





    static void ErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^>(info.This())) {
        return;
      }

      GattRequestStateChangedEventArgs *wrapper = GattRequestStateChangedEventArgs::Unwrap<GattRequestStateChangedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothError result = wrapper->_instance->Error;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StateGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^>(info.This())) {
        return;
      }

      GattRequestStateChangedEventArgs *wrapper = GattRequestStateChangedEventArgs::Unwrap<GattRequestStateChangedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestState result = wrapper->_instance->State;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattRequestStateChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^ UnwrapGattRequestStateChangedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattRequestStateChangedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattRequestStateChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattRequestStateChangedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^ UnwrapGattRequestStateChangedEventArgs(Local<Value> value) {
     return GattRequestStateChangedEventArgs::Unwrap<GattRequestStateChangedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattRequestStateChangedEventArgs(Local<Object> exports) {
    GattRequestStateChangedEventArgs::Init(exports);
  }

  class GattServiceProvider : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattServiceProvider").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "startAdvertising", StartAdvertising);
            Nan::SetPrototypeMethod(localRef, "stopAdvertising", StopAdvertising);
          


          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("advertisementStatus").ToLocalChecked(), AdvertisementStatusGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("service").ToLocalChecked(), ServiceGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        func = Nan::GetFunction(Nan::New<FunctionTemplate>(CreateAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("createAsync").ToLocalChecked(), func);


        Nan::Set(exports, Nan::New<String>("GattServiceProvider").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattServiceProvider(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattServiceProvider *wrapperInstance = new GattServiceProvider(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattServiceProvider(winRtInstance));
    }


    static void StartAdvertising(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^>(info.This())) {
        return;
      }

      GattServiceProvider *wrapper = GattServiceProvider::Unwrap<GattServiceProvider>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->StartAdvertising();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^>(info[0]))
      {
        try
        {
          ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^ arg0 = UnwrapGattServiceProviderAdvertisingParameters(info[0]);
          
          wrapper->_instance->StartAdvertising(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void StopAdvertising(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^>(info.This())) {
        return;
      }

      GattServiceProvider *wrapper = GattServiceProvider::Unwrap<GattServiceProvider>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->StopAdvertising();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }


    static void CreateAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^>^ op;


      if (info.Length() == 2
          && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
            
          op = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider::CreateAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattServiceProviderResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void AdvertisementStatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^>(info.This())) {
        return;
      }

      GattServiceProvider *wrapper = GattServiceProvider::Unwrap<GattServiceProvider>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatus result = wrapper->_instance->AdvertisementStatus;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ServiceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^>(info.This())) {
        return;
      }

      GattServiceProvider *wrapper = GattServiceProvider::Unwrap<GattServiceProvider>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService^ result = wrapper->_instance->Service;
        info.GetReturnValue().Set(WrapGattLocalService(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"advertisementStatusChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        GattServiceProvider *wrapper = GattServiceProvider::Unwrap<GattServiceProvider>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->AdvertisementStatusChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^ arg0, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapGattServiceProvider(arg0);
                  wrappedArg1 = WrapGattServiceProviderAdvertisementStatusChangedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"advertisementStatusChanged", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"advertisementStatusChanged", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          GattServiceProvider *wrapper = GattServiceProvider::Unwrap<GattServiceProvider>(info.This());
          wrapper->_instance->AdvertisementStatusChanged::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattServiceProvider(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^ UnwrapGattServiceProvider(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattServiceProvider::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattServiceProvider(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattServiceProvider::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^ UnwrapGattServiceProvider(Local<Value> value) {
     return GattServiceProvider::Unwrap<GattServiceProvider>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattServiceProvider(Local<Object> exports) {
    GattServiceProvider::Init(exports);
  }

  class GattServiceProviderAdvertisementStatusChangedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattServiceProviderAdvertisementStatusChangedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("error").ToLocalChecked(), ErrorGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattServiceProviderAdvertisementStatusChangedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattServiceProviderAdvertisementStatusChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattServiceProviderAdvertisementStatusChangedEventArgs *wrapperInstance = new GattServiceProviderAdvertisementStatusChangedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattServiceProviderAdvertisementStatusChangedEventArgs(winRtInstance));
    }





    static void ErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^>(info.This())) {
        return;
      }

      GattServiceProviderAdvertisementStatusChangedEventArgs *wrapper = GattServiceProviderAdvertisementStatusChangedEventArgs::Unwrap<GattServiceProviderAdvertisementStatusChangedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothError result = wrapper->_instance->Error;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^>(info.This())) {
        return;
      }

      GattServiceProviderAdvertisementStatusChangedEventArgs *wrapper = GattServiceProviderAdvertisementStatusChangedEventArgs::Unwrap<GattServiceProviderAdvertisementStatusChangedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattServiceProviderAdvertisementStatusChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^ UnwrapGattServiceProviderAdvertisementStatusChangedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattServiceProviderAdvertisementStatusChangedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattServiceProviderAdvertisementStatusChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattServiceProviderAdvertisementStatusChangedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs^ UnwrapGattServiceProviderAdvertisementStatusChangedEventArgs(Local<Value> value) {
     return GattServiceProviderAdvertisementStatusChangedEventArgs::Unwrap<GattServiceProviderAdvertisementStatusChangedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattServiceProviderAdvertisementStatusChangedEventArgs(Local<Object> exports) {
    GattServiceProviderAdvertisementStatusChangedEventArgs::Init(exports);
  }

  class GattServiceProviderAdvertisingParameters : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattServiceProviderAdvertisingParameters").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isDiscoverable").ToLocalChecked(), IsDiscoverableGetter, IsDiscoverableSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isConnectable").ToLocalChecked(), IsConnectableGetter, IsConnectableSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("serviceData").ToLocalChecked(), ServiceDataGetter, ServiceDataSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattServiceProviderAdvertisingParameters").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattServiceProviderAdvertisingParameters(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattServiceProviderAdvertisingParameters *wrapperInstance = new GattServiceProviderAdvertisingParameters(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattServiceProviderAdvertisingParameters(winRtInstance));
    }





    static void IsDiscoverableGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^>(info.This())) {
        return;
      }

      GattServiceProviderAdvertisingParameters *wrapper = GattServiceProviderAdvertisingParameters::Unwrap<GattServiceProviderAdvertisingParameters>(info.This());

      try  {
        bool result = wrapper->_instance->IsDiscoverable;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsDiscoverableSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsBoolean()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^>(info.This())) {
        return;
      }

      GattServiceProviderAdvertisingParameters *wrapper = GattServiceProviderAdvertisingParameters::Unwrap<GattServiceProviderAdvertisingParameters>(info.This());

      try {

        bool winRtValue = Nan::To<bool>(value).FromMaybe(false);

        wrapper->_instance->IsDiscoverable = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void IsConnectableGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^>(info.This())) {
        return;
      }

      GattServiceProviderAdvertisingParameters *wrapper = GattServiceProviderAdvertisingParameters::Unwrap<GattServiceProviderAdvertisingParameters>(info.This());

      try  {
        bool result = wrapper->_instance->IsConnectable;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsConnectableSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsBoolean()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^>(info.This())) {
        return;
      }

      GattServiceProviderAdvertisingParameters *wrapper = GattServiceProviderAdvertisingParameters::Unwrap<GattServiceProviderAdvertisingParameters>(info.This());

      try {

        bool winRtValue = Nan::To<bool>(value).FromMaybe(false);

        wrapper->_instance->IsConnectable = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void ServiceDataGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^>(info.This())) {
        return;
      }

      GattServiceProviderAdvertisingParameters *wrapper = GattServiceProviderAdvertisingParameters::Unwrap<GattServiceProviderAdvertisingParameters>(info.This());

      try  {
        ::Windows::Storage::Streams::IBuffer^ result = wrapper->_instance->ServiceData;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ServiceDataSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^>(info.This())) {
        return;
      }

      GattServiceProviderAdvertisingParameters *wrapper = GattServiceProviderAdvertisingParameters::Unwrap<GattServiceProviderAdvertisingParameters>(info.This());

      try {

        ::Windows::Storage::Streams::IBuffer^ winRtValue = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->ServiceData = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattServiceProviderAdvertisingParameters(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^ UnwrapGattServiceProviderAdvertisingParameters(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattServiceProviderAdvertisingParameters::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattServiceProviderAdvertisingParameters(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattServiceProviderAdvertisingParameters::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters^ UnwrapGattServiceProviderAdvertisingParameters(Local<Value> value) {
     return GattServiceProviderAdvertisingParameters::Unwrap<GattServiceProviderAdvertisingParameters>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattServiceProviderAdvertisingParameters(Local<Object> exports) {
    GattServiceProviderAdvertisingParameters::Init(exports);
  }

  class GattServiceProviderResult : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattServiceProviderResult").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("error").ToLocalChecked(), ErrorGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("serviceProvider").ToLocalChecked(), ServiceProviderGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattServiceProviderResult").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattServiceProviderResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattServiceProviderResult *wrapperInstance = new GattServiceProviderResult(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattServiceProviderResult(winRtInstance));
    }





    static void ErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^>(info.This())) {
        return;
      }

      GattServiceProviderResult *wrapper = GattServiceProviderResult::Unwrap<GattServiceProviderResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothError result = wrapper->_instance->Error;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ServiceProviderGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^>(info.This())) {
        return;
      }

      GattServiceProviderResult *wrapper = GattServiceProviderResult::Unwrap<GattServiceProviderResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider^ result = wrapper->_instance->ServiceProvider;
        info.GetReturnValue().Set(WrapGattServiceProvider(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattServiceProviderResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^ UnwrapGattServiceProviderResult(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattServiceProviderResult::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattServiceProviderResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattServiceProviderResult::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult^ UnwrapGattServiceProviderResult(Local<Value> value) {
     return GattServiceProviderResult::Unwrap<GattServiceProviderResult>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattServiceProviderResult(Local<Object> exports) {
    GattServiceProviderResult::Init(exports);
  }

  class GattServiceUuids : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattServiceUuids").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetAccessor(constructor, Nan::New<String>("battery").ToLocalChecked(), BatteryGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("bloodPressure").ToLocalChecked(), BloodPressureGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cyclingSpeedAndCadence").ToLocalChecked(), CyclingSpeedAndCadenceGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("genericAccess").ToLocalChecked(), GenericAccessGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("genericAttribute").ToLocalChecked(), GenericAttributeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("glucose").ToLocalChecked(), GlucoseGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("healthThermometer").ToLocalChecked(), HealthThermometerGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("heartRate").ToLocalChecked(), HeartRateGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("runningSpeedAndCadence").ToLocalChecked(), RunningSpeedAndCadenceGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("alertNotification").ToLocalChecked(), AlertNotificationGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("currentTime").ToLocalChecked(), CurrentTimeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("cyclingPower").ToLocalChecked(), CyclingPowerGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("deviceInformation").ToLocalChecked(), DeviceInformationGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("humanInterfaceDevice").ToLocalChecked(), HumanInterfaceDeviceGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("immediateAlert").ToLocalChecked(), ImmediateAlertGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("linkLoss").ToLocalChecked(), LinkLossGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("locationAndNavigation").ToLocalChecked(), LocationAndNavigationGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("nextDstChange").ToLocalChecked(), NextDstChangeGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("phoneAlertStatus").ToLocalChecked(), PhoneAlertStatusGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("referenceTimeUpdate").ToLocalChecked(), ReferenceTimeUpdateGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("scanParameters").ToLocalChecked(), ScanParametersGetter);
        Nan::SetAccessor(constructor, Nan::New<String>("txPower").ToLocalChecked(), TxPowerGetter);


        Nan::Set(exports, Nan::New<String>("GattServiceUuids").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattServiceUuids(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattServiceUuids *wrapperInstance = new GattServiceUuids(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattServiceUuids(winRtInstance));
    }







    static void BatteryGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::Battery;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void BloodPressureGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::BloodPressure;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CyclingSpeedAndCadenceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::CyclingSpeedAndCadence;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GenericAccessGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::GenericAccess;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GenericAttributeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::GenericAttribute;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void GlucoseGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::Glucose;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void HealthThermometerGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::HealthThermometer;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void HeartRateGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::HeartRate;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void RunningSpeedAndCadenceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::RunningSpeedAndCadence;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void AlertNotificationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::AlertNotification;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CurrentTimeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::CurrentTime;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void CyclingPowerGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::CyclingPower;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void DeviceInformationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::DeviceInformation;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void HumanInterfaceDeviceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::HumanInterfaceDevice;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ImmediateAlertGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::ImmediateAlert;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void LinkLossGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::LinkLoss;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void LocationAndNavigationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::LocationAndNavigation;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void NextDstChangeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::NextDstChange;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void PhoneAlertStatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::PhoneAlertStatus;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ReferenceTimeUpdateGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::ReferenceTimeUpdate;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void ScanParametersGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::ScanParameters;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    static void TxPowerGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::TxPower;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattServiceUuids(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^ UnwrapGattServiceUuids(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattServiceUuids::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattServiceUuids(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattServiceUuids::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids^ UnwrapGattServiceUuids(Local<Value> value) {
     return GattServiceUuids::Unwrap<GattServiceUuids>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattServiceUuids(Local<Object> exports) {
    GattServiceUuids::Init(exports);
  }

  class GattSession : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattSession").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "close", Close);
          


          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("maintainConnection").ToLocalChecked(), MaintainConnectionGetter, MaintainConnectionSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("canMaintainConnection").ToLocalChecked(), CanMaintainConnectionGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceId").ToLocalChecked(), DeviceIdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("maxPduSize").ToLocalChecked(), MaxPduSizeGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("sessionStatus").ToLocalChecked(), SessionStatusGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        func = Nan::GetFunction(Nan::New<FunctionTemplate>(FromDeviceIdAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("fromDeviceIdAsync").ToLocalChecked(), func);


        Nan::Set(exports, Nan::New<String>("GattSession").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattSession(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattSession *wrapperInstance = new GattSession(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattSession(winRtInstance));
    }



    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info.This())) {
        return;
      }

      GattSession *wrapper = GattSession::Unwrap<GattSession>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }


    static void FromDeviceIdAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>^ op;


      if (info.Length() == 2
          && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(info[0]))
      {
        try
        {
          ::Windows::Devices::Bluetooth::BluetoothDeviceId^ arg0 = dynamic_cast<::Windows::Devices::Bluetooth::BluetoothDeviceId^>(NodeRT::Utils::GetObjectInstance(info[0]));
            
          op = ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession::FromDeviceIdAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattSession(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void MaintainConnectionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info.This())) {
        return;
      }

      GattSession *wrapper = GattSession::Unwrap<GattSession>(info.This());

      try  {
        bool result = wrapper->_instance->MaintainConnection;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void MaintainConnectionSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsBoolean()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info.This())) {
        return;
      }

      GattSession *wrapper = GattSession::Unwrap<GattSession>(info.This());

      try {

        bool winRtValue = Nan::To<bool>(value).FromMaybe(false);

        wrapper->_instance->MaintainConnection = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void CanMaintainConnectionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info.This())) {
        return;
      }

      GattSession *wrapper = GattSession::Unwrap<GattSession>(info.This());

      try  {
        bool result = wrapper->_instance->CanMaintainConnection;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DeviceIdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info.This())) {
        return;
      }

      GattSession *wrapper = GattSession::Unwrap<GattSession>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothDeviceId^ result = wrapper->_instance->DeviceId;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Bluetooth", "BluetoothDeviceId", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void MaxPduSizeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info.This())) {
        return;
      }

      GattSession *wrapper = GattSession::Unwrap<GattSession>(info.This());

      try  {
        unsigned short result = wrapper->_instance->MaxPduSize;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SessionStatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info.This())) {
        return;
      }

      GattSession *wrapper = GattSession::Unwrap<GattSession>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatus result = wrapper->_instance->SessionStatus;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"maxPduSizeChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        GattSession *wrapper = GattSession::Unwrap<GattSession>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->MaxPduSizeChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapGattSession(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"sessionStatusChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        GattSession *wrapper = GattSession::Unwrap<GattSession>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->SessionStatusChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ arg0, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapGattSession(arg0);
                  wrappedArg1 = WrapGattSessionStatusChangedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"maxPduSizeChanged", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"sessionStatusChanged", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"maxPduSizeChanged", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          GattSession *wrapper = GattSession::Unwrap<GattSession>(info.This());
          wrapper->_instance->MaxPduSizeChanged::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"sessionStatusChanged", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          GattSession *wrapper = GattSession::Unwrap<GattSession>(info.This());
          wrapper->_instance->SessionStatusChanged::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattSession(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ UnwrapGattSession(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattSession::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattSession(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattSession::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ UnwrapGattSession(Local<Value> value) {
     return GattSession::Unwrap<GattSession>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattSession(Local<Object> exports) {
    GattSession::Init(exports);
  }

  class GattSessionStatusChangedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattSessionStatusChangedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("error").ToLocalChecked(), ErrorGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattSessionStatusChangedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattSessionStatusChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattSessionStatusChangedEventArgs *wrapperInstance = new GattSessionStatusChangedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattSessionStatusChangedEventArgs(winRtInstance));
    }





    static void ErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^>(info.This())) {
        return;
      }

      GattSessionStatusChangedEventArgs *wrapper = GattSessionStatusChangedEventArgs::Unwrap<GattSessionStatusChangedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::BluetoothError result = wrapper->_instance->Error;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^>(info.This())) {
        return;
      }

      GattSessionStatusChangedEventArgs *wrapper = GattSessionStatusChangedEventArgs::Unwrap<GattSessionStatusChangedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattSessionStatusChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^ UnwrapGattSessionStatusChangedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattSessionStatusChangedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattSessionStatusChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattSessionStatusChangedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs^ UnwrapGattSessionStatusChangedEventArgs(Local<Value> value) {
     return GattSessionStatusChangedEventArgs::Unwrap<GattSessionStatusChangedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattSessionStatusChangedEventArgs(Local<Object> exports) {
    GattSessionStatusChangedEventArgs::Init(exports);
  }

  class GattSubscribedClient : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattSubscribedClient").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);




          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("maxNotificationSize").ToLocalChecked(), MaxNotificationSizeGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("session").ToLocalChecked(), SessionGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattSubscribedClient").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattSubscribedClient(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattSubscribedClient *wrapperInstance = new GattSubscribedClient(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattSubscribedClient(winRtInstance));
    }





    static void MaxNotificationSizeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^>(info.This())) {
        return;
      }

      GattSubscribedClient *wrapper = GattSubscribedClient::Unwrap<GattSubscribedClient>(info.This());

      try  {
        unsigned short result = wrapper->_instance->MaxNotificationSize;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SessionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^>(info.This())) {
        return;
      }

      GattSubscribedClient *wrapper = GattSubscribedClient::Unwrap<GattSubscribedClient>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ result = wrapper->_instance->Session;
        info.GetReturnValue().Set(WrapGattSession(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"maxNotificationSizeChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        GattSubscribedClient *wrapper = GattSubscribedClient::Unwrap<GattSubscribedClient>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->MaxNotificationSizeChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapGattSubscribedClient(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"maxNotificationSizeChanged", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"maxNotificationSizeChanged", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          GattSubscribedClient *wrapper = GattSubscribedClient::Unwrap<GattSubscribedClient>(info.This());
          wrapper->_instance->MaxNotificationSizeChanged::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattSubscribedClient(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ UnwrapGattSubscribedClient(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattSubscribedClient::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattSubscribedClient(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattSubscribedClient::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient^ UnwrapGattSubscribedClient(Local<Value> value) {
     return GattSubscribedClient::Unwrap<GattSubscribedClient>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattSubscribedClient(Local<Object> exports) {
    GattSubscribedClient::Init(exports);
  }

  class GattValueChangedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattValueChangedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("characteristicValue").ToLocalChecked(), CharacteristicValueGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("timestamp").ToLocalChecked(), TimestampGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattValueChangedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattValueChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattValueChangedEventArgs *wrapperInstance = new GattValueChangedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattValueChangedEventArgs(winRtInstance));
    }





    static void CharacteristicValueGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^>(info.This())) {
        return;
      }

      GattValueChangedEventArgs *wrapper = GattValueChangedEventArgs::Unwrap<GattValueChangedEventArgs>(info.This());

      try  {
        ::Windows::Storage::Streams::IBuffer^ result = wrapper->_instance->CharacteristicValue;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void TimestampGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^>(info.This())) {
        return;
      }

      GattValueChangedEventArgs *wrapper = GattValueChangedEventArgs::Unwrap<GattValueChangedEventArgs>(info.This());

      try  {
        ::Windows::Foundation::DateTime result = wrapper->_instance->Timestamp;
        info.GetReturnValue().Set(NodeRT::Utils::DateTimeToJS(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattValueChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^ UnwrapGattValueChangedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattValueChangedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattValueChangedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattValueChangedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs^ UnwrapGattValueChangedEventArgs(Local<Value> value) {
     return GattValueChangedEventArgs::Unwrap<GattValueChangedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattValueChangedEventArgs(Local<Object> exports) {
    GattValueChangedEventArgs::Init(exports);
  }

  class GattWriteRequest : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattWriteRequest").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "respond", Respond);
            Nan::SetPrototypeMethod(localRef, "respondWithProtocolError", RespondWithProtocolError);
          


          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("offset").ToLocalChecked(), OffsetGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("option").ToLocalChecked(), OptionGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("state").ToLocalChecked(), StateGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("value").ToLocalChecked(), ValueGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattWriteRequest").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattWriteRequest(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattWriteRequest *wrapperInstance = new GattWriteRequest(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattWriteRequest(winRtInstance));
    }


    static void Respond(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^>(info.This())) {
        return;
      }

      GattWriteRequest *wrapper = GattWriteRequest::Unwrap<GattWriteRequest>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Respond();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void RespondWithProtocolError(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^>(info.This())) {
        return;
      }

      GattWriteRequest *wrapper = GattWriteRequest::Unwrap<GattWriteRequest>(info.This());

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned char arg0 = static_cast<unsigned char>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->RespondWithProtocolError(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void OffsetGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^>(info.This())) {
        return;
      }

      GattWriteRequest *wrapper = GattWriteRequest::Unwrap<GattWriteRequest>(info.This());

      try  {
        unsigned int result = wrapper->_instance->Offset;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void OptionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^>(info.This())) {
        return;
      }

      GattWriteRequest *wrapper = GattWriteRequest::Unwrap<GattWriteRequest>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteOption result = wrapper->_instance->Option;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StateGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^>(info.This())) {
        return;
      }

      GattWriteRequest *wrapper = GattWriteRequest::Unwrap<GattWriteRequest>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestState result = wrapper->_instance->State;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ValueGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^>(info.This())) {
        return;
      }

      GattWriteRequest *wrapper = GattWriteRequest::Unwrap<GattWriteRequest>(info.This());

      try  {
        ::Windows::Storage::Streams::IBuffer^ result = wrapper->_instance->Value;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"stateChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        GattWriteRequest *wrapper = GattWriteRequest::Unwrap<GattWriteRequest>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->StateChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^ arg0, ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapGattWriteRequest(arg0);
                  wrappedArg1 = WrapGattRequestStateChangedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"stateChanged", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"stateChanged", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          GattWriteRequest *wrapper = GattWriteRequest::Unwrap<GattWriteRequest>(info.This());
          wrapper->_instance->StateChanged::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattWriteRequest(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^ UnwrapGattWriteRequest(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattWriteRequest::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattWriteRequest(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattWriteRequest::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^ UnwrapGattWriteRequest(Local<Value> value) {
     return GattWriteRequest::Unwrap<GattWriteRequest>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattWriteRequest(Local<Object> exports) {
    GattWriteRequest::Init(exports);
  }

  class GattWriteRequestedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattWriteRequestedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "getDeferral", GetDeferral);
          

          
            Nan::SetPrototypeMethod(localRef, "getRequestAsync", GetRequestAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("session").ToLocalChecked(), SessionGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattWriteRequestedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattWriteRequestedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattWriteRequestedEventArgs *wrapperInstance = new GattWriteRequestedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattWriteRequestedEventArgs(winRtInstance));
    }

    static void GetRequestAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      GattWriteRequestedEventArgs *wrapper = GattWriteRequestedEventArgs::Unwrap<GattWriteRequestedEventArgs>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetRequestAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapGattWriteRequest(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void GetDeferral(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^>(info.This())) {
        return;
      }

      GattWriteRequestedEventArgs *wrapper = GattWriteRequestedEventArgs::Unwrap<GattWriteRequestedEventArgs>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Deferral^ result;
          result = wrapper->_instance->GetDeferral();
          info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation", "Deferral", result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void SessionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^>(info.This())) {
        return;
      }

      GattWriteRequestedEventArgs *wrapper = GattWriteRequestedEventArgs::Unwrap<GattWriteRequestedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession^ result = wrapper->_instance->Session;
        info.GetReturnValue().Set(WrapGattSession(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattWriteRequestedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^ UnwrapGattWriteRequestedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattWriteRequestedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattWriteRequestedEventArgs(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattWriteRequestedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs^ UnwrapGattWriteRequestedEventArgs(Local<Value> value) {
     return GattWriteRequestedEventArgs::Unwrap<GattWriteRequestedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattWriteRequestedEventArgs(Local<Object> exports) {
    GattWriteRequestedEventArgs::Init(exports);
  }

  class GattWriteResult : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GattWriteResult").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("protocolError").ToLocalChecked(), ProtocolErrorGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("GattWriteResult").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GattWriteResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GattWriteResult *wrapperInstance = new GattWriteResult(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGattWriteResult(winRtInstance));
    }





    static void ProtocolErrorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^>(info.This())) {
        return;
      }

      GattWriteResult *wrapper = GattWriteResult::Unwrap<GattWriteResult>(info.This());

      try  {
        ::Platform::IBox<unsigned char>^ result = wrapper->_instance->ProtocolError;
        info.GetReturnValue().Set(result ? static_cast<Local<Value>>(Nan::New<Integer>(result->Value)) : Undefined());
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^>(info.This())) {
        return;
      }

      GattWriteResult *wrapper = GattWriteResult::Unwrap<GattWriteResult>(info.This());

      try  {
        ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGattWriteResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^ wintRtInstance);
      friend ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^ UnwrapGattWriteResult(Local<Value> value);
  };

  Persistent<FunctionTemplate> GattWriteResult::s_constructorTemplate;

  v8::Local<v8::Value> WrapGattWriteResult(::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GattWriteResult::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult^ UnwrapGattWriteResult(Local<Value> value) {
     return GattWriteResult::Unwrap<GattWriteResult>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGattWriteResult(Local<Object> exports) {
    GattWriteResult::Init(exports);
  }

} } } } }


namespace NodeRT { namespace Windows { namespace Devices { namespace Enumeration { 
  v8::Local<v8::Value> WrapDeviceAccessChangedEventArgs(::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^ UnwrapDeviceAccessChangedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceAccessInformation(::Windows::Devices::Enumeration::DeviceAccessInformation^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceAccessInformation^ UnwrapDeviceAccessInformation(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceConnectionChangeTriggerDetails(::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^ UnwrapDeviceConnectionChangeTriggerDetails(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceDisconnectButtonClickedEventArgs(::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^ UnwrapDeviceDisconnectButtonClickedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceInformation(::Windows::Devices::Enumeration::DeviceInformation^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceInformation^ UnwrapDeviceInformation(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceInformationCollection(::Windows::Devices::Enumeration::DeviceInformationCollection^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceInformationCollection^ UnwrapDeviceInformationCollection(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceInformationCustomPairing(::Windows::Devices::Enumeration::DeviceInformationCustomPairing^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceInformationCustomPairing^ UnwrapDeviceInformationCustomPairing(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceInformationPairing(::Windows::Devices::Enumeration::DeviceInformationPairing^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceInformationPairing^ UnwrapDeviceInformationPairing(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceInformationUpdate(::Windows::Devices::Enumeration::DeviceInformationUpdate^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceInformationUpdate^ UnwrapDeviceInformationUpdate(Local<Value> value);
  
  v8::Local<v8::Value> WrapDevicePairingRequestedEventArgs(::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^ wintRtInstance);
  ::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^ UnwrapDevicePairingRequestedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapDevicePairingResult(::Windows::Devices::Enumeration::DevicePairingResult^ wintRtInstance);
  ::Windows::Devices::Enumeration::DevicePairingResult^ UnwrapDevicePairingResult(Local<Value> value);
  
  v8::Local<v8::Value> WrapDevicePicker(::Windows::Devices::Enumeration::DevicePicker^ wintRtInstance);
  ::Windows::Devices::Enumeration::DevicePicker^ UnwrapDevicePicker(Local<Value> value);
  
  v8::Local<v8::Value> WrapDevicePickerAppearance(::Windows::Devices::Enumeration::DevicePickerAppearance^ wintRtInstance);
  ::Windows::Devices::Enumeration::DevicePickerAppearance^ UnwrapDevicePickerAppearance(Local<Value> value);
  
  v8::Local<v8::Value> WrapDevicePickerFilter(::Windows::Devices::Enumeration::DevicePickerFilter^ wintRtInstance);
  ::Windows::Devices::Enumeration::DevicePickerFilter^ UnwrapDevicePickerFilter(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceSelectedEventArgs(::Windows::Devices::Enumeration::DeviceSelectedEventArgs^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceSelectedEventArgs^ UnwrapDeviceSelectedEventArgs(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceThumbnail(::Windows::Devices::Enumeration::DeviceThumbnail^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceThumbnail^ UnwrapDeviceThumbnail(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceUnpairingResult(::Windows::Devices::Enumeration::DeviceUnpairingResult^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceUnpairingResult^ UnwrapDeviceUnpairingResult(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceWatcher(::Windows::Devices::Enumeration::DeviceWatcher^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceWatcher^ UnwrapDeviceWatcher(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceWatcherEvent(::Windows::Devices::Enumeration::DeviceWatcherEvent^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceWatcherEvent^ UnwrapDeviceWatcherEvent(Local<Value> value);
  
  v8::Local<v8::Value> WrapDeviceWatcherTriggerDetails(::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^ wintRtInstance);
  ::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^ UnwrapDeviceWatcherTriggerDetails(Local<Value> value);
  
  v8::Local<v8::Value> WrapEnclosureLocation(::Windows::Devices::Enumeration::EnclosureLocation^ wintRtInstance);
  ::Windows::Devices::Enumeration::EnclosureLocation^ UnwrapEnclosureLocation(Local<Value> value);
  
  v8::Local<v8::Value> WrapIDevicePairingSettings(::Windows::Devices::Enumeration::IDevicePairingSettings^ wintRtInstance);
  ::Windows::Devices::Enumeration::IDevicePairingSettings^ UnwrapIDevicePairingSettings(Local<Value> value);
  



  static void InitDeviceAccessStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("DeviceAccessStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("unspecified").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceAccessStatus::Unspecified)));
    Nan::Set(enumObject, Nan::New<String>("allowed").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceAccessStatus::Allowed)));
    Nan::Set(enumObject, Nan::New<String>("deniedByUser").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceAccessStatus::DeniedByUser)));
    Nan::Set(enumObject, Nan::New<String>("deniedBySystem").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceAccessStatus::DeniedBySystem)));
  }

  static void InitDeviceClassEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("DeviceClass").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("all").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceClass::All)));
    Nan::Set(enumObject, Nan::New<String>("audioCapture").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceClass::AudioCapture)));
    Nan::Set(enumObject, Nan::New<String>("audioRender").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceClass::AudioRender)));
    Nan::Set(enumObject, Nan::New<String>("portableStorageDevice").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceClass::PortableStorageDevice)));
    Nan::Set(enumObject, Nan::New<String>("videoCapture").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceClass::VideoCapture)));
    Nan::Set(enumObject, Nan::New<String>("imageScanner").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceClass::ImageScanner)));
    Nan::Set(enumObject, Nan::New<String>("location").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceClass::Location)));
  }

  static void InitDeviceInformationKindEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("DeviceInformationKind").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("unknown").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceInformationKind::Unknown)));
    Nan::Set(enumObject, Nan::New<String>("deviceInterface").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceInformationKind::DeviceInterface)));
    Nan::Set(enumObject, Nan::New<String>("deviceContainer").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceInformationKind::DeviceContainer)));
    Nan::Set(enumObject, Nan::New<String>("device").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceInformationKind::Device)));
    Nan::Set(enumObject, Nan::New<String>("deviceInterfaceClass").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceInformationKind::DeviceInterfaceClass)));
    Nan::Set(enumObject, Nan::New<String>("associationEndpoint").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceInformationKind::AssociationEndpoint)));
    Nan::Set(enumObject, Nan::New<String>("associationEndpointContainer").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceInformationKind::AssociationEndpointContainer)));
    Nan::Set(enumObject, Nan::New<String>("associationEndpointService").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceInformationKind::AssociationEndpointService)));
    Nan::Set(enumObject, Nan::New<String>("devicePanel").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceInformationKind::DevicePanel)));
  }

  static void InitDevicePairingKindsEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("DevicePairingKinds").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("none").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingKinds::None)));
    Nan::Set(enumObject, Nan::New<String>("confirmOnly").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingKinds::ConfirmOnly)));
    Nan::Set(enumObject, Nan::New<String>("displayPin").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingKinds::DisplayPin)));
    Nan::Set(enumObject, Nan::New<String>("providePin").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingKinds::ProvidePin)));
    Nan::Set(enumObject, Nan::New<String>("confirmPinMatch").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingKinds::ConfirmPinMatch)));
    Nan::Set(enumObject, Nan::New<String>("providePasswordCredential").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingKinds::ProvidePasswordCredential)));
  }

  static void InitDevicePairingProtectionLevelEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("DevicePairingProtectionLevel").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("default").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingProtectionLevel::Default)));
    Nan::Set(enumObject, Nan::New<String>("none").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingProtectionLevel::None)));
    Nan::Set(enumObject, Nan::New<String>("encryption").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingProtectionLevel::Encryption)));
    Nan::Set(enumObject, Nan::New<String>("encryptionAndAuthentication").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingProtectionLevel::EncryptionAndAuthentication)));
  }

  static void InitDevicePairingResultStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("DevicePairingResultStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("paired").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::Paired)));
    Nan::Set(enumObject, Nan::New<String>("notReadyToPair").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::NotReadyToPair)));
    Nan::Set(enumObject, Nan::New<String>("notPaired").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::NotPaired)));
    Nan::Set(enumObject, Nan::New<String>("alreadyPaired").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::AlreadyPaired)));
    Nan::Set(enumObject, Nan::New<String>("connectionRejected").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::ConnectionRejected)));
    Nan::Set(enumObject, Nan::New<String>("tooManyConnections").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::TooManyConnections)));
    Nan::Set(enumObject, Nan::New<String>("hardwareFailure").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::HardwareFailure)));
    Nan::Set(enumObject, Nan::New<String>("authenticationTimeout").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::AuthenticationTimeout)));
    Nan::Set(enumObject, Nan::New<String>("authenticationNotAllowed").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::AuthenticationNotAllowed)));
    Nan::Set(enumObject, Nan::New<String>("authenticationFailure").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::AuthenticationFailure)));
    Nan::Set(enumObject, Nan::New<String>("noSupportedProfiles").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::NoSupportedProfiles)));
    Nan::Set(enumObject, Nan::New<String>("protectionLevelCouldNotBeMet").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::ProtectionLevelCouldNotBeMet)));
    Nan::Set(enumObject, Nan::New<String>("accessDenied").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::AccessDenied)));
    Nan::Set(enumObject, Nan::New<String>("invalidCeremonyData").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::InvalidCeremonyData)));
    Nan::Set(enumObject, Nan::New<String>("pairingCanceled").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::PairingCanceled)));
    Nan::Set(enumObject, Nan::New<String>("operationAlreadyInProgress").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::OperationAlreadyInProgress)));
    Nan::Set(enumObject, Nan::New<String>("requiredHandlerNotRegistered").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::RequiredHandlerNotRegistered)));
    Nan::Set(enumObject, Nan::New<String>("rejectedByHandler").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::RejectedByHandler)));
    Nan::Set(enumObject, Nan::New<String>("remoteDeviceHasAssociation").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::RemoteDeviceHasAssociation)));
    Nan::Set(enumObject, Nan::New<String>("failed").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePairingResultStatus::Failed)));
  }

  static void InitDevicePickerDisplayStatusOptionsEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("DevicePickerDisplayStatusOptions").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("none").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePickerDisplayStatusOptions::None)));
    Nan::Set(enumObject, Nan::New<String>("showProgress").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePickerDisplayStatusOptions::ShowProgress)));
    Nan::Set(enumObject, Nan::New<String>("showDisconnectButton").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePickerDisplayStatusOptions::ShowDisconnectButton)));
    Nan::Set(enumObject, Nan::New<String>("showRetryButton").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DevicePickerDisplayStatusOptions::ShowRetryButton)));
  }

  static void InitDeviceUnpairingResultStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("DeviceUnpairingResultStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("unpaired").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceUnpairingResultStatus::Unpaired)));
    Nan::Set(enumObject, Nan::New<String>("alreadyUnpaired").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceUnpairingResultStatus::AlreadyUnpaired)));
    Nan::Set(enumObject, Nan::New<String>("operationAlreadyInProgress").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceUnpairingResultStatus::OperationAlreadyInProgress)));
    Nan::Set(enumObject, Nan::New<String>("accessDenied").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceUnpairingResultStatus::AccessDenied)));
    Nan::Set(enumObject, Nan::New<String>("failed").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceUnpairingResultStatus::Failed)));
  }

  static void InitDeviceWatcherEventKindEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("DeviceWatcherEventKind").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("add").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceWatcherEventKind::Add)));
    Nan::Set(enumObject, Nan::New<String>("update").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceWatcherEventKind::Update)));
    Nan::Set(enumObject, Nan::New<String>("remove").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceWatcherEventKind::Remove)));
  }

  static void InitDeviceWatcherStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("DeviceWatcherStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("created").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceWatcherStatus::Created)));
    Nan::Set(enumObject, Nan::New<String>("started").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceWatcherStatus::Started)));
    Nan::Set(enumObject, Nan::New<String>("enumerationCompleted").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceWatcherStatus::EnumerationCompleted)));
    Nan::Set(enumObject, Nan::New<String>("stopping").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceWatcherStatus::Stopping)));
    Nan::Set(enumObject, Nan::New<String>("stopped").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceWatcherStatus::Stopped)));
    Nan::Set(enumObject, Nan::New<String>("aborted").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::DeviceWatcherStatus::Aborted)));
  }

  static void InitPanelEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("Panel").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("unknown").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::Panel::Unknown)));
    Nan::Set(enumObject, Nan::New<String>("front").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::Panel::Front)));
    Nan::Set(enumObject, Nan::New<String>("back").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::Panel::Back)));
    Nan::Set(enumObject, Nan::New<String>("top").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::Panel::Top)));
    Nan::Set(enumObject, Nan::New<String>("bottom").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::Panel::Bottom)));
    Nan::Set(enumObject, Nan::New<String>("left").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::Panel::Left)));
    Nan::Set(enumObject, Nan::New<String>("right").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Enumeration::Panel::Right)));
  }


  static bool IsRectJsObject(Local<Value> value) {
    if (!value->IsObject()) {
      return false;
    }

    Local<String> symbol;
    Local<Object> obj = Nan::To<Object>(value).ToLocalChecked();

    return true;
  }

  ::Windows::Foundation::Rect RectFromJsObject(Local<Value> value) {
    HandleScope scope;
    ::Windows::Foundation::Rect returnValue;

    if (!value->IsObject()) {
      Nan::ThrowError(Nan::TypeError(NodeRT::Utils::NewString(L"Unexpected type, expected an object")));
      return returnValue;
    }

    Local<Object> obj = Nan::To<Object>(value).ToLocalChecked();
    Local<String> symbol;

    return returnValue;
  }

  Local<Value> RectToJsObject(::Windows::Foundation::Rect value) {
    EscapableHandleScope scope;

    Local<Object> obj = Nan::New<Object>();


    return scope.Escape(obj);
  }
  static bool IsColorJsObject(Local<Value> value) {
    if (!value->IsObject()) {
      return false;
    }

    Local<String> symbol;
    Local<Object> obj = Nan::To<Object>(value).ToLocalChecked();

    return true;
  }

  ::Windows::UI::Color ColorFromJsObject(Local<Value> value) {
    HandleScope scope;
    ::Windows::UI::Color returnValue;

    if (!value->IsObject()) {
      Nan::ThrowError(Nan::TypeError(NodeRT::Utils::NewString(L"Unexpected type, expected an object")));
      return returnValue;
    }

    Local<Object> obj = Nan::To<Object>(value).ToLocalChecked();
    Local<String> symbol;

    return returnValue;
  }

  Local<Value> ColorToJsObject(::Windows::UI::Color value) {
    EscapableHandleScope scope;

    Local<Object> obj = Nan::New<Object>();


    return scope.Escape(obj);
  }

  class DeviceAccessChangedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceAccessChangedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("id").ToLocalChecked(), IdGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DeviceAccessChangedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceAccessChangedEventArgs(::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceAccessChangedEventArgs *wrapperInstance = new DeviceAccessChangedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceAccessChangedEventArgs(winRtInstance));
    }





    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^>(info.This())) {
        return;
      }

      DeviceAccessChangedEventArgs *wrapper = DeviceAccessChangedEventArgs::Unwrap<DeviceAccessChangedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceAccessStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^>(info.This())) {
        return;
      }

      DeviceAccessChangedEventArgs *wrapper = DeviceAccessChangedEventArgs::Unwrap<DeviceAccessChangedEventArgs>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Id;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceAccessChangedEventArgs(::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^ UnwrapDeviceAccessChangedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceAccessChangedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceAccessChangedEventArgs(::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceAccessChangedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^ UnwrapDeviceAccessChangedEventArgs(Local<Value> value) {
     return DeviceAccessChangedEventArgs::Unwrap<DeviceAccessChangedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceAccessChangedEventArgs(Local<Object> exports) {
    DeviceAccessChangedEventArgs::Init(exports);
  }

  class DeviceAccessInformation : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceAccessInformation").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);




          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("currentStatus").ToLocalChecked(), CurrentStatusGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "createFromId", CreateFromId);
        Nan::SetMethod(constructor, "createFromDeviceClassId", CreateFromDeviceClassId);
        Nan::SetMethod(constructor, "createFromDeviceClass", CreateFromDeviceClass);


        Nan::Set(exports, Nan::New<String>("DeviceAccessInformation").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceAccessInformation(::Windows::Devices::Enumeration::DeviceAccessInformation^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceAccessInformation^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceAccessInformation^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceAccessInformation^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceAccessInformation *wrapperInstance = new DeviceAccessInformation(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceAccessInformation^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceAccessInformation^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceAccessInformation^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceAccessInformation(winRtInstance));
    }





    static void CreateFromId(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          ::Windows::Devices::Enumeration::DeviceAccessInformation^ result;
          result = ::Windows::Devices::Enumeration::DeviceAccessInformation::CreateFromId(arg0);
          info.GetReturnValue().Set(WrapDeviceAccessInformation(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateFromDeviceClassId(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          ::Windows::Devices::Enumeration::DeviceAccessInformation^ result;
          result = ::Windows::Devices::Enumeration::DeviceAccessInformation::CreateFromDeviceClassId(arg0);
          info.GetReturnValue().Set(WrapDeviceAccessInformation(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateFromDeviceClass(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Enumeration::DeviceClass arg0 = static_cast<::Windows::Devices::Enumeration::DeviceClass>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          ::Windows::Devices::Enumeration::DeviceAccessInformation^ result;
          result = ::Windows::Devices::Enumeration::DeviceAccessInformation::CreateFromDeviceClass(arg0);
          info.GetReturnValue().Set(WrapDeviceAccessInformation(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CurrentStatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceAccessInformation^>(info.This())) {
        return;
      }

      DeviceAccessInformation *wrapper = DeviceAccessInformation::Unwrap<DeviceAccessInformation>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceAccessStatus result = wrapper->_instance->CurrentStatus;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"accessChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceAccessInformation^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        DeviceAccessInformation *wrapper = DeviceAccessInformation::Unwrap<DeviceAccessInformation>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->AccessChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Enumeration::DeviceAccessInformation^, ::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Enumeration::DeviceAccessInformation^ arg0, ::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapDeviceAccessInformation(arg0);
                  wrappedArg1 = WrapDeviceAccessChangedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"accessChanged", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"accessChanged", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceAccessInformation^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          DeviceAccessInformation *wrapper = DeviceAccessInformation::Unwrap<DeviceAccessInformation>(info.This());
          wrapper->_instance->AccessChanged::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Enumeration::DeviceAccessInformation^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceAccessInformation(::Windows::Devices::Enumeration::DeviceAccessInformation^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceAccessInformation^ UnwrapDeviceAccessInformation(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceAccessInformation::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceAccessInformation(::Windows::Devices::Enumeration::DeviceAccessInformation^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceAccessInformation::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceAccessInformation^ UnwrapDeviceAccessInformation(Local<Value> value) {
     return DeviceAccessInformation::Unwrap<DeviceAccessInformation>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceAccessInformation(Local<Object> exports) {
    DeviceAccessInformation::Init(exports);
  }

  class DeviceConnectionChangeTriggerDetails : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceConnectionChangeTriggerDetails").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceId").ToLocalChecked(), DeviceIdGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DeviceConnectionChangeTriggerDetails").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceConnectionChangeTriggerDetails(::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceConnectionChangeTriggerDetails *wrapperInstance = new DeviceConnectionChangeTriggerDetails(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceConnectionChangeTriggerDetails(winRtInstance));
    }





    static void DeviceIdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^>(info.This())) {
        return;
      }

      DeviceConnectionChangeTriggerDetails *wrapper = DeviceConnectionChangeTriggerDetails::Unwrap<DeviceConnectionChangeTriggerDetails>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->DeviceId;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceConnectionChangeTriggerDetails(::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^ UnwrapDeviceConnectionChangeTriggerDetails(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceConnectionChangeTriggerDetails::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceConnectionChangeTriggerDetails(::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceConnectionChangeTriggerDetails::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails^ UnwrapDeviceConnectionChangeTriggerDetails(Local<Value> value) {
     return DeviceConnectionChangeTriggerDetails::Unwrap<DeviceConnectionChangeTriggerDetails>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceConnectionChangeTriggerDetails(Local<Object> exports) {
    DeviceConnectionChangeTriggerDetails::Init(exports);
  }

  class DeviceDisconnectButtonClickedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceDisconnectButtonClickedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("device").ToLocalChecked(), DeviceGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DeviceDisconnectButtonClickedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceDisconnectButtonClickedEventArgs(::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceDisconnectButtonClickedEventArgs *wrapperInstance = new DeviceDisconnectButtonClickedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceDisconnectButtonClickedEventArgs(winRtInstance));
    }





    static void DeviceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^>(info.This())) {
        return;
      }

      DeviceDisconnectButtonClickedEventArgs *wrapper = DeviceDisconnectButtonClickedEventArgs::Unwrap<DeviceDisconnectButtonClickedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceInformation^ result = wrapper->_instance->Device;
        info.GetReturnValue().Set(WrapDeviceInformation(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceDisconnectButtonClickedEventArgs(::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^ UnwrapDeviceDisconnectButtonClickedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceDisconnectButtonClickedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceDisconnectButtonClickedEventArgs(::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceDisconnectButtonClickedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^ UnwrapDeviceDisconnectButtonClickedEventArgs(Local<Value> value) {
     return DeviceDisconnectButtonClickedEventArgs::Unwrap<DeviceDisconnectButtonClickedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceDisconnectButtonClickedEventArgs(Local<Object> exports) {
    DeviceDisconnectButtonClickedEventArgs::Init(exports);
  }

  class DeviceInformation : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceInformation").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "update", Update);
          

          
            Nan::SetPrototypeMethod(localRef, "getThumbnailAsync", GetThumbnailAsync);
            Nan::SetPrototypeMethod(localRef, "getGlyphThumbnailAsync", GetGlyphThumbnailAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("enclosureLocation").ToLocalChecked(), EnclosureLocationGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("id").ToLocalChecked(), IdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isDefault").ToLocalChecked(), IsDefaultGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isEnabled").ToLocalChecked(), IsEnabledGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("name").ToLocalChecked(), NameGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("properties").ToLocalChecked(), PropertiesGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("kind").ToLocalChecked(), KindGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("pairing").ToLocalChecked(), PairingGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "getAqsFilterFromDeviceClass", GetAqsFilterFromDeviceClass);
        Nan::SetMethod(constructor, "createWatcher", CreateWatcher);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(CreateFromIdAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("createFromIdAsync").ToLocalChecked(), func);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(FindAllAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("findAllAsync").ToLocalChecked(), func);


        Nan::Set(exports, Nan::New<String>("DeviceInformation").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceInformation(::Windows::Devices::Enumeration::DeviceInformation^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceInformation^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceInformation^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceInformation *wrapperInstance = new DeviceInformation(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceInformation^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceInformation^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceInformation(winRtInstance));
    }

    static void GetThumbnailAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      DeviceInformation *wrapper = DeviceInformation::Unwrap<DeviceInformation>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Enumeration::DeviceThumbnail^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetThumbnailAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Enumeration::DeviceThumbnail^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapDeviceThumbnail(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void GetGlyphThumbnailAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      DeviceInformation *wrapper = DeviceInformation::Unwrap<DeviceInformation>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Enumeration::DeviceThumbnail^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetGlyphThumbnailAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Enumeration::DeviceThumbnail^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapDeviceThumbnail(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void Update(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info.This())) {
        return;
      }

      DeviceInformation *wrapper = DeviceInformation::Unwrap<DeviceInformation>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationUpdate^>(info[0]))
      {
        try
        {
          ::Windows::Devices::Enumeration::DeviceInformationUpdate^ arg0 = UnwrapDeviceInformationUpdate(info[0]);
          
          wrapper->_instance->Update(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }


    static void CreateFromIdAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Enumeration::DeviceInformation^>^ op;


      if (info.Length() == 4
          && info[0]->IsString()
          && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(info[1]) || info[1]->IsArray())
          && info[2]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Local<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Local<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[1]);
          ::Windows::Devices::Enumeration::DeviceInformationKind arg2 = static_cast<::Windows::Devices::Enumeration::DeviceInformationKind>(Nan::To<int32_t>(info[2]).FromMaybe(0));
            
          op = ::Windows::Devices::Enumeration::DeviceInformation::CreateFromIdAsync(arg0,arg1,arg2);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 2
          && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
            
          op = ::Windows::Devices::Enumeration::DeviceInformation::CreateFromIdAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 3
          && info[0]->IsString()
          && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(info[1]) || info[1]->IsArray()))
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Local<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Local<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[1]);
            
          op = ::Windows::Devices::Enumeration::DeviceInformation::CreateFromIdAsync(arg0,arg1);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Enumeration::DeviceInformation^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapDeviceInformation(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void FindAllAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Enumeration::DeviceInformationCollection^>^ op;


      if (info.Length() == 4
          && info[0]->IsString()
          && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(info[1]) || info[1]->IsArray())
          && info[2]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Local<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Local<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[1]);
          ::Windows::Devices::Enumeration::DeviceInformationKind arg2 = static_cast<::Windows::Devices::Enumeration::DeviceInformationKind>(Nan::To<int32_t>(info[2]).FromMaybe(0));
            
          op = ::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(arg0,arg1,arg2);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 1)
      {
        try
        {
          op = ::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync();
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 2
          && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Enumeration::DeviceClass arg0 = static_cast<::Windows::Devices::Enumeration::DeviceClass>(Nan::To<int32_t>(info[0]).FromMaybe(0));
            
          op = ::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 2
          && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
            
          op = ::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 3
          && info[0]->IsString()
          && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(info[1]) || info[1]->IsArray()))
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Local<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Local<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[1]);
            
          op = ::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(arg0,arg1);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Enumeration::DeviceInformationCollection^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapDeviceInformationCollection(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void GetAqsFilterFromDeviceClass(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Enumeration::DeviceClass arg0 = static_cast<::Windows::Devices::Enumeration::DeviceClass>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          Platform::String^ result;
          result = ::Windows::Devices::Enumeration::DeviceInformation::GetAqsFilterFromDeviceClass(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateWatcher(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 3
        && info[0]->IsString()
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(info[1]) || info[1]->IsArray())
        && info[2]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Local<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Local<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[1]);
          ::Windows::Devices::Enumeration::DeviceInformationKind arg2 = static_cast<::Windows::Devices::Enumeration::DeviceInformationKind>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          
          ::Windows::Devices::Enumeration::DeviceWatcher^ result;
          result = ::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(arg0, arg1, arg2);
          info.GetReturnValue().Set(WrapDeviceWatcher(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try
        {
          ::Windows::Devices::Enumeration::DeviceWatcher^ result;
          result = ::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher();
          info.GetReturnValue().Set(WrapDeviceWatcher(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Enumeration::DeviceClass arg0 = static_cast<::Windows::Devices::Enumeration::DeviceClass>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          ::Windows::Devices::Enumeration::DeviceWatcher^ result;
          result = ::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(arg0);
          info.GetReturnValue().Set(WrapDeviceWatcher(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          ::Windows::Devices::Enumeration::DeviceWatcher^ result;
          result = ::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(arg0);
          info.GetReturnValue().Set(WrapDeviceWatcher(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsString()
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(info[1]) || info[1]->IsArray()))
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Local<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Local<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[1]);
          
          ::Windows::Devices::Enumeration::DeviceWatcher^ result;
          result = ::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(arg0, arg1);
          info.GetReturnValue().Set(WrapDeviceWatcher(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void EnclosureLocationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info.This())) {
        return;
      }

      DeviceInformation *wrapper = DeviceInformation::Unwrap<DeviceInformation>(info.This());

      try  {
        ::Windows::Devices::Enumeration::EnclosureLocation^ result = wrapper->_instance->EnclosureLocation;
        info.GetReturnValue().Set(WrapEnclosureLocation(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info.This())) {
        return;
      }

      DeviceInformation *wrapper = DeviceInformation::Unwrap<DeviceInformation>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Id;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsDefaultGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info.This())) {
        return;
      }

      DeviceInformation *wrapper = DeviceInformation::Unwrap<DeviceInformation>(info.This());

      try  {
        bool result = wrapper->_instance->IsDefault;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsEnabledGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info.This())) {
        return;
      }

      DeviceInformation *wrapper = DeviceInformation::Unwrap<DeviceInformation>(info.This());

      try  {
        bool result = wrapper->_instance->IsEnabled;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void NameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info.This())) {
        return;
      }

      DeviceInformation *wrapper = DeviceInformation::Unwrap<DeviceInformation>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Name;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PropertiesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info.This())) {
        return;
      }

      DeviceInformation *wrapper = DeviceInformation::Unwrap<DeviceInformation>(info.This());

      try  {
        ::Windows::Foundation::Collections::IMapView<::Platform::String^, ::Platform::Object^>^ result = wrapper->_instance->Properties;
        info.GetReturnValue().Set(NodeRT::Collections::MapViewWrapper<::Platform::String^,::Platform::Object^>::CreateMapViewWrapper(result, 
            [](::Platform::String^ val) -> Local<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Local<Value> value) -> bool {
              return value->IsString();
            },
            [](Local<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));
            },
            [](::Platform::Object^ val) -> Local<Value> {
              return CreateOpaqueWrapper(val);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void KindGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info.This())) {
        return;
      }

      DeviceInformation *wrapper = DeviceInformation::Unwrap<DeviceInformation>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceInformationKind result = wrapper->_instance->Kind;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PairingGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info.This())) {
        return;
      }

      DeviceInformation *wrapper = DeviceInformation::Unwrap<DeviceInformation>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceInformationPairing^ result = wrapper->_instance->Pairing;
        info.GetReturnValue().Set(WrapDeviceInformationPairing(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DeviceInformation^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceInformation(::Windows::Devices::Enumeration::DeviceInformation^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceInformation^ UnwrapDeviceInformation(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceInformation::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceInformation(::Windows::Devices::Enumeration::DeviceInformation^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceInformation::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceInformation^ UnwrapDeviceInformation(Local<Value> value) {
     return DeviceInformation::Unwrap<DeviceInformation>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceInformation(Local<Object> exports) {
    DeviceInformation::Init(exports);
  }

  class DeviceInformationCollection : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceInformationCollection").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "getAt", GetAt);
            Nan::SetPrototypeMethod(localRef, "indexOf", IndexOf);
            Nan::SetPrototypeMethod(localRef, "getMany", GetMany);
            Nan::SetPrototypeMethod(localRef, "first", First);
          




        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DeviceInformationCollection").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceInformationCollection(::Windows::Devices::Enumeration::DeviceInformationCollection^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceInformationCollection^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationCollection^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceInformationCollection^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceInformationCollection *wrapperInstance = new DeviceInformationCollection(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationCollection^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceInformationCollection^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceInformationCollection^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceInformationCollection(winRtInstance));
    }


    static void GetAt(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationCollection^>(info.This())) {
        return;
      }

      DeviceInformationCollection *wrapper = DeviceInformationCollection::Unwrap<DeviceInformationCollection>(info.This());

      if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          ::Windows::Devices::Enumeration::DeviceInformation^ result;
          result = wrapper->_instance->GetAt(arg0);
          info.GetReturnValue().Set(WrapDeviceInformation(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void IndexOf(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationCollection^>(info.This())) {
        return;
      }

      DeviceInformationCollection *wrapper = DeviceInformationCollection::Unwrap<DeviceInformationCollection>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info[0]))
      {
        try
        {
          ::Windows::Devices::Enumeration::DeviceInformation^ arg0 = UnwrapDeviceInformation(info[0]);
          unsigned int arg1;
          
          bool result;
          result = wrapper->_instance->IndexOf(arg0, &arg1);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("boolean").ToLocalChecked(), Nan::New<Boolean>(result));
          Nan::Set(resObj, Nan::New<String>("index").ToLocalChecked(), Nan::New<Integer>(arg1));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetMany(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Not implemented")));
    }
    static void First(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationCollection^>(info.This())) {
        return;
      }

      DeviceInformationCollection *wrapper = DeviceInformationCollection::Unwrap<DeviceInformationCollection>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Collections::IIterator<::Windows::Devices::Enumeration::DeviceInformation^>^ result;
          result = wrapper->_instance->First();
          info.GetReturnValue().Set(NodeRT::Collections::IteratorWrapper<::Windows::Devices::Enumeration::DeviceInformation^>::CreateIteratorWrapper(result, 
            [](::Windows::Devices::Enumeration::DeviceInformation^ val) -> Local<Value> {
              return WrapDeviceInformation(val);
            }
          ));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }





    private:
      ::Windows::Devices::Enumeration::DeviceInformationCollection^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceInformationCollection(::Windows::Devices::Enumeration::DeviceInformationCollection^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceInformationCollection^ UnwrapDeviceInformationCollection(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceInformationCollection::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceInformationCollection(::Windows::Devices::Enumeration::DeviceInformationCollection^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceInformationCollection::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceInformationCollection^ UnwrapDeviceInformationCollection(Local<Value> value) {
     return DeviceInformationCollection::Unwrap<DeviceInformationCollection>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceInformationCollection(Local<Object> exports) {
    DeviceInformationCollection::Init(exports);
  }

  class DeviceInformationCustomPairing : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceInformationCustomPairing").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;


          
            Nan::SetPrototypeMethod(localRef, "pairAsync", PairAsync);
          

          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);


        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DeviceInformationCustomPairing").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceInformationCustomPairing(::Windows::Devices::Enumeration::DeviceInformationCustomPairing^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceInformationCustomPairing^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationCustomPairing^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceInformationCustomPairing^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceInformationCustomPairing *wrapperInstance = new DeviceInformationCustomPairing(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationCustomPairing^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceInformationCustomPairing^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceInformationCustomPairing^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceInformationCustomPairing(winRtInstance));
    }

    static void PairAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationCustomPairing^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      DeviceInformationCustomPairing *wrapper = DeviceInformationCustomPairing::Unwrap<DeviceInformationCustomPairing>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Enumeration::DevicePairingResult^>^ op;


      if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Enumeration::DevicePairingKinds arg0 = static_cast<::Windows::Devices::Enumeration::DevicePairingKinds>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->PairAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && info[0]->IsInt32()
        && info[1]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Enumeration::DevicePairingKinds arg0 = static_cast<::Windows::Devices::Enumeration::DevicePairingKinds>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          ::Windows::Devices::Enumeration::DevicePairingProtectionLevel arg1 = static_cast<::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          op = wrapper->_instance->PairAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 4
        && info[0]->IsInt32()
        && info[1]->IsInt32()
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::IDevicePairingSettings^>(info[2]))
      {
        try
        {
          ::Windows::Devices::Enumeration::DevicePairingKinds arg0 = static_cast<::Windows::Devices::Enumeration::DevicePairingKinds>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          ::Windows::Devices::Enumeration::DevicePairingProtectionLevel arg1 = static_cast<::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          ::Windows::Devices::Enumeration::IDevicePairingSettings^ arg2 = UnwrapIDevicePairingSettings(info[2]);
          
          op = wrapper->_instance->PairAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Enumeration::DevicePairingResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapDevicePairingResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }






    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"pairingRequested", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationCustomPairing^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        DeviceInformationCustomPairing *wrapper = DeviceInformationCustomPairing::Unwrap<DeviceInformationCustomPairing>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->PairingRequested::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Enumeration::DeviceInformationCustomPairing^, ::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Enumeration::DeviceInformationCustomPairing^ arg0, ::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapDeviceInformationCustomPairing(arg0);
                  wrappedArg1 = WrapDevicePairingRequestedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"pairingRequested", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"pairingRequested", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationCustomPairing^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          DeviceInformationCustomPairing *wrapper = DeviceInformationCustomPairing::Unwrap<DeviceInformationCustomPairing>(info.This());
          wrapper->_instance->PairingRequested::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Enumeration::DeviceInformationCustomPairing^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceInformationCustomPairing(::Windows::Devices::Enumeration::DeviceInformationCustomPairing^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceInformationCustomPairing^ UnwrapDeviceInformationCustomPairing(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceInformationCustomPairing::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceInformationCustomPairing(::Windows::Devices::Enumeration::DeviceInformationCustomPairing^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceInformationCustomPairing::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceInformationCustomPairing^ UnwrapDeviceInformationCustomPairing(Local<Value> value) {
     return DeviceInformationCustomPairing::Unwrap<DeviceInformationCustomPairing>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceInformationCustomPairing(Local<Object> exports) {
    DeviceInformationCustomPairing::Init(exports);
  }

  class DeviceInformationPairing : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceInformationPairing").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;


          
            Nan::SetPrototypeMethod(localRef, "pairAsync", PairAsync);
            Nan::SetPrototypeMethod(localRef, "unpairAsync", UnpairAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("canPair").ToLocalChecked(), CanPairGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isPaired").ToLocalChecked(), IsPairedGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("custom").ToLocalChecked(), CustomGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("protectionLevel").ToLocalChecked(), ProtectionLevelGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "tryRegisterForAllInboundPairingRequestsWithProtectionLevel", TryRegisterForAllInboundPairingRequestsWithProtectionLevel);
        Nan::SetMethod(constructor, "tryRegisterForAllInboundPairingRequests", TryRegisterForAllInboundPairingRequests);


        Nan::Set(exports, Nan::New<String>("DeviceInformationPairing").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceInformationPairing(::Windows::Devices::Enumeration::DeviceInformationPairing^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceInformationPairing^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationPairing^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceInformationPairing^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceInformationPairing *wrapperInstance = new DeviceInformationPairing(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationPairing^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceInformationPairing^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceInformationPairing^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceInformationPairing(winRtInstance));
    }

    static void PairAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationPairing^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      DeviceInformationPairing *wrapper = DeviceInformationPairing::Unwrap<DeviceInformationPairing>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Enumeration::DevicePairingResult^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->PairAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Enumeration::DevicePairingProtectionLevel arg0 = static_cast<::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->PairAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && info[0]->IsInt32()
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::IDevicePairingSettings^>(info[1]))
      {
        try
        {
          ::Windows::Devices::Enumeration::DevicePairingProtectionLevel arg0 = static_cast<::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          ::Windows::Devices::Enumeration::IDevicePairingSettings^ arg1 = UnwrapIDevicePairingSettings(info[1]);
          
          op = wrapper->_instance->PairAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Enumeration::DevicePairingResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapDevicePairingResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void UnpairAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationPairing^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      DeviceInformationPairing *wrapper = DeviceInformationPairing::Unwrap<DeviceInformationPairing>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Enumeration::DeviceUnpairingResult^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->UnpairAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Enumeration::DeviceUnpairingResult^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapDeviceUnpairingResult(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }




    static void TryRegisterForAllInboundPairingRequestsWithProtectionLevel(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 2
        && info[0]->IsInt32()
        && info[1]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Enumeration::DevicePairingKinds arg0 = static_cast<::Windows::Devices::Enumeration::DevicePairingKinds>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          ::Windows::Devices::Enumeration::DevicePairingProtectionLevel arg1 = static_cast<::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          bool result;
          result = ::Windows::Devices::Enumeration::DeviceInformationPairing::TryRegisterForAllInboundPairingRequestsWithProtectionLevel(arg0, arg1);
          info.GetReturnValue().Set(Nan::New<Boolean>(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void TryRegisterForAllInboundPairingRequests(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Enumeration::DevicePairingKinds arg0 = static_cast<::Windows::Devices::Enumeration::DevicePairingKinds>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          bool result;
          result = ::Windows::Devices::Enumeration::DeviceInformationPairing::TryRegisterForAllInboundPairingRequests(arg0);
          info.GetReturnValue().Set(Nan::New<Boolean>(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CanPairGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationPairing^>(info.This())) {
        return;
      }

      DeviceInformationPairing *wrapper = DeviceInformationPairing::Unwrap<DeviceInformationPairing>(info.This());

      try  {
        bool result = wrapper->_instance->CanPair;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IsPairedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationPairing^>(info.This())) {
        return;
      }

      DeviceInformationPairing *wrapper = DeviceInformationPairing::Unwrap<DeviceInformationPairing>(info.This());

      try  {
        bool result = wrapper->_instance->IsPaired;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CustomGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationPairing^>(info.This())) {
        return;
      }

      DeviceInformationPairing *wrapper = DeviceInformationPairing::Unwrap<DeviceInformationPairing>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceInformationCustomPairing^ result = wrapper->_instance->Custom;
        info.GetReturnValue().Set(WrapDeviceInformationCustomPairing(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ProtectionLevelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationPairing^>(info.This())) {
        return;
      }

      DeviceInformationPairing *wrapper = DeviceInformationPairing::Unwrap<DeviceInformationPairing>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DevicePairingProtectionLevel result = wrapper->_instance->ProtectionLevel;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DeviceInformationPairing^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceInformationPairing(::Windows::Devices::Enumeration::DeviceInformationPairing^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceInformationPairing^ UnwrapDeviceInformationPairing(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceInformationPairing::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceInformationPairing(::Windows::Devices::Enumeration::DeviceInformationPairing^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceInformationPairing::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceInformationPairing^ UnwrapDeviceInformationPairing(Local<Value> value) {
     return DeviceInformationPairing::Unwrap<DeviceInformationPairing>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceInformationPairing(Local<Object> exports) {
    DeviceInformationPairing::Init(exports);
  }

  class DeviceInformationUpdate : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceInformationUpdate").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("id").ToLocalChecked(), IdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("properties").ToLocalChecked(), PropertiesGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("kind").ToLocalChecked(), KindGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DeviceInformationUpdate").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceInformationUpdate(::Windows::Devices::Enumeration::DeviceInformationUpdate^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceInformationUpdate^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationUpdate^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceInformationUpdate^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceInformationUpdate *wrapperInstance = new DeviceInformationUpdate(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationUpdate^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceInformationUpdate^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceInformationUpdate^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceInformationUpdate(winRtInstance));
    }





    static void IdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationUpdate^>(info.This())) {
        return;
      }

      DeviceInformationUpdate *wrapper = DeviceInformationUpdate::Unwrap<DeviceInformationUpdate>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Id;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PropertiesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationUpdate^>(info.This())) {
        return;
      }

      DeviceInformationUpdate *wrapper = DeviceInformationUpdate::Unwrap<DeviceInformationUpdate>(info.This());

      try  {
        ::Windows::Foundation::Collections::IMapView<::Platform::String^, ::Platform::Object^>^ result = wrapper->_instance->Properties;
        info.GetReturnValue().Set(NodeRT::Collections::MapViewWrapper<::Platform::String^,::Platform::Object^>::CreateMapViewWrapper(result, 
            [](::Platform::String^ val) -> Local<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Local<Value> value) -> bool {
              return value->IsString();
            },
            [](Local<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));
            },
            [](::Platform::Object^ val) -> Local<Value> {
              return CreateOpaqueWrapper(val);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void KindGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformationUpdate^>(info.This())) {
        return;
      }

      DeviceInformationUpdate *wrapper = DeviceInformationUpdate::Unwrap<DeviceInformationUpdate>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceInformationKind result = wrapper->_instance->Kind;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DeviceInformationUpdate^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceInformationUpdate(::Windows::Devices::Enumeration::DeviceInformationUpdate^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceInformationUpdate^ UnwrapDeviceInformationUpdate(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceInformationUpdate::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceInformationUpdate(::Windows::Devices::Enumeration::DeviceInformationUpdate^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceInformationUpdate::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceInformationUpdate^ UnwrapDeviceInformationUpdate(Local<Value> value) {
     return DeviceInformationUpdate::Unwrap<DeviceInformationUpdate>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceInformationUpdate(Local<Object> exports) {
    DeviceInformationUpdate::Init(exports);
  }

  class DevicePairingRequestedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DevicePairingRequestedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "accept", Accept);
            Nan::SetPrototypeMethod(localRef, "getDeferral", GetDeferral);
            Nan::SetPrototypeMethod(localRef, "acceptWithPasswordCredential", AcceptWithPasswordCredential);
          



          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceInformation").ToLocalChecked(), DeviceInformationGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("pairingKind").ToLocalChecked(), PairingKindGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("pin").ToLocalChecked(), PinGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DevicePairingRequestedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DevicePairingRequestedEventArgs(::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DevicePairingRequestedEventArgs *wrapperInstance = new DevicePairingRequestedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDevicePairingRequestedEventArgs(winRtInstance));
    }


    static void Accept(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^>(info.This())) {
        return;
      }

      DevicePairingRequestedEventArgs *wrapper = DevicePairingRequestedEventArgs::Unwrap<DevicePairingRequestedEventArgs>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Accept();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          wrapper->_instance->Accept(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetDeferral(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^>(info.This())) {
        return;
      }

      DevicePairingRequestedEventArgs *wrapper = DevicePairingRequestedEventArgs::Unwrap<DevicePairingRequestedEventArgs>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Deferral^ result;
          result = wrapper->_instance->GetDeferral();
          info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation", "Deferral", result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void AcceptWithPasswordCredential(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^>(info.This())) {
        return;
      }

      DevicePairingRequestedEventArgs *wrapper = DevicePairingRequestedEventArgs::Unwrap<DevicePairingRequestedEventArgs>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Security::Credentials::PasswordCredential^>(info[0]))
      {
        try
        {
          ::Windows::Security::Credentials::PasswordCredential^ arg0 = dynamic_cast<::Windows::Security::Credentials::PasswordCredential^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          wrapper->_instance->AcceptWithPasswordCredential(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void DeviceInformationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^>(info.This())) {
        return;
      }

      DevicePairingRequestedEventArgs *wrapper = DevicePairingRequestedEventArgs::Unwrap<DevicePairingRequestedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceInformation^ result = wrapper->_instance->DeviceInformation;
        info.GetReturnValue().Set(WrapDeviceInformation(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PairingKindGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^>(info.This())) {
        return;
      }

      DevicePairingRequestedEventArgs *wrapper = DevicePairingRequestedEventArgs::Unwrap<DevicePairingRequestedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DevicePairingKinds result = wrapper->_instance->PairingKind;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PinGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^>(info.This())) {
        return;
      }

      DevicePairingRequestedEventArgs *wrapper = DevicePairingRequestedEventArgs::Unwrap<DevicePairingRequestedEventArgs>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Pin;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDevicePairingRequestedEventArgs(::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^ UnwrapDevicePairingRequestedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> DevicePairingRequestedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapDevicePairingRequestedEventArgs(::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DevicePairingRequestedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs^ UnwrapDevicePairingRequestedEventArgs(Local<Value> value) {
     return DevicePairingRequestedEventArgs::Unwrap<DevicePairingRequestedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDevicePairingRequestedEventArgs(Local<Object> exports) {
    DevicePairingRequestedEventArgs::Init(exports);
  }

  class DevicePairingResult : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DevicePairingResult").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("protectionLevelUsed").ToLocalChecked(), ProtectionLevelUsedGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DevicePairingResult").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DevicePairingResult(::Windows::Devices::Enumeration::DevicePairingResult^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DevicePairingResult^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePairingResult^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DevicePairingResult^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DevicePairingResult *wrapperInstance = new DevicePairingResult(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePairingResult^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DevicePairingResult^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DevicePairingResult^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDevicePairingResult(winRtInstance));
    }





    static void ProtectionLevelUsedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePairingResult^>(info.This())) {
        return;
      }

      DevicePairingResult *wrapper = DevicePairingResult::Unwrap<DevicePairingResult>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DevicePairingProtectionLevel result = wrapper->_instance->ProtectionLevelUsed;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePairingResult^>(info.This())) {
        return;
      }

      DevicePairingResult *wrapper = DevicePairingResult::Unwrap<DevicePairingResult>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DevicePairingResultStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DevicePairingResult^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDevicePairingResult(::Windows::Devices::Enumeration::DevicePairingResult^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DevicePairingResult^ UnwrapDevicePairingResult(Local<Value> value);
  };

  Persistent<FunctionTemplate> DevicePairingResult::s_constructorTemplate;

  v8::Local<v8::Value> WrapDevicePairingResult(::Windows::Devices::Enumeration::DevicePairingResult^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DevicePairingResult::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DevicePairingResult^ UnwrapDevicePairingResult(Local<Value> value) {
     return DevicePairingResult::Unwrap<DevicePairingResult>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDevicePairingResult(Local<Object> exports) {
    DevicePairingResult::Init(exports);
  }

  class DevicePicker : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DevicePicker").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "show", Show);
            Nan::SetPrototypeMethod(localRef, "hide", Hide);
            Nan::SetPrototypeMethod(localRef, "setDisplayStatus", SetDisplayStatus);
          

          
            Nan::SetPrototypeMethod(localRef, "pickSingleDeviceAsync", PickSingleDeviceAsync);
          

          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("appearance").ToLocalChecked(), AppearanceGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("filter").ToLocalChecked(), FilterGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("requestedProperties").ToLocalChecked(), RequestedPropertiesGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DevicePicker").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DevicePicker(::Windows::Devices::Enumeration::DevicePicker^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DevicePicker^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DevicePicker^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Devices::Enumeration::DevicePicker();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DevicePicker *wrapperInstance = new DevicePicker(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DevicePicker^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DevicePicker^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDevicePicker(winRtInstance));
    }

    static void PickSingleDeviceAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Enumeration::DeviceInformation^>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsRect(info[0]))
      {
        try
        {
          ::Windows::Foundation::Rect arg0 = NodeRT::Utils::RectFromJs(info[0]);
          
          op = wrapper->_instance->PickSingleDeviceAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && NodeRT::Utils::IsRect(info[0])
        && info[1]->IsInt32())
      {
        try
        {
          ::Windows::Foundation::Rect arg0 = NodeRT::Utils::RectFromJs(info[0]);
          ::Windows::UI::Popups::Placement arg1 = static_cast<::Windows::UI::Popups::Placement>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          op = wrapper->_instance->PickSingleDeviceAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Enumeration::DeviceInformation^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapDeviceInformation(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void Show(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This())) {
        return;
      }

      DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsRect(info[0]))
      {
        try
        {
          ::Windows::Foundation::Rect arg0 = NodeRT::Utils::RectFromJs(info[0]);
          
          wrapper->_instance->Show(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && NodeRT::Utils::IsRect(info[0])
        && info[1]->IsInt32())
      {
        try
        {
          ::Windows::Foundation::Rect arg0 = NodeRT::Utils::RectFromJs(info[0]);
          ::Windows::UI::Popups::Placement arg1 = static_cast<::Windows::UI::Popups::Placement>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          
          wrapper->_instance->Show(arg0, arg1);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Hide(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This())) {
        return;
      }

      DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Hide();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void SetDisplayStatus(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This())) {
        return;
      }

      DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());

      if (info.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceInformation^>(info[0])
        && info[1]->IsString()
        && info[2]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Enumeration::DeviceInformation^ arg0 = UnwrapDeviceInformation(info[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[1])));
          ::Windows::Devices::Enumeration::DevicePickerDisplayStatusOptions arg2 = static_cast<::Windows::Devices::Enumeration::DevicePickerDisplayStatusOptions>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          
          wrapper->_instance->SetDisplayStatus(arg0, arg1, arg2);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void AppearanceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This())) {
        return;
      }

      DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DevicePickerAppearance^ result = wrapper->_instance->Appearance;
        info.GetReturnValue().Set(WrapDevicePickerAppearance(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void FilterGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This())) {
        return;
      }

      DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DevicePickerFilter^ result = wrapper->_instance->Filter;
        info.GetReturnValue().Set(WrapDevicePickerFilter(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void RequestedPropertiesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This())) {
        return;
      }

      DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->RequestedProperties;
        info.GetReturnValue().Set(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Local<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Local<Value> value) -> bool {
              return value->IsString();
            },
            [](Local<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"devicePickerDismissed", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->DevicePickerDismissed::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Enumeration::DevicePicker^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Enumeration::DevicePicker^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapDevicePicker(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"deviceSelected", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->DeviceSelected::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Enumeration::DevicePicker^, ::Windows::Devices::Enumeration::DeviceSelectedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Enumeration::DevicePicker^ arg0, ::Windows::Devices::Enumeration::DeviceSelectedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapDevicePicker(arg0);
                  wrappedArg1 = WrapDeviceSelectedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"disconnectButtonClicked", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->DisconnectButtonClicked::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Enumeration::DevicePicker^, ::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Enumeration::DevicePicker^ arg0, ::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapDevicePicker(arg0);
                  wrappedArg1 = WrapDeviceDisconnectButtonClickedEventArgs(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"devicePickerDismissed", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"deviceSelected", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"disconnectButtonClicked", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"devicePickerDismissed", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());
          wrapper->_instance->DevicePickerDismissed::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"deviceSelected", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());
          wrapper->_instance->DeviceSelected::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"disconnectButtonClicked", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePicker^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          DevicePicker *wrapper = DevicePicker::Unwrap<DevicePicker>(info.This());
          wrapper->_instance->DisconnectButtonClicked::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Enumeration::DevicePicker^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDevicePicker(::Windows::Devices::Enumeration::DevicePicker^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DevicePicker^ UnwrapDevicePicker(Local<Value> value);
  };

  Persistent<FunctionTemplate> DevicePicker::s_constructorTemplate;

  v8::Local<v8::Value> WrapDevicePicker(::Windows::Devices::Enumeration::DevicePicker^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DevicePicker::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DevicePicker^ UnwrapDevicePicker(Local<Value> value) {
     return DevicePicker::Unwrap<DevicePicker>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDevicePicker(Local<Object> exports) {
    DevicePicker::Init(exports);
  }

  class DevicePickerAppearance : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DevicePickerAppearance").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("title").ToLocalChecked(), TitleGetter, TitleSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("selectedForegroundColor").ToLocalChecked(), SelectedForegroundColorGetter, SelectedForegroundColorSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("selectedBackgroundColor").ToLocalChecked(), SelectedBackgroundColorGetter, SelectedBackgroundColorSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("selectedAccentColor").ToLocalChecked(), SelectedAccentColorGetter, SelectedAccentColorSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("foregroundColor").ToLocalChecked(), ForegroundColorGetter, ForegroundColorSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("backgroundColor").ToLocalChecked(), BackgroundColorGetter, BackgroundColorSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("accentColor").ToLocalChecked(), AccentColorGetter, AccentColorSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DevicePickerAppearance").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DevicePickerAppearance(::Windows::Devices::Enumeration::DevicePickerAppearance^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DevicePickerAppearance^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DevicePickerAppearance^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DevicePickerAppearance *wrapperInstance = new DevicePickerAppearance(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DevicePickerAppearance^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DevicePickerAppearance^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDevicePickerAppearance(winRtInstance));
    }





    static void TitleGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Title;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void TitleSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsString()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try {

        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));

        wrapper->_instance->Title = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void SelectedForegroundColorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try  {
        ::Windows::UI::Color result = wrapper->_instance->SelectedForegroundColor;
        info.GetReturnValue().Set(NodeRT::Utils::ColorToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SelectedForegroundColorSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsColor(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try {

        ::Windows::UI::Color winRtValue = NodeRT::Utils::ColorFromJs(value);

        wrapper->_instance->SelectedForegroundColor = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void SelectedBackgroundColorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try  {
        ::Windows::UI::Color result = wrapper->_instance->SelectedBackgroundColor;
        info.GetReturnValue().Set(NodeRT::Utils::ColorToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SelectedBackgroundColorSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsColor(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try {

        ::Windows::UI::Color winRtValue = NodeRT::Utils::ColorFromJs(value);

        wrapper->_instance->SelectedBackgroundColor = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void SelectedAccentColorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try  {
        ::Windows::UI::Color result = wrapper->_instance->SelectedAccentColor;
        info.GetReturnValue().Set(NodeRT::Utils::ColorToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SelectedAccentColorSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsColor(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try {

        ::Windows::UI::Color winRtValue = NodeRT::Utils::ColorFromJs(value);

        wrapper->_instance->SelectedAccentColor = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void ForegroundColorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try  {
        ::Windows::UI::Color result = wrapper->_instance->ForegroundColor;
        info.GetReturnValue().Set(NodeRT::Utils::ColorToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ForegroundColorSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsColor(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try {

        ::Windows::UI::Color winRtValue = NodeRT::Utils::ColorFromJs(value);

        wrapper->_instance->ForegroundColor = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void BackgroundColorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try  {
        ::Windows::UI::Color result = wrapper->_instance->BackgroundColor;
        info.GetReturnValue().Set(NodeRT::Utils::ColorToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void BackgroundColorSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsColor(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try {

        ::Windows::UI::Color winRtValue = NodeRT::Utils::ColorFromJs(value);

        wrapper->_instance->BackgroundColor = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void AccentColorGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try  {
        ::Windows::UI::Color result = wrapper->_instance->AccentColor;
        info.GetReturnValue().Set(NodeRT::Utils::ColorToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void AccentColorSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsColor(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerAppearance^>(info.This())) {
        return;
      }

      DevicePickerAppearance *wrapper = DevicePickerAppearance::Unwrap<DevicePickerAppearance>(info.This());

      try {

        ::Windows::UI::Color winRtValue = NodeRT::Utils::ColorFromJs(value);

        wrapper->_instance->AccentColor = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DevicePickerAppearance^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDevicePickerAppearance(::Windows::Devices::Enumeration::DevicePickerAppearance^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DevicePickerAppearance^ UnwrapDevicePickerAppearance(Local<Value> value);
  };

  Persistent<FunctionTemplate> DevicePickerAppearance::s_constructorTemplate;

  v8::Local<v8::Value> WrapDevicePickerAppearance(::Windows::Devices::Enumeration::DevicePickerAppearance^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DevicePickerAppearance::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DevicePickerAppearance^ UnwrapDevicePickerAppearance(Local<Value> value) {
     return DevicePickerAppearance::Unwrap<DevicePickerAppearance>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDevicePickerAppearance(Local<Object> exports) {
    DevicePickerAppearance::Init(exports);
  }

  class DevicePickerFilter : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DevicePickerFilter").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("supportedDeviceClasses").ToLocalChecked(), SupportedDeviceClassesGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("supportedDeviceSelectors").ToLocalChecked(), SupportedDeviceSelectorsGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DevicePickerFilter").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DevicePickerFilter(::Windows::Devices::Enumeration::DevicePickerFilter^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DevicePickerFilter^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerFilter^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DevicePickerFilter^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DevicePickerFilter *wrapperInstance = new DevicePickerFilter(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerFilter^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DevicePickerFilter^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DevicePickerFilter^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDevicePickerFilter(winRtInstance));
    }





    static void SupportedDeviceClassesGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerFilter^>(info.This())) {
        return;
      }

      DevicePickerFilter *wrapper = DevicePickerFilter::Unwrap<DevicePickerFilter>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVector<::Windows::Devices::Enumeration::DeviceClass>^ result = wrapper->_instance->SupportedDeviceClasses;
        info.GetReturnValue().Set(NodeRT::Collections::VectorWrapper<::Windows::Devices::Enumeration::DeviceClass>::CreateVectorWrapper(result, 
            [](::Windows::Devices::Enumeration::DeviceClass val) -> Local<Value> {
              return Nan::New<Integer>(static_cast<int>(val));
            },
            [](Local<Value> value) -> bool {
              return value->IsInt32();
            },
            [](Local<Value> value) -> ::Windows::Devices::Enumeration::DeviceClass {
              return static_cast<::Windows::Devices::Enumeration::DeviceClass>(Nan::To<int32_t>(value).FromMaybe(0));
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SupportedDeviceSelectorsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DevicePickerFilter^>(info.This())) {
        return;
      }

      DevicePickerFilter *wrapper = DevicePickerFilter::Unwrap<DevicePickerFilter>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->SupportedDeviceSelectors;
        info.GetReturnValue().Set(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Local<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Local<Value> value) -> bool {
              return value->IsString();
            },
            [](Local<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DevicePickerFilter^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDevicePickerFilter(::Windows::Devices::Enumeration::DevicePickerFilter^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DevicePickerFilter^ UnwrapDevicePickerFilter(Local<Value> value);
  };

  Persistent<FunctionTemplate> DevicePickerFilter::s_constructorTemplate;

  v8::Local<v8::Value> WrapDevicePickerFilter(::Windows::Devices::Enumeration::DevicePickerFilter^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DevicePickerFilter::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DevicePickerFilter^ UnwrapDevicePickerFilter(Local<Value> value) {
     return DevicePickerFilter::Unwrap<DevicePickerFilter>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDevicePickerFilter(Local<Object> exports) {
    DevicePickerFilter::Init(exports);
  }

  class DeviceSelectedEventArgs : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceSelectedEventArgs").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("selectedDevice").ToLocalChecked(), SelectedDeviceGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DeviceSelectedEventArgs").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceSelectedEventArgs(::Windows::Devices::Enumeration::DeviceSelectedEventArgs^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceSelectedEventArgs^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceSelectedEventArgs^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceSelectedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceSelectedEventArgs *wrapperInstance = new DeviceSelectedEventArgs(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceSelectedEventArgs^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceSelectedEventArgs^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceSelectedEventArgs^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceSelectedEventArgs(winRtInstance));
    }





    static void SelectedDeviceGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceSelectedEventArgs^>(info.This())) {
        return;
      }

      DeviceSelectedEventArgs *wrapper = DeviceSelectedEventArgs::Unwrap<DeviceSelectedEventArgs>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceInformation^ result = wrapper->_instance->SelectedDevice;
        info.GetReturnValue().Set(WrapDeviceInformation(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DeviceSelectedEventArgs^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceSelectedEventArgs(::Windows::Devices::Enumeration::DeviceSelectedEventArgs^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceSelectedEventArgs^ UnwrapDeviceSelectedEventArgs(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceSelectedEventArgs::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceSelectedEventArgs(::Windows::Devices::Enumeration::DeviceSelectedEventArgs^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceSelectedEventArgs::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceSelectedEventArgs^ UnwrapDeviceSelectedEventArgs(Local<Value> value) {
     return DeviceSelectedEventArgs::Unwrap<DeviceSelectedEventArgs>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceSelectedEventArgs(Local<Object> exports) {
    DeviceSelectedEventArgs::Init(exports);
  }

  class DeviceThumbnail : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceThumbnail").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "getInputStreamAt", GetInputStreamAt);
            Nan::SetPrototypeMethod(localRef, "getOutputStreamAt", GetOutputStreamAt);
            Nan::SetPrototypeMethod(localRef, "seek", Seek);
            Nan::SetPrototypeMethod(localRef, "cloneStream", CloneStream);
            Nan::SetPrototypeMethod(localRef, "close", Close);
          

          
            Nan::SetPrototypeMethod(localRef, "readAsync", ReadAsync);
            Nan::SetPrototypeMethod(localRef, "writeAsync", WriteAsync);
            Nan::SetPrototypeMethod(localRef, "flushAsync", FlushAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("contentType").ToLocalChecked(), ContentTypeGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("size").ToLocalChecked(), SizeGetter, SizeSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("canRead").ToLocalChecked(), CanReadGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("canWrite").ToLocalChecked(), CanWriteGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("position").ToLocalChecked(), PositionGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DeviceThumbnail").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceThumbnail(::Windows::Devices::Enumeration::DeviceThumbnail^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceThumbnail^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceThumbnail^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceThumbnail *wrapperInstance = new DeviceThumbnail(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceThumbnail^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceThumbnail^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceThumbnail(winRtInstance));
    }

    static void ReadAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;


      if (info.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])
        && info[1]->IsUint32()
        && info[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[0]));
          unsigned int arg1 = static_cast<unsigned int>(Nan::To<uint32_t>(info[1]).FromMaybe(0));
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void WriteAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void FlushAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Boolean>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void GetInputStreamAt(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->GetInputStreamAt(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IInputStream", result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetOutputStreamAt(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->GetOutputStreamAt(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IOutputStream", result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Seek(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->Seek(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void CloneStream(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IRandomAccessStream^ result;
          result = wrapper->_instance->CloneStream();
          info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IRandomAccessStream", result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void ContentTypeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->ContentType;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SizeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->Size;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SizeSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsNumber()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      try {

        unsigned __int64 winRtValue = static_cast<unsigned __int64>(Nan::To<int64_t>(value).FromMaybe(0));

        wrapper->_instance->Size = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void CanReadGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      try  {
        bool result = wrapper->_instance->CanRead;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CanWriteGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      try  {
        bool result = wrapper->_instance->CanWrite;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PositionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceThumbnail^>(info.This())) {
        return;
      }

      DeviceThumbnail *wrapper = DeviceThumbnail::Unwrap<DeviceThumbnail>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->Position;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DeviceThumbnail^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceThumbnail(::Windows::Devices::Enumeration::DeviceThumbnail^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceThumbnail^ UnwrapDeviceThumbnail(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceThumbnail::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceThumbnail(::Windows::Devices::Enumeration::DeviceThumbnail^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceThumbnail::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceThumbnail^ UnwrapDeviceThumbnail(Local<Value> value) {
     return DeviceThumbnail::Unwrap<DeviceThumbnail>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceThumbnail(Local<Object> exports) {
    DeviceThumbnail::Init(exports);
  }

  class DeviceUnpairingResult : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceUnpairingResult").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DeviceUnpairingResult").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceUnpairingResult(::Windows::Devices::Enumeration::DeviceUnpairingResult^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceUnpairingResult^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceUnpairingResult^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceUnpairingResult^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceUnpairingResult *wrapperInstance = new DeviceUnpairingResult(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceUnpairingResult^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceUnpairingResult^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceUnpairingResult^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceUnpairingResult(winRtInstance));
    }





    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceUnpairingResult^>(info.This())) {
        return;
      }

      DeviceUnpairingResult *wrapper = DeviceUnpairingResult::Unwrap<DeviceUnpairingResult>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceUnpairingResultStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DeviceUnpairingResult^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceUnpairingResult(::Windows::Devices::Enumeration::DeviceUnpairingResult^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceUnpairingResult^ UnwrapDeviceUnpairingResult(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceUnpairingResult::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceUnpairingResult(::Windows::Devices::Enumeration::DeviceUnpairingResult^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceUnpairingResult::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceUnpairingResult^ UnwrapDeviceUnpairingResult(Local<Value> value) {
     return DeviceUnpairingResult::Unwrap<DeviceUnpairingResult>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceUnpairingResult(Local<Object> exports) {
    DeviceUnpairingResult::Init(exports);
  }

  class DeviceWatcher : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceWatcher").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "start", Start);
            Nan::SetPrototypeMethod(localRef, "stop", Stop);
            Nan::SetPrototypeMethod(localRef, "getBackgroundTrigger", GetBackgroundTrigger);
          


          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DeviceWatcher").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceWatcher(::Windows::Devices::Enumeration::DeviceWatcher^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceWatcher^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceWatcher^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceWatcher *wrapperInstance = new DeviceWatcher(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceWatcher^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceWatcher^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceWatcher(winRtInstance));
    }


    static void Start(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This())) {
        return;
      }

      DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Start();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Stop(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This())) {
        return;
      }

      DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Stop();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetBackgroundTrigger(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This())) {
        return;
      }

      DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Windows::Devices::Enumeration::DeviceWatcherEventKind>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Windows::Devices::Enumeration::DeviceWatcherEventKind>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Windows::Devices::Enumeration::DeviceWatcherEventKind>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Windows::Devices::Enumeration::DeviceWatcherEventKind>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Local<Value> value) -> ::Windows::Devices::Enumeration::DeviceWatcherEventKind {
                   return static_cast<::Windows::Devices::Enumeration::DeviceWatcherEventKind>(Nan::To<int32_t>(value).FromMaybe(0));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Windows::Devices::Enumeration::DeviceWatcherEventKind>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Windows::ApplicationModel::Background::DeviceWatcherTrigger^ result;
          result = wrapper->_instance->GetBackgroundTrigger(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.ApplicationModel.Background", "DeviceWatcherTrigger", result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This())) {
        return;
      }

      DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceWatcherStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"added", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->Added::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Enumeration::DeviceWatcher^, ::Windows::Devices::Enumeration::DeviceInformation^>(
            [callbackObjPtr](::Windows::Devices::Enumeration::DeviceWatcher^ arg0, ::Windows::Devices::Enumeration::DeviceInformation^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapDeviceWatcher(arg0);
                  wrappedArg1 = WrapDeviceInformation(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"enumerationCompleted", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->EnumerationCompleted::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Enumeration::DeviceWatcher^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Enumeration::DeviceWatcher^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapDeviceWatcher(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"removed", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->Removed::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Enumeration::DeviceWatcher^, ::Windows::Devices::Enumeration::DeviceInformationUpdate^>(
            [callbackObjPtr](::Windows::Devices::Enumeration::DeviceWatcher^ arg0, ::Windows::Devices::Enumeration::DeviceInformationUpdate^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapDeviceWatcher(arg0);
                  wrappedArg1 = WrapDeviceInformationUpdate(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"stopped", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->Stopped::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Enumeration::DeviceWatcher^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Enumeration::DeviceWatcher^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapDeviceWatcher(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"updated", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->Updated::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Enumeration::DeviceWatcher^, ::Windows::Devices::Enumeration::DeviceInformationUpdate^>(
            [callbackObjPtr](::Windows::Devices::Enumeration::DeviceWatcher^ arg0, ::Windows::Devices::Enumeration::DeviceInformationUpdate^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapDeviceWatcher(arg0);
                  wrappedArg1 = WrapDeviceInformationUpdate(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"added", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"enumerationCompleted", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"removed", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"stopped", str)) &&(!NodeRT::Utils::CaseInsenstiveEquals(L"updated", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"added", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());
          wrapper->_instance->Added::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"enumerationCompleted", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());
          wrapper->_instance->EnumerationCompleted::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"removed", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());
          wrapper->_instance->Removed::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"stopped", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());
          wrapper->_instance->Stopped::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"updated", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcher^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          DeviceWatcher *wrapper = DeviceWatcher::Unwrap<DeviceWatcher>(info.This());
          wrapper->_instance->Updated::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Enumeration::DeviceWatcher^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceWatcher(::Windows::Devices::Enumeration::DeviceWatcher^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceWatcher^ UnwrapDeviceWatcher(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceWatcher::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceWatcher(::Windows::Devices::Enumeration::DeviceWatcher^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceWatcher::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceWatcher^ UnwrapDeviceWatcher(Local<Value> value) {
     return DeviceWatcher::Unwrap<DeviceWatcher>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceWatcher(Local<Object> exports) {
    DeviceWatcher::Init(exports);
  }

  class DeviceWatcherEvent : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceWatcherEvent").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceInformation").ToLocalChecked(), DeviceInformationGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceInformationUpdate").ToLocalChecked(), DeviceInformationUpdateGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("kind").ToLocalChecked(), KindGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DeviceWatcherEvent").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceWatcherEvent(::Windows::Devices::Enumeration::DeviceWatcherEvent^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceWatcherEvent^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcherEvent^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceWatcherEvent^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceWatcherEvent *wrapperInstance = new DeviceWatcherEvent(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcherEvent^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceWatcherEvent^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceWatcherEvent^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceWatcherEvent(winRtInstance));
    }





    static void DeviceInformationGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcherEvent^>(info.This())) {
        return;
      }

      DeviceWatcherEvent *wrapper = DeviceWatcherEvent::Unwrap<DeviceWatcherEvent>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceInformation^ result = wrapper->_instance->DeviceInformation;
        info.GetReturnValue().Set(WrapDeviceInformation(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DeviceInformationUpdateGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcherEvent^>(info.This())) {
        return;
      }

      DeviceWatcherEvent *wrapper = DeviceWatcherEvent::Unwrap<DeviceWatcherEvent>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceInformationUpdate^ result = wrapper->_instance->DeviceInformationUpdate;
        info.GetReturnValue().Set(WrapDeviceInformationUpdate(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void KindGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcherEvent^>(info.This())) {
        return;
      }

      DeviceWatcherEvent *wrapper = DeviceWatcherEvent::Unwrap<DeviceWatcherEvent>(info.This());

      try  {
        ::Windows::Devices::Enumeration::DeviceWatcherEventKind result = wrapper->_instance->Kind;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DeviceWatcherEvent^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceWatcherEvent(::Windows::Devices::Enumeration::DeviceWatcherEvent^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceWatcherEvent^ UnwrapDeviceWatcherEvent(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceWatcherEvent::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceWatcherEvent(::Windows::Devices::Enumeration::DeviceWatcherEvent^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceWatcherEvent::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceWatcherEvent^ UnwrapDeviceWatcherEvent(Local<Value> value) {
     return DeviceWatcherEvent::Unwrap<DeviceWatcherEvent>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceWatcherEvent(Local<Object> exports) {
    DeviceWatcherEvent::Init(exports);
  }

  class DeviceWatcherTriggerDetails : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DeviceWatcherTriggerDetails").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("deviceWatcherEvents").ToLocalChecked(), DeviceWatcherEventsGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DeviceWatcherTriggerDetails").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DeviceWatcherTriggerDetails(::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DeviceWatcherTriggerDetails *wrapperInstance = new DeviceWatcherTriggerDetails(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeviceWatcherTriggerDetails(winRtInstance));
    }





    static void DeviceWatcherEventsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^>(info.This())) {
        return;
      }

      DeviceWatcherTriggerDetails *wrapper = DeviceWatcherTriggerDetails::Unwrap<DeviceWatcherTriggerDetails>(info.This());

      try  {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Enumeration::DeviceWatcherEvent^>^ result = wrapper->_instance->DeviceWatcherEvents;
        info.GetReturnValue().Set(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Enumeration::DeviceWatcherEvent^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Enumeration::DeviceWatcherEvent^ val) -> Local<Value> {
              return WrapDeviceWatcherEvent(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::DeviceWatcherEvent^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Enumeration::DeviceWatcherEvent^ {
              return UnwrapDeviceWatcherEvent(value);
            }
          ));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeviceWatcherTriggerDetails(::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^ UnwrapDeviceWatcherTriggerDetails(Local<Value> value);
  };

  Persistent<FunctionTemplate> DeviceWatcherTriggerDetails::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeviceWatcherTriggerDetails(::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DeviceWatcherTriggerDetails::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails^ UnwrapDeviceWatcherTriggerDetails(Local<Value> value) {
     return DeviceWatcherTriggerDetails::Unwrap<DeviceWatcherTriggerDetails>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeviceWatcherTriggerDetails(Local<Object> exports) {
    DeviceWatcherTriggerDetails::Init(exports);
  }

  class EnclosureLocation : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("EnclosureLocation").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("inDock").ToLocalChecked(), InDockGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("inLid").ToLocalChecked(), InLidGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("panel").ToLocalChecked(), PanelGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("rotationAngleInDegreesClockwise").ToLocalChecked(), RotationAngleInDegreesClockwiseGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("EnclosureLocation").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      EnclosureLocation(::Windows::Devices::Enumeration::EnclosureLocation^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::EnclosureLocation^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::EnclosureLocation^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::EnclosureLocation^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      EnclosureLocation *wrapperInstance = new EnclosureLocation(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::EnclosureLocation^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::EnclosureLocation^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::EnclosureLocation^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapEnclosureLocation(winRtInstance));
    }





    static void InDockGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::EnclosureLocation^>(info.This())) {
        return;
      }

      EnclosureLocation *wrapper = EnclosureLocation::Unwrap<EnclosureLocation>(info.This());

      try  {
        bool result = wrapper->_instance->InDock;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void InLidGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::EnclosureLocation^>(info.This())) {
        return;
      }

      EnclosureLocation *wrapper = EnclosureLocation::Unwrap<EnclosureLocation>(info.This());

      try  {
        bool result = wrapper->_instance->InLid;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PanelGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::EnclosureLocation^>(info.This())) {
        return;
      }

      EnclosureLocation *wrapper = EnclosureLocation::Unwrap<EnclosureLocation>(info.This());

      try  {
        ::Windows::Devices::Enumeration::Panel result = wrapper->_instance->Panel;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void RotationAngleInDegreesClockwiseGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::EnclosureLocation^>(info.This())) {
        return;
      }

      EnclosureLocation *wrapper = EnclosureLocation::Unwrap<EnclosureLocation>(info.This());

      try  {
        unsigned int result = wrapper->_instance->RotationAngleInDegreesClockwise;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Devices::Enumeration::EnclosureLocation^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapEnclosureLocation(::Windows::Devices::Enumeration::EnclosureLocation^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::EnclosureLocation^ UnwrapEnclosureLocation(Local<Value> value);
  };

  Persistent<FunctionTemplate> EnclosureLocation::s_constructorTemplate;

  v8::Local<v8::Value> WrapEnclosureLocation(::Windows::Devices::Enumeration::EnclosureLocation^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(EnclosureLocation::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::EnclosureLocation^ UnwrapEnclosureLocation(Local<Value> value) {
     return EnclosureLocation::Unwrap<EnclosureLocation>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitEnclosureLocation(Local<Object> exports) {
    EnclosureLocation::Init(exports);
  }

  class IDevicePairingSettings : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IDevicePairingSettings").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IDevicePairingSettings").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IDevicePairingSettings(::Windows::Devices::Enumeration::IDevicePairingSettings^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Enumeration::IDevicePairingSettings^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::IDevicePairingSettings^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Enumeration::IDevicePairingSettings^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IDevicePairingSettings *wrapperInstance = new IDevicePairingSettings(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Enumeration::IDevicePairingSettings^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Enumeration::IDevicePairingSettings^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Enumeration::IDevicePairingSettings^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIDevicePairingSettings(winRtInstance));
    }







    private:
      ::Windows::Devices::Enumeration::IDevicePairingSettings^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIDevicePairingSettings(::Windows::Devices::Enumeration::IDevicePairingSettings^ wintRtInstance);
      friend ::Windows::Devices::Enumeration::IDevicePairingSettings^ UnwrapIDevicePairingSettings(Local<Value> value);
  };

  Persistent<FunctionTemplate> IDevicePairingSettings::s_constructorTemplate;

  v8::Local<v8::Value> WrapIDevicePairingSettings(::Windows::Devices::Enumeration::IDevicePairingSettings^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IDevicePairingSettings::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Enumeration::IDevicePairingSettings^ UnwrapIDevicePairingSettings(Local<Value> value) {
     return IDevicePairingSettings::Unwrap<IDevicePairingSettings>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIDevicePairingSettings(Local<Object> exports) {
    IDevicePairingSettings::Init(exports);
  }

} } } }


namespace NodeRT { namespace Windows { namespace Devices { namespace Radios { 
  v8::Local<v8::Value> WrapRadio(::Windows::Devices::Radios::Radio^ wintRtInstance);
  ::Windows::Devices::Radios::Radio^ UnwrapRadio(Local<Value> value);
  



  static void InitRadioAccessStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("RadioAccessStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("unspecified").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioAccessStatus::Unspecified)));
    Nan::Set(enumObject, Nan::New<String>("allowed").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioAccessStatus::Allowed)));
    Nan::Set(enumObject, Nan::New<String>("deniedByUser").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioAccessStatus::DeniedByUser)));
    Nan::Set(enumObject, Nan::New<String>("deniedBySystem").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioAccessStatus::DeniedBySystem)));
  }

  static void InitRadioKindEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("RadioKind").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("other").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioKind::Other)));
    Nan::Set(enumObject, Nan::New<String>("wiFi").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioKind::WiFi)));
    Nan::Set(enumObject, Nan::New<String>("mobileBroadband").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioKind::MobileBroadband)));
    Nan::Set(enumObject, Nan::New<String>("bluetooth").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioKind::Bluetooth)));
    Nan::Set(enumObject, Nan::New<String>("fM").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioKind::FM)));
  }

  static void InitRadioStateEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("RadioState").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("unknown").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioState::Unknown)));
    Nan::Set(enumObject, Nan::New<String>("on").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioState::On)));
    Nan::Set(enumObject, Nan::New<String>("off").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioState::Off)));
    Nan::Set(enumObject, Nan::New<String>("disabled").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Devices::Radios::RadioState::Disabled)));
  }



  class Radio : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("Radio").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;


          
            Nan::SetPrototypeMethod(localRef, "setStateAsync", SetStateAsync);
          

          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("kind").ToLocalChecked(), KindGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("name").ToLocalChecked(), NameGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("state").ToLocalChecked(), StateGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "getDeviceSelector", GetDeviceSelector);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(GetRadiosAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("getRadiosAsync").ToLocalChecked(), func);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(FromIdAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("fromIdAsync").ToLocalChecked(), func);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(RequestAccessAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("requestAccessAsync").ToLocalChecked(), func);


        Nan::Set(exports, Nan::New<String>("Radio").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      Radio(::Windows::Devices::Radios::Radio^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Devices::Radios::Radio^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Radios::Radio^>(info[0])) {
        try {
          winRtInstance = (::Windows::Devices::Radios::Radio^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      Radio *wrapperInstance = new Radio(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Radios::Radio^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Devices::Radios::Radio^ winRtInstance;
      try {
        winRtInstance = (::Windows::Devices::Radios::Radio^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapRadio(winRtInstance));
    }

    static void SetStateAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Radios::Radio^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      Radio *wrapper = Radio::Unwrap<Radio>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Radios::RadioAccessStatus>^ op;


      if (info.Length() == 2
        && info[0]->IsInt32())
      {
        try
        {
          ::Windows::Devices::Radios::RadioState arg0 = static_cast<::Windows::Devices::Radios::RadioState>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->SetStateAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Radios::RadioAccessStatus> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(static_cast<int>(result));
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }



    static void GetRadiosAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Radios::Radio^>^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = ::Windows::Devices::Radios::Radio::GetRadiosAsync();
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Radios::Radio^>^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Radios::Radio^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Radios::Radio^ val) -> Local<Value> {
              return WrapRadio(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Radios::Radio^>(value);
            },
            [](Local<Value> value) -> ::Windows::Devices::Radios::Radio^ {
              return UnwrapRadio(value);
            }
          );
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void FromIdAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Radios::Radio^>^ op;


      if (info.Length() == 2
          && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
            
          op = ::Windows::Devices::Radios::Radio::FromIdAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Radios::Radio^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapRadio(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void RequestAccessAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Radios::RadioAccessStatus>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = ::Windows::Devices::Radios::Radio::RequestAccessAsync();
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Radios::RadioAccessStatus> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(static_cast<int>(result));
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void GetDeviceSelector(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0)
      {
        try
        {
          Platform::String^ result;
          result = ::Windows::Devices::Radios::Radio::GetDeviceSelector();
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void KindGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Radios::Radio^>(info.This())) {
        return;
      }

      Radio *wrapper = Radio::Unwrap<Radio>(info.This());

      try  {
        ::Windows::Devices::Radios::RadioKind result = wrapper->_instance->Kind;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void NameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Radios::Radio^>(info.This())) {
        return;
      }

      Radio *wrapper = Radio::Unwrap<Radio>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Name;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StateGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Radios::Radio^>(info.This())) {
        return;
      }

      Radio *wrapper = Radio::Unwrap<Radio>(info.This());

      try  {
        ::Windows::Devices::Radios::RadioState result = wrapper->_instance->State;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"stateChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Radios::Radio^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        Radio *wrapper = Radio::Unwrap<Radio>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->StateChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Radios::Radio^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Devices::Radios::Radio^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapRadio(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"stateChanged", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"stateChanged", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Radios::Radio^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          Radio *wrapper = Radio::Unwrap<Radio>(info.This());
          wrapper->_instance->StateChanged::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Devices::Radios::Radio^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapRadio(::Windows::Devices::Radios::Radio^ wintRtInstance);
      friend ::Windows::Devices::Radios::Radio^ UnwrapRadio(Local<Value> value);
  };

  Persistent<FunctionTemplate> Radio::s_constructorTemplate;

  v8::Local<v8::Value> WrapRadio(::Windows::Devices::Radios::Radio^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(Radio::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Devices::Radios::Radio^ UnwrapRadio(Local<Value> value) {
     return Radio::Unwrap<Radio>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitRadio(Local<Object> exports) {
    Radio::Init(exports);
  }

} } } }


namespace NodeRT { namespace Windows { namespace Foundation { 
  v8::Local<v8::Value> WrapDeferral(::Windows::Foundation::Deferral^ wintRtInstance);
  ::Windows::Foundation::Deferral^ UnwrapDeferral(Local<Value> value);
  
  v8::Local<v8::Value> WrapGuidHelper(::Windows::Foundation::GuidHelper^ wintRtInstance);
  ::Windows::Foundation::GuidHelper^ UnwrapGuidHelper(Local<Value> value);
  
  v8::Local<v8::Value> WrapIAsyncAction(::Windows::Foundation::IAsyncAction^ wintRtInstance);
  ::Windows::Foundation::IAsyncAction^ UnwrapIAsyncAction(Local<Value> value);
  
  v8::Local<v8::Value> WrapIAsyncInfo(::Windows::Foundation::IAsyncInfo^ wintRtInstance);
  ::Windows::Foundation::IAsyncInfo^ UnwrapIAsyncInfo(Local<Value> value);
  
  v8::Local<v8::Value> WrapIGetActivationFactory(::Windows::Foundation::IGetActivationFactory^ wintRtInstance);
  ::Windows::Foundation::IGetActivationFactory^ UnwrapIGetActivationFactory(Local<Value> value);
  
  v8::Local<v8::Value> WrapIMemoryBuffer(::Windows::Foundation::IMemoryBuffer^ wintRtInstance);
  ::Windows::Foundation::IMemoryBuffer^ UnwrapIMemoryBuffer(Local<Value> value);
  
  v8::Local<v8::Value> WrapIMemoryBufferReference(::Windows::Foundation::IMemoryBufferReference^ wintRtInstance);
  ::Windows::Foundation::IMemoryBufferReference^ UnwrapIMemoryBufferReference(Local<Value> value);
  
  v8::Local<v8::Value> WrapIStringable(::Windows::Foundation::IStringable^ wintRtInstance);
  ::Windows::Foundation::IStringable^ UnwrapIStringable(Local<Value> value);
  
  v8::Local<v8::Value> WrapIWwwFormUrlDecoderEntry(::Windows::Foundation::IWwwFormUrlDecoderEntry^ wintRtInstance);
  ::Windows::Foundation::IWwwFormUrlDecoderEntry^ UnwrapIWwwFormUrlDecoderEntry(Local<Value> value);
  
  v8::Local<v8::Value> WrapMemoryBuffer(::Windows::Foundation::MemoryBuffer^ wintRtInstance);
  ::Windows::Foundation::MemoryBuffer^ UnwrapMemoryBuffer(Local<Value> value);
  
  v8::Local<v8::Value> WrapPropertyValue(::Windows::Foundation::PropertyValue^ wintRtInstance);
  ::Windows::Foundation::PropertyValue^ UnwrapPropertyValue(Local<Value> value);
  
  v8::Local<v8::Value> WrapWwwFormUrlDecoder(::Windows::Foundation::WwwFormUrlDecoder^ wintRtInstance);
  ::Windows::Foundation::WwwFormUrlDecoder^ UnwrapWwwFormUrlDecoder(Local<Value> value);
  
  v8::Local<v8::Value> WrapWwwFormUrlDecoderEntry(::Windows::Foundation::WwwFormUrlDecoderEntry^ wintRtInstance);
  ::Windows::Foundation::WwwFormUrlDecoderEntry^ UnwrapWwwFormUrlDecoderEntry(Local<Value> value);
  
  v8::Local<v8::Value> WrapIPropertyValue(::Windows::Foundation::IPropertyValue^ wintRtInstance);
  ::Windows::Foundation::IPropertyValue^ UnwrapIPropertyValue(Local<Value> value);
  
  v8::Local<v8::Value> WrapUri(::Windows::Foundation::Uri^ wintRtInstance);
  ::Windows::Foundation::Uri^ UnwrapUri(Local<Value> value);
  



  static void InitAsyncStatusEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("AsyncStatus").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("started").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::AsyncStatus::Started)));
    Nan::Set(enumObject, Nan::New<String>("completed").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::AsyncStatus::Completed)));
    Nan::Set(enumObject, Nan::New<String>("canceled").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::AsyncStatus::Canceled)));
    Nan::Set(enumObject, Nan::New<String>("error").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::AsyncStatus::Error)));
  }

  static void InitPropertyTypeEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("PropertyType").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("empty").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Empty)));
    Nan::Set(enumObject, Nan::New<String>("uInt8").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::UInt8)));
    Nan::Set(enumObject, Nan::New<String>("int16").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Int16)));
    Nan::Set(enumObject, Nan::New<String>("uInt16").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::UInt16)));
    Nan::Set(enumObject, Nan::New<String>("int32").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Int32)));
    Nan::Set(enumObject, Nan::New<String>("uInt32").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::UInt32)));
    Nan::Set(enumObject, Nan::New<String>("int64").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Int64)));
    Nan::Set(enumObject, Nan::New<String>("uInt64").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::UInt64)));
    Nan::Set(enumObject, Nan::New<String>("single").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Single)));
    Nan::Set(enumObject, Nan::New<String>("double").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Double)));
    Nan::Set(enumObject, Nan::New<String>("char16").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Char16)));
    Nan::Set(enumObject, Nan::New<String>("boolean").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Boolean)));
    Nan::Set(enumObject, Nan::New<String>("string").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::String)));
    Nan::Set(enumObject, Nan::New<String>("inspectable").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Inspectable)));
    Nan::Set(enumObject, Nan::New<String>("dateTime").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::DateTime)));
    Nan::Set(enumObject, Nan::New<String>("timeSpan").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::TimeSpan)));
    Nan::Set(enumObject, Nan::New<String>("guid").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Guid)));
    Nan::Set(enumObject, Nan::New<String>("point").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Point)));
    Nan::Set(enumObject, Nan::New<String>("size").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Size)));
    Nan::Set(enumObject, Nan::New<String>("rect").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Rect)));
    Nan::Set(enumObject, Nan::New<String>("otherType").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::OtherType)));
    Nan::Set(enumObject, Nan::New<String>("uInt8Array").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::UInt8Array)));
    Nan::Set(enumObject, Nan::New<String>("int16Array").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Int16Array)));
    Nan::Set(enumObject, Nan::New<String>("uInt16Array").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::UInt16Array)));
    Nan::Set(enumObject, Nan::New<String>("int32Array").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Int32Array)));
    Nan::Set(enumObject, Nan::New<String>("uInt32Array").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::UInt32Array)));
    Nan::Set(enumObject, Nan::New<String>("int64Array").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Int64Array)));
    Nan::Set(enumObject, Nan::New<String>("uInt64Array").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::UInt64Array)));
    Nan::Set(enumObject, Nan::New<String>("singleArray").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::SingleArray)));
    Nan::Set(enumObject, Nan::New<String>("doubleArray").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::DoubleArray)));
    Nan::Set(enumObject, Nan::New<String>("char16Array").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::Char16Array)));
    Nan::Set(enumObject, Nan::New<String>("booleanArray").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::BooleanArray)));
    Nan::Set(enumObject, Nan::New<String>("stringArray").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::StringArray)));
    Nan::Set(enumObject, Nan::New<String>("inspectableArray").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::InspectableArray)));
    Nan::Set(enumObject, Nan::New<String>("dateTimeArray").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::DateTimeArray)));
    Nan::Set(enumObject, Nan::New<String>("timeSpanArray").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::TimeSpanArray)));
    Nan::Set(enumObject, Nan::New<String>("guidArray").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::GuidArray)));
    Nan::Set(enumObject, Nan::New<String>("pointArray").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::PointArray)));
    Nan::Set(enumObject, Nan::New<String>("sizeArray").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::SizeArray)));
    Nan::Set(enumObject, Nan::New<String>("rectArray").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::RectArray)));
    Nan::Set(enumObject, Nan::New<String>("otherTypeArray").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Foundation::PropertyType::OtherTypeArray)));
  }

  static bool IsFoundationContractJsObject(Local<Value> value) {
    if (!value->IsObject()) {
      return false;
    }

    Local<String> symbol;
    Local<Object> obj = Nan::To<Object>(value).ToLocalChecked();

    return true;
  }

  ::Windows::Foundation::FoundationContract FoundationContractFromJsObject(Local<Value> value) {
    HandleScope scope;
    ::Windows::Foundation::FoundationContract returnValue;

    if (!value->IsObject()) {
      Nan::ThrowError(Nan::TypeError(NodeRT::Utils::NewString(L"Unexpected type, expected an object")));
      return returnValue;
    }

    Local<Object> obj = Nan::To<Object>(value).ToLocalChecked();
    Local<String> symbol;

    return returnValue;
  }

  Local<Value> FoundationContractToJsObject(::Windows::Foundation::FoundationContract value) {
    EscapableHandleScope scope;

    Local<Object> obj = Nan::New<Object>();


    return scope.Escape(obj);
  }
  static bool IsUniversalApiContractJsObject(Local<Value> value) {
    if (!value->IsObject()) {
      return false;
    }

    Local<String> symbol;
    Local<Object> obj = Nan::To<Object>(value).ToLocalChecked();

    return true;
  }

  ::Windows::Foundation::UniversalApiContract UniversalApiContractFromJsObject(Local<Value> value) {
    HandleScope scope;
    ::Windows::Foundation::UniversalApiContract returnValue;

    if (!value->IsObject()) {
      Nan::ThrowError(Nan::TypeError(NodeRT::Utils::NewString(L"Unexpected type, expected an object")));
      return returnValue;
    }

    Local<Object> obj = Nan::To<Object>(value).ToLocalChecked();
    Local<String> symbol;

    return returnValue;
  }

  Local<Value> UniversalApiContractToJsObject(::Windows::Foundation::UniversalApiContract value) {
    EscapableHandleScope scope;

    Local<Object> obj = Nan::New<Object>();


    return scope.Escape(obj);
  }


  class Deferral : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("Deferral").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "complete", Complete);
            Nan::SetPrototypeMethod(localRef, "close", Close);
          




        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("Deferral").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      Deferral(::Windows::Foundation::Deferral^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::Deferral^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Deferral^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::Deferral^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::DeferralCompletedHandler^>(info[0]))
      {
        try {
          ::Windows::Foundation::DeferralCompletedHandler^ arg0 = dynamic_cast<::Windows::Foundation::DeferralCompletedHandler^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          winRtInstance = ref new ::Windows::Foundation::Deferral(arg0);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      Deferral *wrapperInstance = new Deferral(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Deferral^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::Deferral^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::Deferral^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDeferral(winRtInstance));
    }


    static void Complete(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Deferral^>(info.This())) {
        return;
      }

      Deferral *wrapper = Deferral::Unwrap<Deferral>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Complete();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Deferral^>(info.This())) {
        return;
      }

      Deferral *wrapper = Deferral::Unwrap<Deferral>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }





    private:
      ::Windows::Foundation::Deferral^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDeferral(::Windows::Foundation::Deferral^ wintRtInstance);
      friend ::Windows::Foundation::Deferral^ UnwrapDeferral(Local<Value> value);
  };

  Persistent<FunctionTemplate> Deferral::s_constructorTemplate;

  v8::Local<v8::Value> WrapDeferral(::Windows::Foundation::Deferral^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(Deferral::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::Deferral^ UnwrapDeferral(Local<Value> value) {
     return Deferral::Unwrap<Deferral>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDeferral(Local<Object> exports) {
    Deferral::Init(exports);
  }

  class GuidHelper : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("GuidHelper").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "createNewGuid", CreateNewGuid);
        Nan::SetMethod(constructor, "equals", Equals);
        Nan::SetAccessor(constructor, Nan::New<String>("empty").ToLocalChecked(), EmptyGetter);


        Nan::Set(exports, Nan::New<String>("GuidHelper").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      GuidHelper(::Windows::Foundation::GuidHelper^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::GuidHelper^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::GuidHelper^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::GuidHelper^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      GuidHelper *wrapperInstance = new GuidHelper(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::GuidHelper^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::GuidHelper^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::GuidHelper^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapGuidHelper(winRtInstance));
    }





    static void CreateNewGuid(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Guid result;
          result = ::Windows::Foundation::GuidHelper::CreateNewGuid();
          info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void Equals(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 2
        && NodeRT::Utils::IsGuid(info[0])
        && NodeRT::Utils::IsGuid(info[1]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          ::Platform::Guid arg1 = NodeRT::Utils::GuidFromJs(info[1]);
          
          bool result;
          result = ::Windows::Foundation::GuidHelper::Equals(arg0, arg1);
          info.GetReturnValue().Set(Nan::New<Boolean>(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void EmptyGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      try
      {
        ::Platform::Guid result = ::Windows::Foundation::GuidHelper::Empty;
        info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      

    private:
      ::Windows::Foundation::GuidHelper^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapGuidHelper(::Windows::Foundation::GuidHelper^ wintRtInstance);
      friend ::Windows::Foundation::GuidHelper^ UnwrapGuidHelper(Local<Value> value);
  };

  Persistent<FunctionTemplate> GuidHelper::s_constructorTemplate;

  v8::Local<v8::Value> WrapGuidHelper(::Windows::Foundation::GuidHelper^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(GuidHelper::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::GuidHelper^ UnwrapGuidHelper(Local<Value> value) {
     return GuidHelper::Unwrap<GuidHelper>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitGuidHelper(Local<Object> exports) {
    GuidHelper::Init(exports);
  }

  class IAsyncAction : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IAsyncAction").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "getResults", GetResults);
          



          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("completed").ToLocalChecked(), CompletedGetter, CompletedSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IAsyncAction").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IAsyncAction(::Windows::Foundation::IAsyncAction^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::IAsyncAction^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncAction^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::IAsyncAction^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IAsyncAction *wrapperInstance = new IAsyncAction(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncAction^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::IAsyncAction^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::IAsyncAction^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIAsyncAction(winRtInstance));
    }


    static void GetResults(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncAction^>(info.This())) {
        return;
      }

      IAsyncAction *wrapper = IAsyncAction::Unwrap<IAsyncAction>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->GetResults();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void CompletedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncAction^>(info.This())) {
        return;
      }

      IAsyncAction *wrapper = IAsyncAction::Unwrap<IAsyncAction>(info.This());

      try  {
        ::Windows::Foundation::AsyncActionCompletedHandler^ result = wrapper->_instance->Completed;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation", "AsyncActionCompletedHandler", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CompletedSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::AsyncActionCompletedHandler^>(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncAction^>(info.This())) {
        return;
      }

      IAsyncAction *wrapper = IAsyncAction::Unwrap<IAsyncAction>(info.This());

      try {

        ::Windows::Foundation::AsyncActionCompletedHandler^ winRtValue = dynamic_cast<::Windows::Foundation::AsyncActionCompletedHandler^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->Completed = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Foundation::IAsyncAction^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIAsyncAction(::Windows::Foundation::IAsyncAction^ wintRtInstance);
      friend ::Windows::Foundation::IAsyncAction^ UnwrapIAsyncAction(Local<Value> value);
  };

  Persistent<FunctionTemplate> IAsyncAction::s_constructorTemplate;

  v8::Local<v8::Value> WrapIAsyncAction(::Windows::Foundation::IAsyncAction^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IAsyncAction::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::IAsyncAction^ UnwrapIAsyncAction(Local<Value> value) {
     return IAsyncAction::Unwrap<IAsyncAction>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIAsyncAction(Local<Object> exports) {
    IAsyncAction::Init(exports);
  }

  class IAsyncInfo : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IAsyncInfo").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "cancel", Cancel);
            Nan::SetPrototypeMethod(localRef, "close", Close);
          



          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("errorCode").ToLocalChecked(), ErrorCodeGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("id").ToLocalChecked(), IdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IAsyncInfo").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IAsyncInfo(::Windows::Foundation::IAsyncInfo^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::IAsyncInfo^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::IAsyncInfo^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IAsyncInfo *wrapperInstance = new IAsyncInfo(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::IAsyncInfo^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::IAsyncInfo^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIAsyncInfo(winRtInstance));
    }


    static void Cancel(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(info.This())) {
        return;
      }

      IAsyncInfo *wrapper = IAsyncInfo::Unwrap<IAsyncInfo>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Cancel();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(info.This())) {
        return;
      }

      IAsyncInfo *wrapper = IAsyncInfo::Unwrap<IAsyncInfo>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Close();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void ErrorCodeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(info.This())) {
        return;
      }

      IAsyncInfo *wrapper = IAsyncInfo::Unwrap<IAsyncInfo>(info.This());

      try  {
        ::Windows::Foundation::HResult result = wrapper->_instance->ErrorCode;
        info.GetReturnValue().Set(Nan::New<Integer>(result.Value));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(info.This())) {
        return;
      }

      IAsyncInfo *wrapper = IAsyncInfo::Unwrap<IAsyncInfo>(info.This());

      try  {
        unsigned int result = wrapper->_instance->Id;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(info.This())) {
        return;
      }

      IAsyncInfo *wrapper = IAsyncInfo::Unwrap<IAsyncInfo>(info.This());

      try  {
        ::Windows::Foundation::AsyncStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Foundation::IAsyncInfo^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIAsyncInfo(::Windows::Foundation::IAsyncInfo^ wintRtInstance);
      friend ::Windows::Foundation::IAsyncInfo^ UnwrapIAsyncInfo(Local<Value> value);
  };

  Persistent<FunctionTemplate> IAsyncInfo::s_constructorTemplate;

  v8::Local<v8::Value> WrapIAsyncInfo(::Windows::Foundation::IAsyncInfo^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IAsyncInfo::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::IAsyncInfo^ UnwrapIAsyncInfo(Local<Value> value) {
     return IAsyncInfo::Unwrap<IAsyncInfo>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIAsyncInfo(Local<Object> exports) {
    IAsyncInfo::Init(exports);
  }

  class IGetActivationFactory : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IGetActivationFactory").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "getActivationFactory", GetActivationFactory);
          




        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IGetActivationFactory").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IGetActivationFactory(::Windows::Foundation::IGetActivationFactory^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::IGetActivationFactory^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IGetActivationFactory^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::IGetActivationFactory^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IGetActivationFactory *wrapperInstance = new IGetActivationFactory(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IGetActivationFactory^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::IGetActivationFactory^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::IGetActivationFactory^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIGetActivationFactory(winRtInstance));
    }


    static void GetActivationFactory(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IGetActivationFactory^>(info.This())) {
        return;
      }

      IGetActivationFactory *wrapper = IGetActivationFactory::Unwrap<IGetActivationFactory>(info.This());

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          ::Platform::Object^ result;
          result = wrapper->_instance->GetActivationFactory(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }





    private:
      ::Windows::Foundation::IGetActivationFactory^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIGetActivationFactory(::Windows::Foundation::IGetActivationFactory^ wintRtInstance);
      friend ::Windows::Foundation::IGetActivationFactory^ UnwrapIGetActivationFactory(Local<Value> value);
  };

  Persistent<FunctionTemplate> IGetActivationFactory::s_constructorTemplate;

  v8::Local<v8::Value> WrapIGetActivationFactory(::Windows::Foundation::IGetActivationFactory^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IGetActivationFactory::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::IGetActivationFactory^ UnwrapIGetActivationFactory(Local<Value> value) {
     return IGetActivationFactory::Unwrap<IGetActivationFactory>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIGetActivationFactory(Local<Object> exports) {
    IGetActivationFactory::Init(exports);
  }

  class IMemoryBuffer : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IMemoryBuffer").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "createReference", CreateReference);
          




        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IMemoryBuffer").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IMemoryBuffer(::Windows::Foundation::IMemoryBuffer^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::IMemoryBuffer^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IMemoryBuffer^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::IMemoryBuffer^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IMemoryBuffer *wrapperInstance = new IMemoryBuffer(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IMemoryBuffer^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::IMemoryBuffer^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::IMemoryBuffer^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIMemoryBuffer(winRtInstance));
    }


    static void CreateReference(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IMemoryBuffer^>(info.This())) {
        return;
      }

      IMemoryBuffer *wrapper = IMemoryBuffer::Unwrap<IMemoryBuffer>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::IMemoryBufferReference^ result;
          result = wrapper->_instance->CreateReference();
          info.GetReturnValue().Set(WrapIMemoryBufferReference(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }





    private:
      ::Windows::Foundation::IMemoryBuffer^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIMemoryBuffer(::Windows::Foundation::IMemoryBuffer^ wintRtInstance);
      friend ::Windows::Foundation::IMemoryBuffer^ UnwrapIMemoryBuffer(Local<Value> value);
  };

  Persistent<FunctionTemplate> IMemoryBuffer::s_constructorTemplate;

  v8::Local<v8::Value> WrapIMemoryBuffer(::Windows::Foundation::IMemoryBuffer^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IMemoryBuffer::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::IMemoryBuffer^ UnwrapIMemoryBuffer(Local<Value> value) {
     return IMemoryBuffer::Unwrap<IMemoryBuffer>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIMemoryBuffer(Local<Object> exports) {
    IMemoryBuffer::Init(exports);
  }

  class IMemoryBufferReference : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IMemoryBufferReference").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);




          
          Nan::SetPrototypeMethod(localRef,"addListener", AddListener);
          Nan::SetPrototypeMethod(localRef,"on", AddListener);
          Nan::SetPrototypeMethod(localRef,"removeListener", RemoveListener);
          Nan::SetPrototypeMethod(localRef, "off", RemoveListener);

          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("capacity").ToLocalChecked(), CapacityGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IMemoryBufferReference").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IMemoryBufferReference(::Windows::Foundation::IMemoryBufferReference^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::IMemoryBufferReference^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IMemoryBufferReference^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::IMemoryBufferReference^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IMemoryBufferReference *wrapperInstance = new IMemoryBufferReference(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IMemoryBufferReference^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::IMemoryBufferReference^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::IMemoryBufferReference^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIMemoryBufferReference(winRtInstance));
    }





    static void CapacityGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IMemoryBufferReference^>(info.This())) {
        return;
      }

      IMemoryBufferReference *wrapper = IMemoryBufferReference::Unwrap<IMemoryBufferReference>(info.This());

      try  {
        unsigned int result = wrapper->_instance->Capacity;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    static void AddListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      Local<Function> callback = info[1].As<Function>();

      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"closed", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IMemoryBufferReference^>(info.This()))
        {
          Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
      return;
        }
        IMemoryBufferReference *wrapper = IMemoryBufferReference::Unwrap<IMemoryBufferReference>(info.This());
      
        try {
          Persistent<Object>* perstPtr = new Persistent<Object>();
          perstPtr->Reset(NodeRT::Utils::CreateCallbackObjectInDomain(callback));
          std::shared_ptr<Persistent<Object>> callbackObjPtr(perstPtr,
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Reset();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->Closed::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Foundation::IMemoryBufferReference^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Foundation::IMemoryBufferReference^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                HandleScope scope;


                Local<Value> wrappedArg0;
                Local<Value> wrappedArg1;

                {
                  TryCatch tryCatch;


                  wrappedArg0 = WrapIMemoryBufferReference(arg0);
                  wrappedArg1 = CreateOpaqueWrapper(arg1);


                  if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                  if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();
                }

                Local<Value> args[] = { wrappedArg0, wrappedArg1 };
                Local<Object> callbackObjLocalRef = Nan::New<Object>(*callbackObjPtr);
                NodeRT::Utils::CallCallbackInDomain(callbackObjLocalRef, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }

      }
 else  {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Value> tokenMapVal = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());
      Local<Object> tokenMap;

      if (tokenMapVal.IsEmpty() || Nan::Equals(tokenMapVal, Undefined()).FromMaybe(false)) {
        tokenMap = Nan::New<Object>();
        NodeRT::Utils::SetHiddenValueWithObject(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked(), tokenMap);
      } else {
        tokenMap = Nan::To<Object>(tokenMapVal).ToLocalChecked();
      }

      Nan::Set(tokenMap, info[0], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
    }

    static void RemoveListener(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() < 2 || !info[0]->IsString() || !info[1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return;
      }

      String::Value eventName(v8::Isolate::GetCurrent(), info[0]);
      auto str = *eventName;

      if ((!NodeRT::Utils::CaseInsenstiveEquals(L"closed", str))) {
        Nan::ThrowError(Nan::Error(String::Concat(v8::Isolate::GetCurrent(), NodeRT::Utils::NewString(L"given event name isn't supported: "), info[0].As<String>())));
        return;
      }

      Local<Function> callback = info[1].As<Function>();
      Local<Value> tokenMap = NodeRT::Utils::GetHiddenValue(callback, Nan::New<String>(REGISTRATION_TOKEN_MAP_PROPERTY_NAME).ToLocalChecked());

      if (tokenMap.IsEmpty() || Nan::Equals(tokenMap, Undefined()).FromMaybe(false)) {
        return;
      }

      Local<Value> opaqueWrapperObj =  Nan::Get(Nan::To<Object>(tokenMap).ToLocalChecked(), info[0]).ToLocalChecked();

      if (opaqueWrapperObj.IsEmpty() || Nan::Equals(opaqueWrapperObj,Undefined()).FromMaybe(false)) {
        return;
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());

      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;

      try  {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"closed", str)) {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IMemoryBufferReference^>(info.This()))
          {
            Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return;
          }
          IMemoryBufferReference *wrapper = IMemoryBufferReference::Unwrap<IMemoryBufferReference>(info.This());
          wrapper->_instance->Closed::remove(registrationToken);
        }
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      Nan::Delete(Nan::To<Object>(tokenMap).ToLocalChecked(), Nan::To<String>(info[0]).ToLocalChecked());
    }
    private:
      ::Windows::Foundation::IMemoryBufferReference^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIMemoryBufferReference(::Windows::Foundation::IMemoryBufferReference^ wintRtInstance);
      friend ::Windows::Foundation::IMemoryBufferReference^ UnwrapIMemoryBufferReference(Local<Value> value);
  };

  Persistent<FunctionTemplate> IMemoryBufferReference::s_constructorTemplate;

  v8::Local<v8::Value> WrapIMemoryBufferReference(::Windows::Foundation::IMemoryBufferReference^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IMemoryBufferReference::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::IMemoryBufferReference^ UnwrapIMemoryBufferReference(Local<Value> value) {
     return IMemoryBufferReference::Unwrap<IMemoryBufferReference>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIMemoryBufferReference(Local<Object> exports) {
    IMemoryBufferReference::Init(exports);
  }

  class IStringable : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IStringable").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "toString", ToString);
          




        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IStringable").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IStringable(::Windows::Foundation::IStringable^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::IStringable^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IStringable^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::IStringable^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IStringable *wrapperInstance = new IStringable(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IStringable^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::IStringable^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::IStringable^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIStringable(winRtInstance));
    }


    static void ToString(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IStringable^>(info.This())) {
        return;
      }

      IStringable *wrapper = IStringable::Unwrap<IStringable>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          Platform::String^ result;
          result = wrapper->_instance->ToString();
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }





    private:
      ::Windows::Foundation::IStringable^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIStringable(::Windows::Foundation::IStringable^ wintRtInstance);
      friend ::Windows::Foundation::IStringable^ UnwrapIStringable(Local<Value> value);
  };

  Persistent<FunctionTemplate> IStringable::s_constructorTemplate;

  v8::Local<v8::Value> WrapIStringable(::Windows::Foundation::IStringable^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IStringable::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::IStringable^ UnwrapIStringable(Local<Value> value) {
     return IStringable::Unwrap<IStringable>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIStringable(Local<Object> exports) {
    IStringable::Init(exports);
  }

  class IWwwFormUrlDecoderEntry : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IWwwFormUrlDecoderEntry").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("name").ToLocalChecked(), NameGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("value").ToLocalChecked(), ValueGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IWwwFormUrlDecoderEntry").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IWwwFormUrlDecoderEntry(::Windows::Foundation::IWwwFormUrlDecoderEntry^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::IWwwFormUrlDecoderEntry^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IWwwFormUrlDecoderEntry^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::IWwwFormUrlDecoderEntry^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IWwwFormUrlDecoderEntry *wrapperInstance = new IWwwFormUrlDecoderEntry(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IWwwFormUrlDecoderEntry^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::IWwwFormUrlDecoderEntry^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::IWwwFormUrlDecoderEntry^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIWwwFormUrlDecoderEntry(winRtInstance));
    }





    static void NameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IWwwFormUrlDecoderEntry^>(info.This())) {
        return;
      }

      IWwwFormUrlDecoderEntry *wrapper = IWwwFormUrlDecoderEntry::Unwrap<IWwwFormUrlDecoderEntry>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Name;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ValueGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IWwwFormUrlDecoderEntry^>(info.This())) {
        return;
      }

      IWwwFormUrlDecoderEntry *wrapper = IWwwFormUrlDecoderEntry::Unwrap<IWwwFormUrlDecoderEntry>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Value;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Foundation::IWwwFormUrlDecoderEntry^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIWwwFormUrlDecoderEntry(::Windows::Foundation::IWwwFormUrlDecoderEntry^ wintRtInstance);
      friend ::Windows::Foundation::IWwwFormUrlDecoderEntry^ UnwrapIWwwFormUrlDecoderEntry(Local<Value> value);
  };

  Persistent<FunctionTemplate> IWwwFormUrlDecoderEntry::s_constructorTemplate;

  v8::Local<v8::Value> WrapIWwwFormUrlDecoderEntry(::Windows::Foundation::IWwwFormUrlDecoderEntry^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IWwwFormUrlDecoderEntry::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::IWwwFormUrlDecoderEntry^ UnwrapIWwwFormUrlDecoderEntry(Local<Value> value) {
     return IWwwFormUrlDecoderEntry::Unwrap<IWwwFormUrlDecoderEntry>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIWwwFormUrlDecoderEntry(Local<Object> exports) {
    IWwwFormUrlDecoderEntry::Init(exports);
  }

  class MemoryBuffer : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("MemoryBuffer").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "createReference", CreateReference);
            Nan::SetPrototypeMethod(localRef, "close", Close);
          




        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("MemoryBuffer").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      MemoryBuffer(::Windows::Foundation::MemoryBuffer^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::MemoryBuffer^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::MemoryBuffer^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::MemoryBuffer^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          winRtInstance = ref new ::Windows::Foundation::MemoryBuffer(arg0);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      MemoryBuffer *wrapperInstance = new MemoryBuffer(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::MemoryBuffer^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::MemoryBuffer^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::MemoryBuffer^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapMemoryBuffer(winRtInstance));
    }


    static void CreateReference(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::MemoryBuffer^>(info.This())) {
        return;
      }

      MemoryBuffer *wrapper = MemoryBuffer::Unwrap<MemoryBuffer>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::IMemoryBufferReference^ result;
          result = wrapper->_instance->CreateReference();
          info.GetReturnValue().Set(WrapIMemoryBufferReference(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::MemoryBuffer^>(info.This())) {
        return;
      }

      MemoryBuffer *wrapper = MemoryBuffer::Unwrap<MemoryBuffer>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }





    private:
      ::Windows::Foundation::MemoryBuffer^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapMemoryBuffer(::Windows::Foundation::MemoryBuffer^ wintRtInstance);
      friend ::Windows::Foundation::MemoryBuffer^ UnwrapMemoryBuffer(Local<Value> value);
  };

  Persistent<FunctionTemplate> MemoryBuffer::s_constructorTemplate;

  v8::Local<v8::Value> WrapMemoryBuffer(::Windows::Foundation::MemoryBuffer^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(MemoryBuffer::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::MemoryBuffer^ UnwrapMemoryBuffer(Local<Value> value) {
     return MemoryBuffer::Unwrap<MemoryBuffer>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitMemoryBuffer(Local<Object> exports) {
    MemoryBuffer::Init(exports);
  }

  class PropertyValue : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("PropertyValue").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "createEmpty", CreateEmpty);
        Nan::SetMethod(constructor, "createUInt8", CreateUInt8);
        Nan::SetMethod(constructor, "createInt16", CreateInt16);
        Nan::SetMethod(constructor, "createUInt16", CreateUInt16);
        Nan::SetMethod(constructor, "createInt32", CreateInt32);
        Nan::SetMethod(constructor, "createUInt32", CreateUInt32);
        Nan::SetMethod(constructor, "createInt64", CreateInt64);
        Nan::SetMethod(constructor, "createUInt64", CreateUInt64);
        Nan::SetMethod(constructor, "createSingle", CreateSingle);
        Nan::SetMethod(constructor, "createDouble", CreateDouble);
        Nan::SetMethod(constructor, "createChar16", CreateChar16);
        Nan::SetMethod(constructor, "createBoolean", CreateBoolean);
        Nan::SetMethod(constructor, "createString", CreateString);
        Nan::SetMethod(constructor, "createInspectable", CreateInspectable);
        Nan::SetMethod(constructor, "createGuid", CreateGuid);
        Nan::SetMethod(constructor, "createDateTime", CreateDateTime);
        Nan::SetMethod(constructor, "createTimeSpan", CreateTimeSpan);
        Nan::SetMethod(constructor, "createPoint", CreatePoint);
        Nan::SetMethod(constructor, "createSize", CreateSize);
        Nan::SetMethod(constructor, "createRect", CreateRect);
        Nan::SetMethod(constructor, "createUInt8Array", CreateUInt8Array);
        Nan::SetMethod(constructor, "createInt16Array", CreateInt16Array);
        Nan::SetMethod(constructor, "createUInt16Array", CreateUInt16Array);
        Nan::SetMethod(constructor, "createInt32Array", CreateInt32Array);
        Nan::SetMethod(constructor, "createUInt32Array", CreateUInt32Array);
        Nan::SetMethod(constructor, "createInt64Array", CreateInt64Array);
        Nan::SetMethod(constructor, "createUInt64Array", CreateUInt64Array);
        Nan::SetMethod(constructor, "createSingleArray", CreateSingleArray);
        Nan::SetMethod(constructor, "createDoubleArray", CreateDoubleArray);
        Nan::SetMethod(constructor, "createChar16Array", CreateChar16Array);
        Nan::SetMethod(constructor, "createBooleanArray", CreateBooleanArray);
        Nan::SetMethod(constructor, "createStringArray", CreateStringArray);
        Nan::SetMethod(constructor, "createInspectableArray", CreateInspectableArray);
        Nan::SetMethod(constructor, "createGuidArray", CreateGuidArray);
        Nan::SetMethod(constructor, "createDateTimeArray", CreateDateTimeArray);
        Nan::SetMethod(constructor, "createTimeSpanArray", CreateTimeSpanArray);
        Nan::SetMethod(constructor, "createPointArray", CreatePointArray);
        Nan::SetMethod(constructor, "createSizeArray", CreateSizeArray);
        Nan::SetMethod(constructor, "createRectArray", CreateRectArray);


        Nan::Set(exports, Nan::New<String>("PropertyValue").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      PropertyValue(::Windows::Foundation::PropertyValue^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::PropertyValue^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::PropertyValue^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::PropertyValue^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      PropertyValue *wrapperInstance = new PropertyValue(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::PropertyValue^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::PropertyValue^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::PropertyValue^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapPropertyValue(winRtInstance));
    }





    static void CreateEmpty(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateEmpty();
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateUInt8(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned char arg0 = static_cast<unsigned char>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt8(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateInt16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          short arg0 = static_cast<short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInt16(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateUInt16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt16(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateInt32(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          int arg0 = static_cast<int>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInt32(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateUInt32(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt32(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateInt64(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          __int64 arg0 = Nan::To<int64_t>(info[0]).FromMaybe(0);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInt64(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateUInt64(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt64(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateSingle(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          float arg0 = static_cast<float>(Nan::To<double>(info[0]).FromMaybe(0.0));
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateSingle(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateDouble(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          double arg0 = Nan::To<double>(info[0]).FromMaybe(0.0);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateDouble(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateChar16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          wchar_t arg0 = NodeRT::Utils::GetFirstChar(info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateChar16(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateBoolean(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsBoolean())
      {
        try
        {
          bool arg0 = Nan::To<bool>(info[0]).FromMaybe(false);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateBoolean(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateString(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateString(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateInspectable(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(info[0]))
      {
        try
        {
          ::Platform::Object^ arg0 = dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInspectable(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateGuid(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateGuid(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateDateTime(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsDate())
      {
        try
        {
          ::Windows::Foundation::DateTime arg0 = NodeRT::Utils::DateTimeFromJSDate(info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateDateTime(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateTimeSpan(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          ::Windows::Foundation::TimeSpan arg0 = NodeRT::Utils::TimeSpanFromMilli(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateTimeSpan(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreatePoint(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsPoint(info[0]))
      {
        try
        {
          ::Windows::Foundation::Point arg0 = NodeRT::Utils::PointFromJs(info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreatePoint(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateSize(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsSize(info[0]))
      {
        try
        {
          ::Windows::Foundation::Size arg0 = NodeRT::Utils::SizeFromJs(info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateSize(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateRect(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsRect(info[0]))
      {
        try
        {
          ::Windows::Foundation::Rect arg0 = NodeRT::Utils::RectFromJs(info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateRect(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateUInt8Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned char>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<unsigned char>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<unsigned char>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned char>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Local<Value> value) -> unsigned char {
                   return static_cast<unsigned char>(Nan::To<int32_t>(value).FromMaybe(0));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned char>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt8Array(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateInt16Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<short>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<short>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<short>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<short>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Local<Value> value) -> short {
                   return static_cast<short>(Nan::To<int32_t>(value).FromMaybe(0));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<short>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInt16Array(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateUInt16Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned short>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<unsigned short>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<unsigned short>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned short>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Local<Value> value) -> unsigned short {
                   return static_cast<unsigned short>(Nan::To<int32_t>(value).FromMaybe(0));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned short>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt16Array(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateInt32Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<int>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<int>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<int>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<int>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Local<Value> value) -> int {
                   return static_cast<int>(Nan::To<int32_t>(value).FromMaybe(0));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<int>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInt32Array(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateUInt32Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned int>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<unsigned int>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<unsigned int>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned int>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsUint32();
                 },
                 [](Local<Value> value) -> unsigned int {
                   return static_cast<unsigned int>(Nan::To<uint32_t>(value).FromMaybe(0));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned int>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt32Array(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateInt64Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<__int64>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<__int64>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<__int64>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<__int64>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsNumber();
                 },
                 [](Local<Value> value) -> __int64 {
                   return Nan::To<int64_t>(value).FromMaybe(0);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<__int64>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInt64Array(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateUInt64Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned __int64>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<unsigned __int64>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<unsigned __int64>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned __int64>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsNumber();
                 },
                 [](Local<Value> value) -> unsigned __int64 {
                   return static_cast<unsigned __int64>(Nan::To<int64_t>(value).FromMaybe(0));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned __int64>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt64Array(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateSingleArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<float>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<float>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<float>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<float>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsNumber();
                 },
                 [](Local<Value> value) -> float {
                   return static_cast<float>(Nan::To<double>(value).FromMaybe(0.0));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<float>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateSingleArray(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateDoubleArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<double>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<double>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<double>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<double>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsNumber();
                 },
                 [](Local<Value> value) -> double {
                   return Nan::To<double>(value).FromMaybe(0.0);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<double>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateDoubleArray(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateChar16Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<wchar_t>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<wchar_t>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<wchar_t>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<wchar_t>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsString();
                 },
                 [](Local<Value> value) -> wchar_t {
                   return NodeRT::Utils::GetFirstChar(value);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<wchar_t>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateChar16Array(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateBooleanArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<bool>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<bool>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<bool>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<bool>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsBoolean();
                 },
                 [](Local<Value> value) -> bool {
                   return Nan::To<bool>(value).FromMaybe(false);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<bool>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateBooleanArray(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateStringArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Platform::String^>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Platform::String^>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Platform::String^>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Local<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateStringArray(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateInspectableArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Platform::Object^>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Platform::Object^>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<::Platform::Object^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Platform::Object^>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
                 },
                 [](Local<Value> value) -> ::Platform::Object^ {
                   return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Platform::Object^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInspectableArray(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateGuidArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Platform::Guid>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Platform::Guid>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<::Platform::Guid>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Platform::Guid>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return NodeRT::Utils::IsGuid(value);
                 },
                 [](Local<Value> value) -> ::Platform::Guid {
                   return NodeRT::Utils::GuidFromJs(value);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Platform::Guid>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateGuidArray(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateDateTimeArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Windows::Foundation::DateTime>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::DateTime>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<::Windows::Foundation::DateTime>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Windows::Foundation::DateTime>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsDate();
                 },
                 [](Local<Value> value) -> ::Windows::Foundation::DateTime {
                   return NodeRT::Utils::DateTimeFromJSDate(value);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Windows::Foundation::DateTime>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateDateTimeArray(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateTimeSpanArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Windows::Foundation::TimeSpan>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::TimeSpan>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<::Windows::Foundation::TimeSpan>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Windows::Foundation::TimeSpan>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsNumber();
                 },
                 [](Local<Value> value) -> ::Windows::Foundation::TimeSpan {
                   return NodeRT::Utils::TimeSpanFromMilli(Nan::To<int64_t>(value).FromMaybe(0));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Windows::Foundation::TimeSpan>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateTimeSpanArray(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreatePointArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Windows::Foundation::Point>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::Point>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<::Windows::Foundation::Point>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Windows::Foundation::Point>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return NodeRT::Utils::IsPoint(value);
                 },
                 [](Local<Value> value) -> ::Windows::Foundation::Point {
                   return NodeRT::Utils::PointFromJs(value);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Windows::Foundation::Point>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreatePointArray(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateSizeArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Windows::Foundation::Size>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::Size>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<::Windows::Foundation::Size>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Windows::Foundation::Size>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return NodeRT::Utils::IsSize(value);
                 },
                 [](Local<Value> value) -> ::Windows::Foundation::Size {
                   return NodeRT::Utils::SizeFromJs(value);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Windows::Foundation::Size>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateSizeArray(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateRectArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Windows::Foundation::Rect>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::Rect>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<::Windows::Foundation::Rect>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Windows::Foundation::Rect>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return NodeRT::Utils::IsRect(value);
                 },
                 [](Local<Value> value) -> ::Windows::Foundation::Rect {
                   return NodeRT::Utils::RectFromJs(value);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Windows::Foundation::Rect>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateRectArray(arg0);
          info.GetReturnValue().Set(CreateOpaqueWrapper(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    private:
      ::Windows::Foundation::PropertyValue^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapPropertyValue(::Windows::Foundation::PropertyValue^ wintRtInstance);
      friend ::Windows::Foundation::PropertyValue^ UnwrapPropertyValue(Local<Value> value);
  };

  Persistent<FunctionTemplate> PropertyValue::s_constructorTemplate;

  v8::Local<v8::Value> WrapPropertyValue(::Windows::Foundation::PropertyValue^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(PropertyValue::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::PropertyValue^ UnwrapPropertyValue(Local<Value> value) {
     return PropertyValue::Unwrap<PropertyValue>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitPropertyValue(Local<Object> exports) {
    PropertyValue::Init(exports);
  }

  class WwwFormUrlDecoder : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("WwwFormUrlDecoder").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "getFirstValueByName", GetFirstValueByName);
            Nan::SetPrototypeMethod(localRef, "first", First);
            Nan::SetPrototypeMethod(localRef, "getAt", GetAt);
            Nan::SetPrototypeMethod(localRef, "indexOf", IndexOf);
            Nan::SetPrototypeMethod(localRef, "getMany", GetMany);
          




        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("WwwFormUrlDecoder").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      WwwFormUrlDecoder(::Windows::Foundation::WwwFormUrlDecoder^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::WwwFormUrlDecoder^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoder^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::WwwFormUrlDecoder^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && info[0]->IsString())
      {
        try {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          winRtInstance = ref new ::Windows::Foundation::WwwFormUrlDecoder(arg0);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      WwwFormUrlDecoder *wrapperInstance = new WwwFormUrlDecoder(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoder^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::WwwFormUrlDecoder^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::WwwFormUrlDecoder^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapWwwFormUrlDecoder(winRtInstance));
    }


    static void GetFirstValueByName(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoder^>(info.This())) {
        return;
      }

      WwwFormUrlDecoder *wrapper = WwwFormUrlDecoder::Unwrap<WwwFormUrlDecoder>(info.This());

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          Platform::String^ result;
          result = wrapper->_instance->GetFirstValueByName(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void First(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoder^>(info.This())) {
        return;
      }

      WwwFormUrlDecoder *wrapper = WwwFormUrlDecoder::Unwrap<WwwFormUrlDecoder>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Collections::IIterator<::Windows::Foundation::IWwwFormUrlDecoderEntry^>^ result;
          result = wrapper->_instance->First();
          info.GetReturnValue().Set(NodeRT::Collections::IteratorWrapper<::Windows::Foundation::IWwwFormUrlDecoderEntry^>::CreateIteratorWrapper(result, 
            [](::Windows::Foundation::IWwwFormUrlDecoderEntry^ val) -> Local<Value> {
              return WrapIWwwFormUrlDecoderEntry(val);
            }
          ));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetAt(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoder^>(info.This())) {
        return;
      }

      WwwFormUrlDecoder *wrapper = WwwFormUrlDecoder::Unwrap<WwwFormUrlDecoder>(info.This());

      if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          ::Windows::Foundation::IWwwFormUrlDecoderEntry^ result;
          result = wrapper->_instance->GetAt(arg0);
          info.GetReturnValue().Set(WrapIWwwFormUrlDecoderEntry(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void IndexOf(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoder^>(info.This())) {
        return;
      }

      WwwFormUrlDecoder *wrapper = WwwFormUrlDecoder::Unwrap<WwwFormUrlDecoder>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IWwwFormUrlDecoderEntry^>(info[0]))
      {
        try
        {
          ::Windows::Foundation::IWwwFormUrlDecoderEntry^ arg0 = UnwrapIWwwFormUrlDecoderEntry(info[0]);
          unsigned int arg1;
          
          bool result;
          result = wrapper->_instance->IndexOf(arg0, &arg1);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("boolean").ToLocalChecked(), Nan::New<Boolean>(result));
          Nan::Set(resObj, Nan::New<String>("index").ToLocalChecked(), Nan::New<Integer>(arg1));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetMany(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Not implemented")));
    }





    private:
      ::Windows::Foundation::WwwFormUrlDecoder^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapWwwFormUrlDecoder(::Windows::Foundation::WwwFormUrlDecoder^ wintRtInstance);
      friend ::Windows::Foundation::WwwFormUrlDecoder^ UnwrapWwwFormUrlDecoder(Local<Value> value);
  };

  Persistent<FunctionTemplate> WwwFormUrlDecoder::s_constructorTemplate;

  v8::Local<v8::Value> WrapWwwFormUrlDecoder(::Windows::Foundation::WwwFormUrlDecoder^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(WwwFormUrlDecoder::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::WwwFormUrlDecoder^ UnwrapWwwFormUrlDecoder(Local<Value> value) {
     return WwwFormUrlDecoder::Unwrap<WwwFormUrlDecoder>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitWwwFormUrlDecoder(Local<Object> exports) {
    WwwFormUrlDecoder::Init(exports);
  }

  class WwwFormUrlDecoderEntry : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("WwwFormUrlDecoderEntry").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("name").ToLocalChecked(), NameGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("value").ToLocalChecked(), ValueGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("WwwFormUrlDecoderEntry").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      WwwFormUrlDecoderEntry(::Windows::Foundation::WwwFormUrlDecoderEntry^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::WwwFormUrlDecoderEntry^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoderEntry^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::WwwFormUrlDecoderEntry^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      WwwFormUrlDecoderEntry *wrapperInstance = new WwwFormUrlDecoderEntry(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoderEntry^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::WwwFormUrlDecoderEntry^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::WwwFormUrlDecoderEntry^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapWwwFormUrlDecoderEntry(winRtInstance));
    }





    static void NameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoderEntry^>(info.This())) {
        return;
      }

      WwwFormUrlDecoderEntry *wrapper = WwwFormUrlDecoderEntry::Unwrap<WwwFormUrlDecoderEntry>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Name;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ValueGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoderEntry^>(info.This())) {
        return;
      }

      WwwFormUrlDecoderEntry *wrapper = WwwFormUrlDecoderEntry::Unwrap<WwwFormUrlDecoderEntry>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Value;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Foundation::WwwFormUrlDecoderEntry^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapWwwFormUrlDecoderEntry(::Windows::Foundation::WwwFormUrlDecoderEntry^ wintRtInstance);
      friend ::Windows::Foundation::WwwFormUrlDecoderEntry^ UnwrapWwwFormUrlDecoderEntry(Local<Value> value);
  };

  Persistent<FunctionTemplate> WwwFormUrlDecoderEntry::s_constructorTemplate;

  v8::Local<v8::Value> WrapWwwFormUrlDecoderEntry(::Windows::Foundation::WwwFormUrlDecoderEntry^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(WwwFormUrlDecoderEntry::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::WwwFormUrlDecoderEntry^ UnwrapWwwFormUrlDecoderEntry(Local<Value> value) {
     return WwwFormUrlDecoderEntry::Unwrap<WwwFormUrlDecoderEntry>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitWwwFormUrlDecoderEntry(Local<Object> exports) {
    WwwFormUrlDecoderEntry::Init(exports);
  }

  class IPropertyValue : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IPropertyValue").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "getUInt8", GetUInt8);
            Nan::SetPrototypeMethod(localRef, "getInt16", GetInt16);
            Nan::SetPrototypeMethod(localRef, "getUInt16", GetUInt16);
            Nan::SetPrototypeMethod(localRef, "getInt32", GetInt32);
            Nan::SetPrototypeMethod(localRef, "getUInt32", GetUInt32);
            Nan::SetPrototypeMethod(localRef, "getInt64", GetInt64);
            Nan::SetPrototypeMethod(localRef, "getUInt64", GetUInt64);
            Nan::SetPrototypeMethod(localRef, "getSingle", GetSingle);
            Nan::SetPrototypeMethod(localRef, "getDouble", GetDouble);
            Nan::SetPrototypeMethod(localRef, "getChar16", GetChar16);
            Nan::SetPrototypeMethod(localRef, "getBoolean", GetBoolean);
            Nan::SetPrototypeMethod(localRef, "getString", GetString);
            Nan::SetPrototypeMethod(localRef, "getGuid", GetGuid);
            Nan::SetPrototypeMethod(localRef, "getDateTime", GetDateTime);
            Nan::SetPrototypeMethod(localRef, "getTimeSpan", GetTimeSpan);
            Nan::SetPrototypeMethod(localRef, "getPoint", GetPoint);
            Nan::SetPrototypeMethod(localRef, "getSize", GetSize);
            Nan::SetPrototypeMethod(localRef, "getRect", GetRect);
            Nan::SetPrototypeMethod(localRef, "getUInt8Array", GetUInt8Array);
            Nan::SetPrototypeMethod(localRef, "getInt16Array", GetInt16Array);
            Nan::SetPrototypeMethod(localRef, "getUInt16Array", GetUInt16Array);
            Nan::SetPrototypeMethod(localRef, "getInt32Array", GetInt32Array);
            Nan::SetPrototypeMethod(localRef, "getUInt32Array", GetUInt32Array);
            Nan::SetPrototypeMethod(localRef, "getInt64Array", GetInt64Array);
            Nan::SetPrototypeMethod(localRef, "getUInt64Array", GetUInt64Array);
            Nan::SetPrototypeMethod(localRef, "getSingleArray", GetSingleArray);
            Nan::SetPrototypeMethod(localRef, "getDoubleArray", GetDoubleArray);
            Nan::SetPrototypeMethod(localRef, "getChar16Array", GetChar16Array);
            Nan::SetPrototypeMethod(localRef, "getBooleanArray", GetBooleanArray);
            Nan::SetPrototypeMethod(localRef, "getStringArray", GetStringArray);
            Nan::SetPrototypeMethod(localRef, "getInspectableArray", GetInspectableArray);
            Nan::SetPrototypeMethod(localRef, "getGuidArray", GetGuidArray);
            Nan::SetPrototypeMethod(localRef, "getDateTimeArray", GetDateTimeArray);
            Nan::SetPrototypeMethod(localRef, "getTimeSpanArray", GetTimeSpanArray);
            Nan::SetPrototypeMethod(localRef, "getPointArray", GetPointArray);
            Nan::SetPrototypeMethod(localRef, "getSizeArray", GetSizeArray);
            Nan::SetPrototypeMethod(localRef, "getRectArray", GetRectArray);
          



          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("isNumericScalar").ToLocalChecked(), IsNumericScalarGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("type").ToLocalChecked(), TypeGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IPropertyValue").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IPropertyValue(::Windows::Foundation::IPropertyValue^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::IPropertyValue^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::IPropertyValue^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IPropertyValue *wrapperInstance = new IPropertyValue(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::IPropertyValue^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::IPropertyValue^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIPropertyValue(winRtInstance));
    }


    static void GetUInt8(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned char result;
          result = wrapper->_instance->GetUInt8();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetInt16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          short result;
          result = wrapper->_instance->GetInt16();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetUInt16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned short result;
          result = wrapper->_instance->GetUInt16();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetInt32(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          int result;
          result = wrapper->_instance->GetInt32();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetUInt32(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned int result;
          result = wrapper->_instance->GetUInt32();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetInt64(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          __int64 result;
          result = wrapper->_instance->GetInt64();
          info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetUInt64(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned __int64 result;
          result = wrapper->_instance->GetUInt64();
          info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetSingle(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          float result;
          result = wrapper->_instance->GetSingle();
          info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetDouble(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          double result;
          result = wrapper->_instance->GetDouble();
          info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetChar16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wchar_t result;
          result = wrapper->_instance->GetChar16();
          info.GetReturnValue().Set(NodeRT::Utils::JsStringFromChar(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetBoolean(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          bool result;
          result = wrapper->_instance->GetBoolean();
          info.GetReturnValue().Set(Nan::New<Boolean>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetString(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          Platform::String^ result;
          result = wrapper->_instance->GetString();
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetGuid(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Guid result;
          result = wrapper->_instance->GetGuid();
          info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetDateTime(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::DateTime result;
          result = wrapper->_instance->GetDateTime();
          info.GetReturnValue().Set(NodeRT::Utils::DateTimeToJS(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetTimeSpan(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::TimeSpan result;
          result = wrapper->_instance->GetTimeSpan();
          info.GetReturnValue().Set(Nan::New<Number>(result.Duration/10000.0));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetPoint(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Point result;
          result = wrapper->_instance->GetPoint();
          info.GetReturnValue().Set(NodeRT::Utils::PointToJs(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetSize(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Size result;
          result = wrapper->_instance->GetSize();
          info.GetReturnValue().Set(NodeRT::Utils::SizeToJs(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetRect(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Rect result;
          result = wrapper->_instance->GetRect();
          info.GetReturnValue().Set(NodeRT::Utils::RectToJs(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetUInt8Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<unsigned char>^ arg0;
          
          wrapper->_instance->GetUInt8Array(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<unsigned char>::CreateArrayWrapper(arg0, 
            [](unsigned char val) -> Local<Value> {
              return Nan::New<Integer>(val);
            },
            [](Local<Value> value) -> bool {
              return value->IsInt32();
            },
            [](Local<Value> value) -> unsigned char {
              return static_cast<unsigned char>(Nan::To<int32_t>(value).FromMaybe(0));
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetInt16Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<short>^ arg0;
          
          wrapper->_instance->GetInt16Array(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<short>::CreateArrayWrapper(arg0, 
            [](short val) -> Local<Value> {
              return Nan::New<Integer>(val);
            },
            [](Local<Value> value) -> bool {
              return value->IsInt32();
            },
            [](Local<Value> value) -> short {
              return static_cast<short>(Nan::To<int32_t>(value).FromMaybe(0));
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetUInt16Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<unsigned short>^ arg0;
          
          wrapper->_instance->GetUInt16Array(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<unsigned short>::CreateArrayWrapper(arg0, 
            [](unsigned short val) -> Local<Value> {
              return Nan::New<Integer>(val);
            },
            [](Local<Value> value) -> bool {
              return value->IsInt32();
            },
            [](Local<Value> value) -> unsigned short {
              return static_cast<unsigned short>(Nan::To<int32_t>(value).FromMaybe(0));
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetInt32Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<int>^ arg0;
          
          wrapper->_instance->GetInt32Array(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<int>::CreateArrayWrapper(arg0, 
            [](int val) -> Local<Value> {
              return Nan::New<Integer>(val);
            },
            [](Local<Value> value) -> bool {
              return value->IsInt32();
            },
            [](Local<Value> value) -> int {
              return static_cast<int>(Nan::To<int32_t>(value).FromMaybe(0));
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetUInt32Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<unsigned int>^ arg0;
          
          wrapper->_instance->GetUInt32Array(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<unsigned int>::CreateArrayWrapper(arg0, 
            [](unsigned int val) -> Local<Value> {
              return Nan::New<Integer>(val);
            },
            [](Local<Value> value) -> bool {
              return value->IsUint32();
            },
            [](Local<Value> value) -> unsigned int {
              return static_cast<unsigned int>(Nan::To<uint32_t>(value).FromMaybe(0));
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetInt64Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<__int64>^ arg0;
          
          wrapper->_instance->GetInt64Array(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<__int64>::CreateArrayWrapper(arg0, 
            [](__int64 val) -> Local<Value> {
              return Nan::New<Number>(static_cast<double>(val));
            },
            [](Local<Value> value) -> bool {
              return value->IsNumber();
            },
            [](Local<Value> value) -> __int64 {
              return Nan::To<int64_t>(value).FromMaybe(0);
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetUInt64Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<unsigned __int64>^ arg0;
          
          wrapper->_instance->GetUInt64Array(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<unsigned __int64>::CreateArrayWrapper(arg0, 
            [](unsigned __int64 val) -> Local<Value> {
              return Nan::New<Number>(static_cast<double>(val));
            },
            [](Local<Value> value) -> bool {
              return value->IsNumber();
            },
            [](Local<Value> value) -> unsigned __int64 {
              return static_cast<unsigned __int64>(Nan::To<int64_t>(value).FromMaybe(0));
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetSingleArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<float>^ arg0;
          
          wrapper->_instance->GetSingleArray(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<float>::CreateArrayWrapper(arg0, 
            [](float val) -> Local<Value> {
              return Nan::New<Number>(static_cast<double>(val));
            },
            [](Local<Value> value) -> bool {
              return value->IsNumber();
            },
            [](Local<Value> value) -> float {
              return static_cast<float>(Nan::To<double>(value).FromMaybe(0.0));
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetDoubleArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<double>^ arg0;
          
          wrapper->_instance->GetDoubleArray(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<double>::CreateArrayWrapper(arg0, 
            [](double val) -> Local<Value> {
              return Nan::New<Number>(static_cast<double>(val));
            },
            [](Local<Value> value) -> bool {
              return value->IsNumber();
            },
            [](Local<Value> value) -> double {
              return Nan::To<double>(value).FromMaybe(0.0);
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetChar16Array(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<wchar_t>^ arg0;
          
          wrapper->_instance->GetChar16Array(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<wchar_t>::CreateArrayWrapper(arg0, 
            [](wchar_t val) -> Local<Value> {
              return NodeRT::Utils::JsStringFromChar(val);
            },
            [](Local<Value> value) -> bool {
              return value->IsString();
            },
            [](Local<Value> value) -> wchar_t {
              return NodeRT::Utils::GetFirstChar(value);
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetBooleanArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<bool>^ arg0;
          
          wrapper->_instance->GetBooleanArray(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<bool>::CreateArrayWrapper(arg0, 
            [](bool val) -> Local<Value> {
              return Nan::New<Boolean>(val);
            },
            [](Local<Value> value) -> bool {
              return value->IsBoolean();
            },
            [](Local<Value> value) -> bool {
              return Nan::To<bool>(value).FromMaybe(false);
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetStringArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Platform::String^>^ arg0;
          
          wrapper->_instance->GetStringArray(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<::Platform::String^>::CreateArrayWrapper(arg0, 
            [](::Platform::String^ val) -> Local<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Local<Value> value) -> bool {
              return value->IsString();
            },
            [](Local<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), value)));
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetInspectableArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Platform::Object^>^ arg0;
          
          wrapper->_instance->GetInspectableArray(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<::Platform::Object^>::CreateArrayWrapper(arg0, 
            [](::Platform::Object^ val) -> Local<Value> {
              return CreateOpaqueWrapper(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
            },
            [](Local<Value> value) -> ::Platform::Object^ {
              return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetGuidArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Platform::Guid>^ arg0;
          
          wrapper->_instance->GetGuidArray(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<::Platform::Guid>::CreateArrayWrapper(arg0, 
            [](::Platform::Guid val) -> Local<Value> {
              return NodeRT::Utils::GuidToJs(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsGuid(value);
            },
            [](Local<Value> value) -> ::Platform::Guid {
              return NodeRT::Utils::GuidFromJs(value);
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetDateTimeArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::DateTime>^ arg0;
          
          wrapper->_instance->GetDateTimeArray(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<::Windows::Foundation::DateTime>::CreateArrayWrapper(arg0, 
            [](::Windows::Foundation::DateTime val) -> Local<Value> {
              return NodeRT::Utils::DateTimeToJS(val);
            },
            [](Local<Value> value) -> bool {
              return value->IsDate();
            },
            [](Local<Value> value) -> ::Windows::Foundation::DateTime {
              return NodeRT::Utils::DateTimeFromJSDate(value);
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetTimeSpanArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::TimeSpan>^ arg0;
          
          wrapper->_instance->GetTimeSpanArray(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<::Windows::Foundation::TimeSpan>::CreateArrayWrapper(arg0, 
            [](::Windows::Foundation::TimeSpan val) -> Local<Value> {
              return Nan::New<Number>(val.Duration/10000.0);
            },
            [](Local<Value> value) -> bool {
              return value->IsNumber();
            },
            [](Local<Value> value) -> ::Windows::Foundation::TimeSpan {
              return NodeRT::Utils::TimeSpanFromMilli(Nan::To<int64_t>(value).FromMaybe(0));
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetPointArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::Point>^ arg0;
          
          wrapper->_instance->GetPointArray(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<::Windows::Foundation::Point>::CreateArrayWrapper(arg0, 
            [](::Windows::Foundation::Point val) -> Local<Value> {
              return NodeRT::Utils::PointToJs(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsPoint(value);
            },
            [](Local<Value> value) -> ::Windows::Foundation::Point {
              return NodeRT::Utils::PointFromJs(value);
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetSizeArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::Size>^ arg0;
          
          wrapper->_instance->GetSizeArray(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<::Windows::Foundation::Size>::CreateArrayWrapper(arg0, 
            [](::Windows::Foundation::Size val) -> Local<Value> {
              return NodeRT::Utils::SizeToJs(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsSize(value);
            },
            [](Local<Value> value) -> ::Windows::Foundation::Size {
              return NodeRT::Utils::SizeFromJs(value);
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetRectArray(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::Rect>^ arg0;
          
          wrapper->_instance->GetRectArray(&arg0);
          Local<Object> resObj = Nan::New<Object>();
          Nan::Set(resObj, Nan::New<String>("value").ToLocalChecked(), NodeRT::Collections::ArrayWrapper<::Windows::Foundation::Rect>::CreateArrayWrapper(arg0, 
            [](::Windows::Foundation::Rect val) -> Local<Value> {
              return NodeRT::Utils::RectToJs(val);
            },
            [](Local<Value> value) -> bool {
              return NodeRT::Utils::IsRect(value);
            },
            [](Local<Value> value) -> ::Windows::Foundation::Rect {
              return NodeRT::Utils::RectFromJs(value);
            }
          ));
          info.GetReturnValue().Set(resObj);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void IsNumericScalarGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      try  {
        bool result = wrapper->_instance->IsNumericScalar;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void TypeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This())) {
        return;
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      try  {
        ::Windows::Foundation::PropertyType result = wrapper->_instance->Type;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Foundation::IPropertyValue^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIPropertyValue(::Windows::Foundation::IPropertyValue^ wintRtInstance);
      friend ::Windows::Foundation::IPropertyValue^ UnwrapIPropertyValue(Local<Value> value);
  };

  Persistent<FunctionTemplate> IPropertyValue::s_constructorTemplate;

  v8::Local<v8::Value> WrapIPropertyValue(::Windows::Foundation::IPropertyValue^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IPropertyValue::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::IPropertyValue^ UnwrapIPropertyValue(Local<Value> value) {
     return IPropertyValue::Unwrap<IPropertyValue>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIPropertyValue(Local<Object> exports) {
    IPropertyValue::Init(exports);
  }

  class Uri : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("Uri").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "equals", Equals);
            Nan::SetPrototypeMethod(localRef, "combineUri", CombineUri);
            Nan::SetPrototypeMethod(localRef, "toString", ToString);
          



          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("absoluteUri").ToLocalChecked(), AbsoluteUriGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("displayUri").ToLocalChecked(), DisplayUriGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("domain").ToLocalChecked(), DomainGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("extension").ToLocalChecked(), ExtensionGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("fragment").ToLocalChecked(), FragmentGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("host").ToLocalChecked(), HostGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("password").ToLocalChecked(), PasswordGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("path").ToLocalChecked(), PathGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("port").ToLocalChecked(), PortGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("query").ToLocalChecked(), QueryGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("queryParsed").ToLocalChecked(), QueryParsedGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("rawUri").ToLocalChecked(), RawUriGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("schemeName").ToLocalChecked(), SchemeNameGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("suspicious").ToLocalChecked(), SuspiciousGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("userName").ToLocalChecked(), UserNameGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("absoluteCanonicalUri").ToLocalChecked(), AbsoluteCanonicalUriGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("displayIri").ToLocalChecked(), DisplayIriGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "unescapeComponent", UnescapeComponent);
        Nan::SetMethod(constructor, "escapeComponent", EscapeComponent);


        Nan::Set(exports, Nan::New<String>("Uri").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      Uri(::Windows::Foundation::Uri^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Foundation::Uri^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info[0])) {
        try {
          winRtInstance = (::Windows::Foundation::Uri^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && info[0]->IsString())
      {
        try {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          winRtInstance = ref new ::Windows::Foundation::Uri(arg0);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 2
        && info[0]->IsString()
        && info[1]->IsString())
      {
        try {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[1])));
          
          winRtInstance = ref new ::Windows::Foundation::Uri(arg0,arg1);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      Uri *wrapperInstance = new Uri(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Foundation::Uri^ winRtInstance;
      try {
        winRtInstance = (::Windows::Foundation::Uri^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapUri(winRtInstance));
    }


    static void Equals(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info[0]))
      {
        try
        {
          ::Windows::Foundation::Uri^ arg0 = dynamic_cast<::Windows::Foundation::Uri^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          bool result;
          result = wrapper->_instance->Equals(arg0);
          info.GetReturnValue().Set(Nan::New<Boolean>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void CombineUri(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          ::Windows::Foundation::Uri^ result;
          result = wrapper->_instance->CombineUri(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation", "Uri", result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ToString(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          Platform::String^ result;
          result = wrapper->_instance->ToString();
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void UnescapeComponent(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          Platform::String^ result;
          result = ::Windows::Foundation::Uri::UnescapeComponent(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void EscapeComponent(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          Platform::String^ result;
          result = ::Windows::Foundation::Uri::EscapeComponent(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void AbsoluteUriGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->AbsoluteUri;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DisplayUriGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->DisplayUri;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DomainGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Domain;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ExtensionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Extension;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void FragmentGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Fragment;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void HostGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Host;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PasswordGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Password;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PathGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Path;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PortGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        int result = wrapper->_instance->Port;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void QueryGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->Query;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void QueryParsedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        ::Windows::Foundation::WwwFormUrlDecoder^ result = wrapper->_instance->QueryParsed;
        info.GetReturnValue().Set(WrapWwwFormUrlDecoder(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void RawUriGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->RawUri;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SchemeNameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->SchemeName;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SuspiciousGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        bool result = wrapper->_instance->Suspicious;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UserNameGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->UserName;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void AbsoluteCanonicalUriGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->AbsoluteCanonicalUri;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void DisplayIriGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This())) {
        return;
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->DisplayIri;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Foundation::Uri^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapUri(::Windows::Foundation::Uri^ wintRtInstance);
      friend ::Windows::Foundation::Uri^ UnwrapUri(Local<Value> value);
  };

  Persistent<FunctionTemplate> Uri::s_constructorTemplate;

  v8::Local<v8::Value> WrapUri(::Windows::Foundation::Uri^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(Uri::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Foundation::Uri^ UnwrapUri(Local<Value> value) {
     return Uri::Unwrap<Uri>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitUri(Local<Object> exports) {
    Uri::Init(exports);
  }

} } }


namespace NodeRT { namespace Windows { namespace Storage { namespace Streams { 
  v8::Local<v8::Value> WrapBuffer(::Windows::Storage::Streams::Buffer^ wintRtInstance);
  ::Windows::Storage::Streams::Buffer^ UnwrapBuffer(Local<Value> value);
  
  v8::Local<v8::Value> WrapDataReader(::Windows::Storage::Streams::DataReader^ wintRtInstance);
  ::Windows::Storage::Streams::DataReader^ UnwrapDataReader(Local<Value> value);
  
  v8::Local<v8::Value> WrapDataReaderLoadOperation(::Windows::Storage::Streams::DataReaderLoadOperation^ wintRtInstance);
  ::Windows::Storage::Streams::DataReaderLoadOperation^ UnwrapDataReaderLoadOperation(Local<Value> value);
  
  v8::Local<v8::Value> WrapDataWriter(::Windows::Storage::Streams::DataWriter^ wintRtInstance);
  ::Windows::Storage::Streams::DataWriter^ UnwrapDataWriter(Local<Value> value);
  
  v8::Local<v8::Value> WrapDataWriterStoreOperation(::Windows::Storage::Streams::DataWriterStoreOperation^ wintRtInstance);
  ::Windows::Storage::Streams::DataWriterStoreOperation^ UnwrapDataWriterStoreOperation(Local<Value> value);
  
  v8::Local<v8::Value> WrapFileInputStream(::Windows::Storage::Streams::FileInputStream^ wintRtInstance);
  ::Windows::Storage::Streams::FileInputStream^ UnwrapFileInputStream(Local<Value> value);
  
  v8::Local<v8::Value> WrapFileOutputStream(::Windows::Storage::Streams::FileOutputStream^ wintRtInstance);
  ::Windows::Storage::Streams::FileOutputStream^ UnwrapFileOutputStream(Local<Value> value);
  
  v8::Local<v8::Value> WrapFileRandomAccessStream(::Windows::Storage::Streams::FileRandomAccessStream^ wintRtInstance);
  ::Windows::Storage::Streams::FileRandomAccessStream^ UnwrapFileRandomAccessStream(Local<Value> value);
  
  v8::Local<v8::Value> WrapIBuffer(::Windows::Storage::Streams::IBuffer^ wintRtInstance);
  ::Windows::Storage::Streams::IBuffer^ UnwrapIBuffer(Local<Value> value);
  
  v8::Local<v8::Value> WrapIContentTypeProvider(::Windows::Storage::Streams::IContentTypeProvider^ wintRtInstance);
  ::Windows::Storage::Streams::IContentTypeProvider^ UnwrapIContentTypeProvider(Local<Value> value);
  
  v8::Local<v8::Value> WrapIDataReader(::Windows::Storage::Streams::IDataReader^ wintRtInstance);
  ::Windows::Storage::Streams::IDataReader^ UnwrapIDataReader(Local<Value> value);
  
  v8::Local<v8::Value> WrapIDataWriter(::Windows::Storage::Streams::IDataWriter^ wintRtInstance);
  ::Windows::Storage::Streams::IDataWriter^ UnwrapIDataWriter(Local<Value> value);
  
  v8::Local<v8::Value> WrapIInputStream(::Windows::Storage::Streams::IInputStream^ wintRtInstance);
  ::Windows::Storage::Streams::IInputStream^ UnwrapIInputStream(Local<Value> value);
  
  v8::Local<v8::Value> WrapIInputStreamReference(::Windows::Storage::Streams::IInputStreamReference^ wintRtInstance);
  ::Windows::Storage::Streams::IInputStreamReference^ UnwrapIInputStreamReference(Local<Value> value);
  
  v8::Local<v8::Value> WrapIOutputStream(::Windows::Storage::Streams::IOutputStream^ wintRtInstance);
  ::Windows::Storage::Streams::IOutputStream^ UnwrapIOutputStream(Local<Value> value);
  
  v8::Local<v8::Value> WrapIRandomAccessStream(::Windows::Storage::Streams::IRandomAccessStream^ wintRtInstance);
  ::Windows::Storage::Streams::IRandomAccessStream^ UnwrapIRandomAccessStream(Local<Value> value);
  
  v8::Local<v8::Value> WrapIRandomAccessStreamReference(::Windows::Storage::Streams::IRandomAccessStreamReference^ wintRtInstance);
  ::Windows::Storage::Streams::IRandomAccessStreamReference^ UnwrapIRandomAccessStreamReference(Local<Value> value);
  
  v8::Local<v8::Value> WrapIRandomAccessStreamWithContentType(::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ wintRtInstance);
  ::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ UnwrapIRandomAccessStreamWithContentType(Local<Value> value);
  
  v8::Local<v8::Value> WrapInMemoryRandomAccessStream(::Windows::Storage::Streams::InMemoryRandomAccessStream^ wintRtInstance);
  ::Windows::Storage::Streams::InMemoryRandomAccessStream^ UnwrapInMemoryRandomAccessStream(Local<Value> value);
  
  v8::Local<v8::Value> WrapInputStreamOverStream(::Windows::Storage::Streams::InputStreamOverStream^ wintRtInstance);
  ::Windows::Storage::Streams::InputStreamOverStream^ UnwrapInputStreamOverStream(Local<Value> value);
  
  v8::Local<v8::Value> WrapOutputStreamOverStream(::Windows::Storage::Streams::OutputStreamOverStream^ wintRtInstance);
  ::Windows::Storage::Streams::OutputStreamOverStream^ UnwrapOutputStreamOverStream(Local<Value> value);
  
  v8::Local<v8::Value> WrapRandomAccessStream(::Windows::Storage::Streams::RandomAccessStream^ wintRtInstance);
  ::Windows::Storage::Streams::RandomAccessStream^ UnwrapRandomAccessStream(Local<Value> value);
  
  v8::Local<v8::Value> WrapRandomAccessStreamOverStream(::Windows::Storage::Streams::RandomAccessStreamOverStream^ wintRtInstance);
  ::Windows::Storage::Streams::RandomAccessStreamOverStream^ UnwrapRandomAccessStreamOverStream(Local<Value> value);
  
  v8::Local<v8::Value> WrapRandomAccessStreamReference(::Windows::Storage::Streams::RandomAccessStreamReference^ wintRtInstance);
  ::Windows::Storage::Streams::RandomAccessStreamReference^ UnwrapRandomAccessStreamReference(Local<Value> value);
  



  static void InitByteOrderEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("ByteOrder").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("littleEndian").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::ByteOrder::LittleEndian)));
    Nan::Set(enumObject, Nan::New<String>("bigEndian").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::ByteOrder::BigEndian)));
  }

  static void InitFileOpenDispositionEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("FileOpenDisposition").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("openExisting").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::FileOpenDisposition::OpenExisting)));
    Nan::Set(enumObject, Nan::New<String>("openAlways").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::FileOpenDisposition::OpenAlways)));
    Nan::Set(enumObject, Nan::New<String>("createNew").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::FileOpenDisposition::CreateNew)));
    Nan::Set(enumObject, Nan::New<String>("createAlways").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::FileOpenDisposition::CreateAlways)));
    Nan::Set(enumObject, Nan::New<String>("truncateExisting").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::FileOpenDisposition::TruncateExisting)));
  }

  static void InitInputStreamOptionsEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("InputStreamOptions").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("none").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::InputStreamOptions::None)));
    Nan::Set(enumObject, Nan::New<String>("partial").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::InputStreamOptions::Partial)));
    Nan::Set(enumObject, Nan::New<String>("readAhead").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::InputStreamOptions::ReadAhead)));
  }

  static void InitUnicodeEncodingEnum(const Local<Object> exports) {
    HandleScope scope;

    Local<Object> enumObject = Nan::New<Object>();

    Nan::Set(exports, Nan::New<String>("UnicodeEncoding").ToLocalChecked(), enumObject);
    Nan::Set(enumObject, Nan::New<String>("utf8").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::UnicodeEncoding::Utf8)));
    Nan::Set(enumObject, Nan::New<String>("utf16LE").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::UnicodeEncoding::Utf16LE)));
    Nan::Set(enumObject, Nan::New<String>("utf16BE").ToLocalChecked(), Nan::New<Integer>(static_cast<int>(::Windows::Storage::Streams::UnicodeEncoding::Utf16BE)));
  }



  class Buffer : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("Buffer").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("length").ToLocalChecked(), LengthGetter, LengthSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("capacity").ToLocalChecked(), CapacityGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "createCopyFromMemoryBuffer", CreateCopyFromMemoryBuffer);
        Nan::SetMethod(constructor, "createMemoryBufferOverIBuffer", CreateMemoryBufferOverIBuffer);


        Nan::Set(exports, Nan::New<String>("Buffer").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      Buffer(::Windows::Storage::Streams::Buffer^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::Buffer^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::Buffer^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::Buffer^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          winRtInstance = ref new ::Windows::Storage::Streams::Buffer(arg0);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      Buffer *wrapperInstance = new Buffer(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::Buffer^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::Buffer^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::Buffer^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapBuffer(winRtInstance));
    }





    static void CreateCopyFromMemoryBuffer(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IMemoryBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Foundation::IMemoryBuffer^ arg0 = dynamic_cast<::Windows::Foundation::IMemoryBuffer^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          ::Windows::Storage::Streams::Buffer^ result;
          result = ::Windows::Storage::Streams::Buffer::CreateCopyFromMemoryBuffer(arg0);
          info.GetReturnValue().Set(WrapBuffer(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateMemoryBufferOverIBuffer(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          
          ::Windows::Foundation::MemoryBuffer^ result;
          result = ::Windows::Storage::Streams::Buffer::CreateMemoryBufferOverIBuffer(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation", "MemoryBuffer", result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void LengthGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::Buffer^>(info.This())) {
        return;
      }

      Buffer *wrapper = Buffer::Unwrap<Buffer>(info.This());

      try  {
        unsigned int result = wrapper->_instance->Length;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void LengthSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsUint32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::Buffer^>(info.This())) {
        return;
      }

      Buffer *wrapper = Buffer::Unwrap<Buffer>(info.This());

      try {

        unsigned int winRtValue = static_cast<unsigned int>(Nan::To<uint32_t>(value).FromMaybe(0));

        wrapper->_instance->Length = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void CapacityGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::Buffer^>(info.This())) {
        return;
      }

      Buffer *wrapper = Buffer::Unwrap<Buffer>(info.This());

      try  {
        unsigned int result = wrapper->_instance->Capacity;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Storage::Streams::Buffer^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapBuffer(::Windows::Storage::Streams::Buffer^ wintRtInstance);
      friend ::Windows::Storage::Streams::Buffer^ UnwrapBuffer(Local<Value> value);
  };

  Persistent<FunctionTemplate> Buffer::s_constructorTemplate;

  v8::Local<v8::Value> WrapBuffer(::Windows::Storage::Streams::Buffer^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(Buffer::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::Buffer^ UnwrapBuffer(Local<Value> value) {
     return Buffer::Unwrap<Buffer>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitBuffer(Local<Object> exports) {
    Buffer::Init(exports);
  }

  class DataReader : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DataReader").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "readByte", ReadByte);
            Nan::SetPrototypeMethod(localRef, "readBytes", ReadBytes);
            Nan::SetPrototypeMethod(localRef, "readBuffer", ReadBuffer);
            Nan::SetPrototypeMethod(localRef, "readBoolean", ReadBoolean);
            Nan::SetPrototypeMethod(localRef, "readGuid", ReadGuid);
            Nan::SetPrototypeMethod(localRef, "readInt16", ReadInt16);
            Nan::SetPrototypeMethod(localRef, "readInt32", ReadInt32);
            Nan::SetPrototypeMethod(localRef, "readInt64", ReadInt64);
            Nan::SetPrototypeMethod(localRef, "readUInt16", ReadUInt16);
            Nan::SetPrototypeMethod(localRef, "readUInt32", ReadUInt32);
            Nan::SetPrototypeMethod(localRef, "readUInt64", ReadUInt64);
            Nan::SetPrototypeMethod(localRef, "readSingle", ReadSingle);
            Nan::SetPrototypeMethod(localRef, "readDouble", ReadDouble);
            Nan::SetPrototypeMethod(localRef, "readString", ReadString);
            Nan::SetPrototypeMethod(localRef, "readDateTime", ReadDateTime);
            Nan::SetPrototypeMethod(localRef, "readTimeSpan", ReadTimeSpan);
            Nan::SetPrototypeMethod(localRef, "detachBuffer", DetachBuffer);
            Nan::SetPrototypeMethod(localRef, "detachStream", DetachStream);
            Nan::SetPrototypeMethod(localRef, "close", Close);
          

          
            Nan::SetPrototypeMethod(localRef, "loadAsync", LoadAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("unicodeEncoding").ToLocalChecked(), UnicodeEncodingGetter, UnicodeEncodingSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("inputStreamOptions").ToLocalChecked(), InputStreamOptionsGetter, InputStreamOptionsSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("byteOrder").ToLocalChecked(), ByteOrderGetter, ByteOrderSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("unconsumedBufferLength").ToLocalChecked(), UnconsumedBufferLengthGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "fromBuffer", FromBuffer);


        Nan::Set(exports, Nan::New<String>("DataReader").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DataReader(::Windows::Storage::Streams::DataReader^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::DataReader^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::DataReader^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(info[0]))
      {
        try {
          ::Windows::Storage::Streams::IInputStream^ arg0 = UnwrapIInputStream(info[0]);
          
          winRtInstance = ref new ::Windows::Storage::Streams::DataReader(arg0);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DataReader *wrapperInstance = new DataReader(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::DataReader^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::DataReader^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDataReader(winRtInstance));
    }

    static void LoadAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      ::Windows::Storage::Streams::DataReaderLoadOperation^ op;


      if (info.Length() == 2
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->LoadAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void ReadByte(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned char result;
          result = wrapper->_instance->ReadByte();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadBytes(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Not implemented")));
    }
    static void ReadBuffer(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          ::Windows::Storage::Streams::IBuffer^ result;
          result = wrapper->_instance->ReadBuffer(arg0);
          info.GetReturnValue().Set(WrapIBuffer(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadBoolean(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          bool result;
          result = wrapper->_instance->ReadBoolean();
          info.GetReturnValue().Set(Nan::New<Boolean>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadGuid(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Guid result;
          result = wrapper->_instance->ReadGuid();
          info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadInt16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          short result;
          result = wrapper->_instance->ReadInt16();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadInt32(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          int result;
          result = wrapper->_instance->ReadInt32();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadInt64(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          __int64 result;
          result = wrapper->_instance->ReadInt64();
          info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadUInt16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned short result;
          result = wrapper->_instance->ReadUInt16();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadUInt32(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned int result;
          result = wrapper->_instance->ReadUInt32();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadUInt64(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned __int64 result;
          result = wrapper->_instance->ReadUInt64();
          info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadSingle(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          float result;
          result = wrapper->_instance->ReadSingle();
          info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadDouble(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          double result;
          result = wrapper->_instance->ReadDouble();
          info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadString(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          Platform::String^ result;
          result = wrapper->_instance->ReadString(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadDateTime(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::DateTime result;
          result = wrapper->_instance->ReadDateTime();
          info.GetReturnValue().Set(NodeRT::Utils::DateTimeToJS(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadTimeSpan(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::TimeSpan result;
          result = wrapper->_instance->ReadTimeSpan();
          info.GetReturnValue().Set(Nan::New<Number>(result.Duration/10000.0));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void DetachBuffer(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ result;
          result = wrapper->_instance->DetachBuffer();
          info.GetReturnValue().Set(WrapIBuffer(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void DetachStream(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->DetachStream();
          info.GetReturnValue().Set(WrapIInputStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void FromBuffer(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          
          ::Windows::Storage::Streams::DataReader^ result;
          result = ::Windows::Storage::Streams::DataReader::FromBuffer(arg0);
          info.GetReturnValue().Set(WrapDataReader(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void UnicodeEncodingGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try  {
        ::Windows::Storage::Streams::UnicodeEncoding result = wrapper->_instance->UnicodeEncoding;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UnicodeEncodingSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try {

        ::Windows::Storage::Streams::UnicodeEncoding winRtValue = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->UnicodeEncoding = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void InputStreamOptionsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try  {
        ::Windows::Storage::Streams::InputStreamOptions result = wrapper->_instance->InputStreamOptions;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void InputStreamOptionsSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try {

        ::Windows::Storage::Streams::InputStreamOptions winRtValue = static_cast<::Windows::Storage::Streams::InputStreamOptions>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->InputStreamOptions = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void ByteOrderGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try  {
        ::Windows::Storage::Streams::ByteOrder result = wrapper->_instance->ByteOrder;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ByteOrderSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try {

        ::Windows::Storage::Streams::ByteOrder winRtValue = static_cast<::Windows::Storage::Streams::ByteOrder>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->ByteOrder = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void UnconsumedBufferLengthGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This())) {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try  {
        unsigned int result = wrapper->_instance->UnconsumedBufferLength;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Storage::Streams::DataReader^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDataReader(::Windows::Storage::Streams::DataReader^ wintRtInstance);
      friend ::Windows::Storage::Streams::DataReader^ UnwrapDataReader(Local<Value> value);
  };

  Persistent<FunctionTemplate> DataReader::s_constructorTemplate;

  v8::Local<v8::Value> WrapDataReader(::Windows::Storage::Streams::DataReader^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DataReader::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::DataReader^ UnwrapDataReader(Local<Value> value) {
     return DataReader::Unwrap<DataReader>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDataReader(Local<Object> exports) {
    DataReader::Init(exports);
  }

  class DataReaderLoadOperation : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DataReaderLoadOperation").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "getResults", GetResults);
            Nan::SetPrototypeMethod(localRef, "cancel", Cancel);
            Nan::SetPrototypeMethod(localRef, "close", Close);
          



          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("errorCode").ToLocalChecked(), ErrorCodeGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("id").ToLocalChecked(), IdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("completed").ToLocalChecked(), CompletedGetter, CompletedSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DataReaderLoadOperation").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DataReaderLoadOperation(::Windows::Storage::Streams::DataReaderLoadOperation^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::DataReaderLoadOperation^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::DataReaderLoadOperation^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DataReaderLoadOperation *wrapperInstance = new DataReaderLoadOperation(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::DataReaderLoadOperation^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::DataReaderLoadOperation^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDataReaderLoadOperation(winRtInstance));
    }


    static void GetResults(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This())) {
        return;
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned int result;
          result = wrapper->_instance->GetResults();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Cancel(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This())) {
        return;
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Cancel();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This())) {
        return;
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Close();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void ErrorCodeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This())) {
        return;
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      try  {
        ::Windows::Foundation::HResult result = wrapper->_instance->ErrorCode;
        info.GetReturnValue().Set(Nan::New<Integer>(result.Value));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This())) {
        return;
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      try  {
        unsigned int result = wrapper->_instance->Id;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This())) {
        return;
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      try  {
        ::Windows::Foundation::AsyncStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CompletedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This())) {
        return;
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      try  {
        ::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^ result = wrapper->_instance->Completed;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation", "AsyncOperationCompletedHandler`1", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CompletedSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^>(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This())) {
        return;
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      try {

        ::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^ winRtValue = dynamic_cast<::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->Completed = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Storage::Streams::DataReaderLoadOperation^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDataReaderLoadOperation(::Windows::Storage::Streams::DataReaderLoadOperation^ wintRtInstance);
      friend ::Windows::Storage::Streams::DataReaderLoadOperation^ UnwrapDataReaderLoadOperation(Local<Value> value);
  };

  Persistent<FunctionTemplate> DataReaderLoadOperation::s_constructorTemplate;

  v8::Local<v8::Value> WrapDataReaderLoadOperation(::Windows::Storage::Streams::DataReaderLoadOperation^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DataReaderLoadOperation::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::DataReaderLoadOperation^ UnwrapDataReaderLoadOperation(Local<Value> value) {
     return DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDataReaderLoadOperation(Local<Object> exports) {
    DataReaderLoadOperation::Init(exports);
  }

  class DataWriter : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DataWriter").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "writeByte", WriteByte);
            Nan::SetPrototypeMethod(localRef, "writeBytes", WriteBytes);
            Nan::SetPrototypeMethod(localRef, "writeBuffer", WriteBuffer);
            Nan::SetPrototypeMethod(localRef, "writeBoolean", WriteBoolean);
            Nan::SetPrototypeMethod(localRef, "writeGuid", WriteGuid);
            Nan::SetPrototypeMethod(localRef, "writeInt16", WriteInt16);
            Nan::SetPrototypeMethod(localRef, "writeInt32", WriteInt32);
            Nan::SetPrototypeMethod(localRef, "writeInt64", WriteInt64);
            Nan::SetPrototypeMethod(localRef, "writeUInt16", WriteUInt16);
            Nan::SetPrototypeMethod(localRef, "writeUInt32", WriteUInt32);
            Nan::SetPrototypeMethod(localRef, "writeUInt64", WriteUInt64);
            Nan::SetPrototypeMethod(localRef, "writeSingle", WriteSingle);
            Nan::SetPrototypeMethod(localRef, "writeDouble", WriteDouble);
            Nan::SetPrototypeMethod(localRef, "writeDateTime", WriteDateTime);
            Nan::SetPrototypeMethod(localRef, "writeTimeSpan", WriteTimeSpan);
            Nan::SetPrototypeMethod(localRef, "writeString", WriteString);
            Nan::SetPrototypeMethod(localRef, "measureString", MeasureString);
            Nan::SetPrototypeMethod(localRef, "detachBuffer", DetachBuffer);
            Nan::SetPrototypeMethod(localRef, "detachStream", DetachStream);
            Nan::SetPrototypeMethod(localRef, "close", Close);
          

          
            Nan::SetPrototypeMethod(localRef, "storeAsync", StoreAsync);
            Nan::SetPrototypeMethod(localRef, "flushAsync", FlushAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("unicodeEncoding").ToLocalChecked(), UnicodeEncodingGetter, UnicodeEncodingSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("byteOrder").ToLocalChecked(), ByteOrderGetter, ByteOrderSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("unstoredBufferLength").ToLocalChecked(), UnstoredBufferLengthGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DataWriter").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DataWriter(::Windows::Storage::Streams::DataWriter^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::DataWriter^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::DataWriter^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(info[0]))
      {
        try {
          ::Windows::Storage::Streams::IOutputStream^ arg0 = UnwrapIOutputStream(info[0]);
          
          winRtInstance = ref new ::Windows::Storage::Streams::DataWriter(arg0);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Storage::Streams::DataWriter();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DataWriter *wrapperInstance = new DataWriter(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::DataWriter^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::DataWriter^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDataWriter(winRtInstance));
    }

    static void StoreAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      ::Windows::Storage::Streams::DataWriterStoreOperation^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->StoreAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void FlushAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Boolean>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void WriteByte(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned char arg0 = static_cast<unsigned char>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteByte(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteBytes(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned char>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<unsigned char>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<unsigned char>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned char>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Local<Value> value) -> unsigned char {
                   return static_cast<unsigned char>(Nan::To<int32_t>(value).FromMaybe(0));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned char>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          wrapper->_instance->WriteBytes(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteBuffer(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          
          wrapper->_instance->WriteBuffer(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])
        && info[1]->IsUint32()
        && info[2]->IsUint32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          unsigned int arg1 = static_cast<unsigned int>(Nan::To<uint32_t>(info[1]).FromMaybe(0));
          unsigned int arg2 = static_cast<unsigned int>(Nan::To<uint32_t>(info[2]).FromMaybe(0));
          
          wrapper->_instance->WriteBuffer(arg0, arg1, arg2);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteBoolean(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsBoolean())
      {
        try
        {
          bool arg0 = Nan::To<bool>(info[0]).FromMaybe(false);
          
          wrapper->_instance->WriteBoolean(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteGuid(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          wrapper->_instance->WriteGuid(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteInt16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          short arg0 = static_cast<short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteInt16(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteInt32(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          int arg0 = static_cast<int>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteInt32(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteInt64(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          __int64 arg0 = Nan::To<int64_t>(info[0]).FromMaybe(0);
          
          wrapper->_instance->WriteInt64(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteUInt16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteUInt16(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteUInt32(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteUInt32(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteUInt64(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteUInt64(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteSingle(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          float arg0 = static_cast<float>(Nan::To<double>(info[0]).FromMaybe(0.0));
          
          wrapper->_instance->WriteSingle(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteDouble(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          double arg0 = Nan::To<double>(info[0]).FromMaybe(0.0);
          
          wrapper->_instance->WriteDouble(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteDateTime(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsDate())
      {
        try
        {
          ::Windows::Foundation::DateTime arg0 = NodeRT::Utils::DateTimeFromJSDate(info[0]);
          
          wrapper->_instance->WriteDateTime(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteTimeSpan(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          ::Windows::Foundation::TimeSpan arg0 = NodeRT::Utils::TimeSpanFromMilli(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteTimeSpan(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteString(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          unsigned int result;
          result = wrapper->_instance->WriteString(arg0);
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void MeasureString(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          unsigned int result;
          result = wrapper->_instance->MeasureString(arg0);
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void DetachBuffer(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ result;
          result = wrapper->_instance->DetachBuffer();
          info.GetReturnValue().Set(WrapIBuffer(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void DetachStream(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->DetachStream();
          info.GetReturnValue().Set(WrapIOutputStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void UnicodeEncodingGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      try  {
        ::Windows::Storage::Streams::UnicodeEncoding result = wrapper->_instance->UnicodeEncoding;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UnicodeEncodingSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      try {

        ::Windows::Storage::Streams::UnicodeEncoding winRtValue = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->UnicodeEncoding = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void ByteOrderGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      try  {
        ::Windows::Storage::Streams::ByteOrder result = wrapper->_instance->ByteOrder;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ByteOrderSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      try {

        ::Windows::Storage::Streams::ByteOrder winRtValue = static_cast<::Windows::Storage::Streams::ByteOrder>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->ByteOrder = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void UnstoredBufferLengthGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This())) {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      try  {
        unsigned int result = wrapper->_instance->UnstoredBufferLength;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Storage::Streams::DataWriter^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDataWriter(::Windows::Storage::Streams::DataWriter^ wintRtInstance);
      friend ::Windows::Storage::Streams::DataWriter^ UnwrapDataWriter(Local<Value> value);
  };

  Persistent<FunctionTemplate> DataWriter::s_constructorTemplate;

  v8::Local<v8::Value> WrapDataWriter(::Windows::Storage::Streams::DataWriter^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DataWriter::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::DataWriter^ UnwrapDataWriter(Local<Value> value) {
     return DataWriter::Unwrap<DataWriter>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDataWriter(Local<Object> exports) {
    DataWriter::Init(exports);
  }

  class DataWriterStoreOperation : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("DataWriterStoreOperation").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "getResults", GetResults);
            Nan::SetPrototypeMethod(localRef, "cancel", Cancel);
            Nan::SetPrototypeMethod(localRef, "close", Close);
          



          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("errorCode").ToLocalChecked(), ErrorCodeGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("id").ToLocalChecked(), IdGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("status").ToLocalChecked(), StatusGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("completed").ToLocalChecked(), CompletedGetter, CompletedSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("DataWriterStoreOperation").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      DataWriterStoreOperation(::Windows::Storage::Streams::DataWriterStoreOperation^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::DataWriterStoreOperation^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::DataWriterStoreOperation^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      DataWriterStoreOperation *wrapperInstance = new DataWriterStoreOperation(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::DataWriterStoreOperation^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::DataWriterStoreOperation^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapDataWriterStoreOperation(winRtInstance));
    }


    static void GetResults(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This())) {
        return;
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned int result;
          result = wrapper->_instance->GetResults();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Cancel(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This())) {
        return;
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Cancel();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This())) {
        return;
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          wrapper->_instance->Close();
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void ErrorCodeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This())) {
        return;
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      try  {
        ::Windows::Foundation::HResult result = wrapper->_instance->ErrorCode;
        info.GetReturnValue().Set(Nan::New<Integer>(result.Value));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void IdGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This())) {
        return;
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      try  {
        unsigned int result = wrapper->_instance->Id;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void StatusGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This())) {
        return;
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      try  {
        ::Windows::Foundation::AsyncStatus result = wrapper->_instance->Status;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CompletedGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This())) {
        return;
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      try  {
        ::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^ result = wrapper->_instance->Completed;
        info.GetReturnValue().Set(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation", "AsyncOperationCompletedHandler`1", result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CompletedSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^>(value)) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This())) {
        return;
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      try {

        ::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^ winRtValue = dynamic_cast<::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->Completed = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Storage::Streams::DataWriterStoreOperation^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapDataWriterStoreOperation(::Windows::Storage::Streams::DataWriterStoreOperation^ wintRtInstance);
      friend ::Windows::Storage::Streams::DataWriterStoreOperation^ UnwrapDataWriterStoreOperation(Local<Value> value);
  };

  Persistent<FunctionTemplate> DataWriterStoreOperation::s_constructorTemplate;

  v8::Local<v8::Value> WrapDataWriterStoreOperation(::Windows::Storage::Streams::DataWriterStoreOperation^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(DataWriterStoreOperation::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::DataWriterStoreOperation^ UnwrapDataWriterStoreOperation(Local<Value> value) {
     return DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitDataWriterStoreOperation(Local<Object> exports) {
    DataWriterStoreOperation::Init(exports);
  }

  class FileInputStream : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("FileInputStream").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "close", Close);
          

          
            Nan::SetPrototypeMethod(localRef, "readAsync", ReadAsync);
          



        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("FileInputStream").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      FileInputStream(::Windows::Storage::Streams::FileInputStream^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::FileInputStream^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileInputStream^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::FileInputStream^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      FileInputStream *wrapperInstance = new FileInputStream(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileInputStream^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::FileInputStream^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::FileInputStream^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapFileInputStream(winRtInstance));
    }

    static void ReadAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileInputStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      FileInputStream *wrapper = FileInputStream::Unwrap<FileInputStream>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;


      if (info.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])
        && info[1]->IsUint32()
        && info[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          unsigned int arg1 = static_cast<unsigned int>(Nan::To<uint32_t>(info[1]).FromMaybe(0));
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapIBuffer(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileInputStream^>(info.This())) {
        return;
      }

      FileInputStream *wrapper = FileInputStream::Unwrap<FileInputStream>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }





    private:
      ::Windows::Storage::Streams::FileInputStream^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapFileInputStream(::Windows::Storage::Streams::FileInputStream^ wintRtInstance);
      friend ::Windows::Storage::Streams::FileInputStream^ UnwrapFileInputStream(Local<Value> value);
  };

  Persistent<FunctionTemplate> FileInputStream::s_constructorTemplate;

  v8::Local<v8::Value> WrapFileInputStream(::Windows::Storage::Streams::FileInputStream^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(FileInputStream::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::FileInputStream^ UnwrapFileInputStream(Local<Value> value) {
     return FileInputStream::Unwrap<FileInputStream>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitFileInputStream(Local<Object> exports) {
    FileInputStream::Init(exports);
  }

  class FileOutputStream : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("FileOutputStream").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "close", Close);
          

          
            Nan::SetPrototypeMethod(localRef, "writeAsync", WriteAsync);
            Nan::SetPrototypeMethod(localRef, "flushAsync", FlushAsync);
          



        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("FileOutputStream").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      FileOutputStream(::Windows::Storage::Streams::FileOutputStream^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::FileOutputStream^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileOutputStream^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::FileOutputStream^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      FileOutputStream *wrapperInstance = new FileOutputStream(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileOutputStream^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::FileOutputStream^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::FileOutputStream^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapFileOutputStream(winRtInstance));
    }

    static void WriteAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileOutputStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      FileOutputStream *wrapper = FileOutputStream::Unwrap<FileOutputStream>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void FlushAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileOutputStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      FileOutputStream *wrapper = FileOutputStream::Unwrap<FileOutputStream>(info.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Boolean>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileOutputStream^>(info.This())) {
        return;
      }

      FileOutputStream *wrapper = FileOutputStream::Unwrap<FileOutputStream>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }





    private:
      ::Windows::Storage::Streams::FileOutputStream^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapFileOutputStream(::Windows::Storage::Streams::FileOutputStream^ wintRtInstance);
      friend ::Windows::Storage::Streams::FileOutputStream^ UnwrapFileOutputStream(Local<Value> value);
  };

  Persistent<FunctionTemplate> FileOutputStream::s_constructorTemplate;

  v8::Local<v8::Value> WrapFileOutputStream(::Windows::Storage::Streams::FileOutputStream^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(FileOutputStream::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::FileOutputStream^ UnwrapFileOutputStream(Local<Value> value) {
     return FileOutputStream::Unwrap<FileOutputStream>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitFileOutputStream(Local<Object> exports) {
    FileOutputStream::Init(exports);
  }

  class FileRandomAccessStream : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("FileRandomAccessStream").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "getInputStreamAt", GetInputStreamAt);
            Nan::SetPrototypeMethod(localRef, "getOutputStreamAt", GetOutputStreamAt);
            Nan::SetPrototypeMethod(localRef, "seek", Seek);
            Nan::SetPrototypeMethod(localRef, "cloneStream", CloneStream);
            Nan::SetPrototypeMethod(localRef, "close", Close);
          

          
            Nan::SetPrototypeMethod(localRef, "readAsync", ReadAsync);
            Nan::SetPrototypeMethod(localRef, "writeAsync", WriteAsync);
            Nan::SetPrototypeMethod(localRef, "flushAsync", FlushAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("size").ToLocalChecked(), SizeGetter, SizeSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("canRead").ToLocalChecked(), CanReadGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("canWrite").ToLocalChecked(), CanWriteGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("position").ToLocalChecked(), PositionGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        func = Nan::GetFunction(Nan::New<FunctionTemplate>(OpenAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("openAsync").ToLocalChecked(), func);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(OpenTransactedWriteAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("openTransactedWriteAsync").ToLocalChecked(), func);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(OpenForUserAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("openForUserAsync").ToLocalChecked(), func);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(OpenTransactedWriteForUserAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("openTransactedWriteForUserAsync").ToLocalChecked(), func);


        Nan::Set(exports, Nan::New<String>("FileRandomAccessStream").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      FileRandomAccessStream(::Windows::Storage::Streams::FileRandomAccessStream^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::FileRandomAccessStream^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::FileRandomAccessStream^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      FileRandomAccessStream *wrapperInstance = new FileRandomAccessStream(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::FileRandomAccessStream^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::FileRandomAccessStream^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapFileRandomAccessStream(winRtInstance));
    }

    static void ReadAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;


      if (info.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])
        && info[1]->IsUint32()
        && info[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          unsigned int arg1 = static_cast<unsigned int>(Nan::To<uint32_t>(info[1]).FromMaybe(0));
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapIBuffer(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void WriteAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void FlushAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Boolean>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void GetInputStreamAt(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->GetInputStreamAt(arg0);
          info.GetReturnValue().Set(WrapIInputStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetOutputStreamAt(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->GetOutputStreamAt(arg0);
          info.GetReturnValue().Set(WrapIOutputStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Seek(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->Seek(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void CloneStream(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IRandomAccessStream^ result;
          result = wrapper->_instance->CloneStream();
          info.GetReturnValue().Set(WrapIRandomAccessStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }


    static void OpenAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IRandomAccessStream^>^ op;


      if (info.Length() == 3
          && info[0]->IsString()
          && info[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          ::Windows::Storage::FileAccessMode arg1 = static_cast<::Windows::Storage::FileAccessMode>(Nan::To<int32_t>(info[1]).FromMaybe(0));
            
          op = ::Windows::Storage::Streams::FileRandomAccessStream::OpenAsync(arg0,arg1);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 5
          && info[0]->IsString()
          && info[1]->IsInt32()
          && info[2]->IsInt32()
          && info[3]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          ::Windows::Storage::FileAccessMode arg1 = static_cast<::Windows::Storage::FileAccessMode>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          ::Windows::Storage::StorageOpenOptions arg2 = static_cast<::Windows::Storage::StorageOpenOptions>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          ::Windows::Storage::Streams::FileOpenDisposition arg3 = static_cast<::Windows::Storage::Streams::FileOpenDisposition>(Nan::To<int32_t>(info[3]).FromMaybe(0));
            
          op = ::Windows::Storage::Streams::FileRandomAccessStream::OpenAsync(arg0,arg1,arg2,arg3);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IRandomAccessStream^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapIRandomAccessStream(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void OpenTransactedWriteAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageStreamTransaction^>^ op;


      if (info.Length() == 2
          && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
            
          op = ::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteAsync(arg0);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 4
          && info[0]->IsString()
          && info[1]->IsInt32()
          && info[2]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          ::Windows::Storage::StorageOpenOptions arg1 = static_cast<::Windows::Storage::StorageOpenOptions>(Nan::To<int32_t>(info[1]).FromMaybe(0));
          ::Windows::Storage::Streams::FileOpenDisposition arg2 = static_cast<::Windows::Storage::Streams::FileOpenDisposition>(Nan::To<int32_t>(info[2]).FromMaybe(0));
            
          op = ::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteAsync(arg0,arg1,arg2);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageStreamTransaction^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage", "StorageStreamTransaction", result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void OpenForUserAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IRandomAccessStream^>^ op;


      if (info.Length() == 4
          && NodeRT::Utils::IsWinRtWrapperOf<::Windows::System::User^>(info[0])
          && info[1]->IsString()
          && info[2]->IsInt32())
      {
        try
        {
          ::Windows::System::User^ arg0 = dynamic_cast<::Windows::System::User^>(NodeRT::Utils::GetObjectInstance(info[0]));
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[1])));
          ::Windows::Storage::FileAccessMode arg2 = static_cast<::Windows::Storage::FileAccessMode>(Nan::To<int32_t>(info[2]).FromMaybe(0));
            
          op = ::Windows::Storage::Streams::FileRandomAccessStream::OpenForUserAsync(arg0,arg1,arg2);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 6
          && NodeRT::Utils::IsWinRtWrapperOf<::Windows::System::User^>(info[0])
          && info[1]->IsString()
          && info[2]->IsInt32()
          && info[3]->IsInt32()
          && info[4]->IsInt32())
      {
        try
        {
          ::Windows::System::User^ arg0 = dynamic_cast<::Windows::System::User^>(NodeRT::Utils::GetObjectInstance(info[0]));
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[1])));
          ::Windows::Storage::FileAccessMode arg2 = static_cast<::Windows::Storage::FileAccessMode>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          ::Windows::Storage::StorageOpenOptions arg3 = static_cast<::Windows::Storage::StorageOpenOptions>(Nan::To<int32_t>(info[3]).FromMaybe(0));
          ::Windows::Storage::Streams::FileOpenDisposition arg4 = static_cast<::Windows::Storage::Streams::FileOpenDisposition>(Nan::To<int32_t>(info[4]).FromMaybe(0));
            
          op = ::Windows::Storage::Streams::FileRandomAccessStream::OpenForUserAsync(arg0,arg1,arg2,arg3,arg4);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IRandomAccessStream^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapIRandomAccessStream(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void OpenTransactedWriteForUserAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageStreamTransaction^>^ op;


      if (info.Length() == 3
          && NodeRT::Utils::IsWinRtWrapperOf<::Windows::System::User^>(info[0])
          && info[1]->IsString())
      {
        try
        {
          ::Windows::System::User^ arg0 = dynamic_cast<::Windows::System::User^>(NodeRT::Utils::GetObjectInstance(info[0]));
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[1])));
            
          op = ::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteForUserAsync(arg0,arg1);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 5
          && NodeRT::Utils::IsWinRtWrapperOf<::Windows::System::User^>(info[0])
          && info[1]->IsString()
          && info[2]->IsInt32()
          && info[3]->IsInt32())
      {
        try
        {
          ::Windows::System::User^ arg0 = dynamic_cast<::Windows::System::User^>(NodeRT::Utils::GetObjectInstance(info[0]));
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[1])));
          ::Windows::Storage::StorageOpenOptions arg2 = static_cast<::Windows::Storage::StorageOpenOptions>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          ::Windows::Storage::Streams::FileOpenDisposition arg3 = static_cast<::Windows::Storage::Streams::FileOpenDisposition>(Nan::To<int32_t>(info[3]).FromMaybe(0));
            
          op = ::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteForUserAsync(arg0,arg1,arg2,arg3);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageStreamTransaction^> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage", "StorageStreamTransaction", result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void SizeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->Size;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SizeSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsNumber()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      try {

        unsigned __int64 winRtValue = static_cast<unsigned __int64>(Nan::To<int64_t>(value).FromMaybe(0));

        wrapper->_instance->Size = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void CanReadGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      try  {
        bool result = wrapper->_instance->CanRead;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CanWriteGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      try  {
        bool result = wrapper->_instance->CanWrite;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PositionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This())) {
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->Position;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Storage::Streams::FileRandomAccessStream^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapFileRandomAccessStream(::Windows::Storage::Streams::FileRandomAccessStream^ wintRtInstance);
      friend ::Windows::Storage::Streams::FileRandomAccessStream^ UnwrapFileRandomAccessStream(Local<Value> value);
  };

  Persistent<FunctionTemplate> FileRandomAccessStream::s_constructorTemplate;

  v8::Local<v8::Value> WrapFileRandomAccessStream(::Windows::Storage::Streams::FileRandomAccessStream^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(FileRandomAccessStream::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::FileRandomAccessStream^ UnwrapFileRandomAccessStream(Local<Value> value) {
     return FileRandomAccessStream::Unwrap<FileRandomAccessStream>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitFileRandomAccessStream(Local<Object> exports) {
    FileRandomAccessStream::Init(exports);
  }

  class IBuffer : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IBuffer").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("capacity").ToLocalChecked(), CapacityGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("length").ToLocalChecked(), LengthGetter, LengthSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IBuffer").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IBuffer(::Windows::Storage::Streams::IBuffer^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::IBuffer^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::IBuffer^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IBuffer *wrapperInstance = new IBuffer(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::IBuffer^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::IBuffer^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIBuffer(winRtInstance));
    }





    static void CapacityGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info.This())) {
        return;
      }

      IBuffer *wrapper = IBuffer::Unwrap<IBuffer>(info.This());

      try  {
        unsigned int result = wrapper->_instance->Capacity;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void LengthGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info.This())) {
        return;
      }

      IBuffer *wrapper = IBuffer::Unwrap<IBuffer>(info.This());

      try  {
        unsigned int result = wrapper->_instance->Length;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void LengthSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsUint32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info.This())) {
        return;
      }

      IBuffer *wrapper = IBuffer::Unwrap<IBuffer>(info.This());

      try {

        unsigned int winRtValue = static_cast<unsigned int>(Nan::To<uint32_t>(value).FromMaybe(0));

        wrapper->_instance->Length = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Storage::Streams::IBuffer^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIBuffer(::Windows::Storage::Streams::IBuffer^ wintRtInstance);
      friend ::Windows::Storage::Streams::IBuffer^ UnwrapIBuffer(Local<Value> value);
  };

  Persistent<FunctionTemplate> IBuffer::s_constructorTemplate;

  v8::Local<v8::Value> WrapIBuffer(::Windows::Storage::Streams::IBuffer^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IBuffer::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::IBuffer^ UnwrapIBuffer(Local<Value> value) {
     return IBuffer::Unwrap<IBuffer>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIBuffer(Local<Object> exports) {
    IBuffer::Init(exports);
  }

  class IContentTypeProvider : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IContentTypeProvider").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);





          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("contentType").ToLocalChecked(), ContentTypeGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IContentTypeProvider").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IContentTypeProvider(::Windows::Storage::Streams::IContentTypeProvider^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::IContentTypeProvider^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IContentTypeProvider^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::IContentTypeProvider^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IContentTypeProvider *wrapperInstance = new IContentTypeProvider(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IContentTypeProvider^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::IContentTypeProvider^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::IContentTypeProvider^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIContentTypeProvider(winRtInstance));
    }





    static void ContentTypeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IContentTypeProvider^>(info.This())) {
        return;
      }

      IContentTypeProvider *wrapper = IContentTypeProvider::Unwrap<IContentTypeProvider>(info.This());

      try  {
        Platform::String^ result = wrapper->_instance->ContentType;
        info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Storage::Streams::IContentTypeProvider^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIContentTypeProvider(::Windows::Storage::Streams::IContentTypeProvider^ wintRtInstance);
      friend ::Windows::Storage::Streams::IContentTypeProvider^ UnwrapIContentTypeProvider(Local<Value> value);
  };

  Persistent<FunctionTemplate> IContentTypeProvider::s_constructorTemplate;

  v8::Local<v8::Value> WrapIContentTypeProvider(::Windows::Storage::Streams::IContentTypeProvider^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IContentTypeProvider::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::IContentTypeProvider^ UnwrapIContentTypeProvider(Local<Value> value) {
     return IContentTypeProvider::Unwrap<IContentTypeProvider>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIContentTypeProvider(Local<Object> exports) {
    IContentTypeProvider::Init(exports);
  }

  class IDataReader : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IDataReader").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "readByte", ReadByte);
            Nan::SetPrototypeMethod(localRef, "readBytes", ReadBytes);
            Nan::SetPrototypeMethod(localRef, "readBuffer", ReadBuffer);
            Nan::SetPrototypeMethod(localRef, "readBoolean", ReadBoolean);
            Nan::SetPrototypeMethod(localRef, "readGuid", ReadGuid);
            Nan::SetPrototypeMethod(localRef, "readInt16", ReadInt16);
            Nan::SetPrototypeMethod(localRef, "readInt32", ReadInt32);
            Nan::SetPrototypeMethod(localRef, "readInt64", ReadInt64);
            Nan::SetPrototypeMethod(localRef, "readUInt16", ReadUInt16);
            Nan::SetPrototypeMethod(localRef, "readUInt32", ReadUInt32);
            Nan::SetPrototypeMethod(localRef, "readUInt64", ReadUInt64);
            Nan::SetPrototypeMethod(localRef, "readSingle", ReadSingle);
            Nan::SetPrototypeMethod(localRef, "readDouble", ReadDouble);
            Nan::SetPrototypeMethod(localRef, "readString", ReadString);
            Nan::SetPrototypeMethod(localRef, "readDateTime", ReadDateTime);
            Nan::SetPrototypeMethod(localRef, "readTimeSpan", ReadTimeSpan);
            Nan::SetPrototypeMethod(localRef, "detachBuffer", DetachBuffer);
            Nan::SetPrototypeMethod(localRef, "detachStream", DetachStream);
          

          
            Nan::SetPrototypeMethod(localRef, "loadAsync", LoadAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("byteOrder").ToLocalChecked(), ByteOrderGetter, ByteOrderSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("inputStreamOptions").ToLocalChecked(), InputStreamOptionsGetter, InputStreamOptionsSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("unconsumedBufferLength").ToLocalChecked(), UnconsumedBufferLengthGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("unicodeEncoding").ToLocalChecked(), UnicodeEncodingGetter, UnicodeEncodingSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IDataReader").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IDataReader(::Windows::Storage::Streams::IDataReader^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::IDataReader^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::IDataReader^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IDataReader *wrapperInstance = new IDataReader(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::IDataReader^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::IDataReader^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIDataReader(winRtInstance));
    }

    static void LoadAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      ::Windows::Storage::Streams::DataReaderLoadOperation^ op;


      if (info.Length() == 2
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          op = wrapper->_instance->LoadAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void ReadByte(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned char result;
          result = wrapper->_instance->ReadByte();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadBytes(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Not implemented")));
    }
    static void ReadBuffer(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          ::Windows::Storage::Streams::IBuffer^ result;
          result = wrapper->_instance->ReadBuffer(arg0);
          info.GetReturnValue().Set(WrapIBuffer(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadBoolean(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          bool result;
          result = wrapper->_instance->ReadBoolean();
          info.GetReturnValue().Set(Nan::New<Boolean>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadGuid(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Platform::Guid result;
          result = wrapper->_instance->ReadGuid();
          info.GetReturnValue().Set(NodeRT::Utils::GuidToJs(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadInt16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          short result;
          result = wrapper->_instance->ReadInt16();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadInt32(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          int result;
          result = wrapper->_instance->ReadInt32();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadInt64(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          __int64 result;
          result = wrapper->_instance->ReadInt64();
          info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadUInt16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned short result;
          result = wrapper->_instance->ReadUInt16();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadUInt32(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned int result;
          result = wrapper->_instance->ReadUInt32();
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadUInt64(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          unsigned __int64 result;
          result = wrapper->_instance->ReadUInt64();
          info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadSingle(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          float result;
          result = wrapper->_instance->ReadSingle();
          info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadDouble(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          double result;
          result = wrapper->_instance->ReadDouble();
          info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadString(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          Platform::String^ result;
          result = wrapper->_instance->ReadString(arg0);
          info.GetReturnValue().Set(NodeRT::Utils::NewString(result->Data()));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadDateTime(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::DateTime result;
          result = wrapper->_instance->ReadDateTime();
          info.GetReturnValue().Set(NodeRT::Utils::DateTimeToJS(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void ReadTimeSpan(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::TimeSpan result;
          result = wrapper->_instance->ReadTimeSpan();
          info.GetReturnValue().Set(Nan::New<Number>(result.Duration/10000.0));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void DetachBuffer(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ result;
          result = wrapper->_instance->DetachBuffer();
          info.GetReturnValue().Set(WrapIBuffer(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void DetachStream(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->DetachStream();
          info.GetReturnValue().Set(WrapIInputStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void ByteOrderGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try  {
        ::Windows::Storage::Streams::ByteOrder result = wrapper->_instance->ByteOrder;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ByteOrderSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try {

        ::Windows::Storage::Streams::ByteOrder winRtValue = static_cast<::Windows::Storage::Streams::ByteOrder>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->ByteOrder = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void InputStreamOptionsGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try  {
        ::Windows::Storage::Streams::InputStreamOptions result = wrapper->_instance->InputStreamOptions;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void InputStreamOptionsSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try {

        ::Windows::Storage::Streams::InputStreamOptions winRtValue = static_cast<::Windows::Storage::Streams::InputStreamOptions>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->InputStreamOptions = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void UnconsumedBufferLengthGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try  {
        unsigned int result = wrapper->_instance->UnconsumedBufferLength;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UnicodeEncodingGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try  {
        ::Windows::Storage::Streams::UnicodeEncoding result = wrapper->_instance->UnicodeEncoding;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UnicodeEncodingSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This())) {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try {

        ::Windows::Storage::Streams::UnicodeEncoding winRtValue = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->UnicodeEncoding = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Storage::Streams::IDataReader^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIDataReader(::Windows::Storage::Streams::IDataReader^ wintRtInstance);
      friend ::Windows::Storage::Streams::IDataReader^ UnwrapIDataReader(Local<Value> value);
  };

  Persistent<FunctionTemplate> IDataReader::s_constructorTemplate;

  v8::Local<v8::Value> WrapIDataReader(::Windows::Storage::Streams::IDataReader^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IDataReader::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::IDataReader^ UnwrapIDataReader(Local<Value> value) {
     return IDataReader::Unwrap<IDataReader>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIDataReader(Local<Object> exports) {
    IDataReader::Init(exports);
  }

  class IDataWriter : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IDataWriter").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "writeByte", WriteByte);
            Nan::SetPrototypeMethod(localRef, "writeBytes", WriteBytes);
            Nan::SetPrototypeMethod(localRef, "writeBuffer", WriteBuffer);
            Nan::SetPrototypeMethod(localRef, "writeBoolean", WriteBoolean);
            Nan::SetPrototypeMethod(localRef, "writeGuid", WriteGuid);
            Nan::SetPrototypeMethod(localRef, "writeInt16", WriteInt16);
            Nan::SetPrototypeMethod(localRef, "writeInt32", WriteInt32);
            Nan::SetPrototypeMethod(localRef, "writeInt64", WriteInt64);
            Nan::SetPrototypeMethod(localRef, "writeUInt16", WriteUInt16);
            Nan::SetPrototypeMethod(localRef, "writeUInt32", WriteUInt32);
            Nan::SetPrototypeMethod(localRef, "writeUInt64", WriteUInt64);
            Nan::SetPrototypeMethod(localRef, "writeSingle", WriteSingle);
            Nan::SetPrototypeMethod(localRef, "writeDouble", WriteDouble);
            Nan::SetPrototypeMethod(localRef, "writeDateTime", WriteDateTime);
            Nan::SetPrototypeMethod(localRef, "writeTimeSpan", WriteTimeSpan);
            Nan::SetPrototypeMethod(localRef, "writeString", WriteString);
            Nan::SetPrototypeMethod(localRef, "measureString", MeasureString);
            Nan::SetPrototypeMethod(localRef, "detachBuffer", DetachBuffer);
            Nan::SetPrototypeMethod(localRef, "detachStream", DetachStream);
          

          
            Nan::SetPrototypeMethod(localRef, "storeAsync", StoreAsync);
            Nan::SetPrototypeMethod(localRef, "flushAsync", FlushAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("byteOrder").ToLocalChecked(), ByteOrderGetter, ByteOrderSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("unicodeEncoding").ToLocalChecked(), UnicodeEncodingGetter, UnicodeEncodingSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("unstoredBufferLength").ToLocalChecked(), UnstoredBufferLengthGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IDataWriter").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IDataWriter(::Windows::Storage::Streams::IDataWriter^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::IDataWriter^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::IDataWriter^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IDataWriter *wrapperInstance = new IDataWriter(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::IDataWriter^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::IDataWriter^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIDataWriter(winRtInstance));
    }

    static void StoreAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      ::Windows::Storage::Streams::DataWriterStoreOperation^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->StoreAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void FlushAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Boolean>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void WriteByte(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned char arg0 = static_cast<unsigned char>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteByte(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteBytes(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned char>^>(info[0]) || info[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<unsigned char>^ arg0 = 
            [] (v8::Local<v8::Value> value) -> ::Platform::Array<unsigned char>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned char>(value.As<Array>(), 
                 [](Local<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Local<Value> value) -> unsigned char {
                   return static_cast<unsigned char>(Nan::To<int32_t>(value).FromMaybe(0));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned char>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (info[0]);
          
          wrapper->_instance->WriteBytes(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteBuffer(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          
          wrapper->_instance->WriteBuffer(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])
        && info[1]->IsUint32()
        && info[2]->IsUint32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          unsigned int arg1 = static_cast<unsigned int>(Nan::To<uint32_t>(info[1]).FromMaybe(0));
          unsigned int arg2 = static_cast<unsigned int>(Nan::To<uint32_t>(info[2]).FromMaybe(0));
          
          wrapper->_instance->WriteBuffer(arg0, arg1, arg2);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteBoolean(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsBoolean())
      {
        try
        {
          bool arg0 = Nan::To<bool>(info[0]).FromMaybe(false);
          
          wrapper->_instance->WriteBoolean(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteGuid(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && NodeRT::Utils::IsGuid(info[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(info[0]);
          
          wrapper->_instance->WriteGuid(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteInt16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          short arg0 = static_cast<short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteInt16(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteInt32(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          int arg0 = static_cast<int>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteInt32(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteInt64(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          __int64 arg0 = Nan::To<int64_t>(info[0]).FromMaybe(0);
          
          wrapper->_instance->WriteInt64(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteUInt16(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(Nan::To<int32_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteUInt16(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteUInt32(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(Nan::To<uint32_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteUInt32(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteUInt64(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteUInt64(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteSingle(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          float arg0 = static_cast<float>(Nan::To<double>(info[0]).FromMaybe(0.0));
          
          wrapper->_instance->WriteSingle(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteDouble(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          double arg0 = Nan::To<double>(info[0]).FromMaybe(0.0);
          
          wrapper->_instance->WriteDouble(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteDateTime(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsDate())
      {
        try
        {
          ::Windows::Foundation::DateTime arg0 = NodeRT::Utils::DateTimeFromJSDate(info[0]);
          
          wrapper->_instance->WriteDateTime(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteTimeSpan(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          ::Windows::Foundation::TimeSpan arg0 = NodeRT::Utils::TimeSpanFromMilli(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->WriteTimeSpan(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void WriteString(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          unsigned int result;
          result = wrapper->_instance->WriteString(arg0);
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void MeasureString(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 1
        && info[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(v8::Isolate::GetCurrent(), info[0])));
          
          unsigned int result;
          result = wrapper->_instance->MeasureString(arg0);
          info.GetReturnValue().Set(Nan::New<Integer>(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void DetachBuffer(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ result;
          result = wrapper->_instance->DetachBuffer();
          info.GetReturnValue().Set(WrapIBuffer(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void DetachStream(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->DetachStream();
          info.GetReturnValue().Set(WrapIOutputStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void ByteOrderGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      try  {
        ::Windows::Storage::Streams::ByteOrder result = wrapper->_instance->ByteOrder;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void ByteOrderSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      try {

        ::Windows::Storage::Streams::ByteOrder winRtValue = static_cast<::Windows::Storage::Streams::ByteOrder>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->ByteOrder = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void UnicodeEncodingGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      try  {
        ::Windows::Storage::Streams::UnicodeEncoding result = wrapper->_instance->UnicodeEncoding;
        info.GetReturnValue().Set(Nan::New<Integer>(static_cast<int>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void UnicodeEncodingSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsInt32()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      try {

        ::Windows::Storage::Streams::UnicodeEncoding winRtValue = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(Nan::To<int32_t>(value).FromMaybe(0));

        wrapper->_instance->UnicodeEncoding = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void UnstoredBufferLengthGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This())) {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      try  {
        unsigned int result = wrapper->_instance->UnstoredBufferLength;
        info.GetReturnValue().Set(Nan::New<Integer>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Storage::Streams::IDataWriter^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIDataWriter(::Windows::Storage::Streams::IDataWriter^ wintRtInstance);
      friend ::Windows::Storage::Streams::IDataWriter^ UnwrapIDataWriter(Local<Value> value);
  };

  Persistent<FunctionTemplate> IDataWriter::s_constructorTemplate;

  v8::Local<v8::Value> WrapIDataWriter(::Windows::Storage::Streams::IDataWriter^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IDataWriter::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::IDataWriter^ UnwrapIDataWriter(Local<Value> value) {
     return IDataWriter::Unwrap<IDataWriter>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIDataWriter(Local<Object> exports) {
    IDataWriter::Init(exports);
  }

  class IInputStream : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IInputStream").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;


          
            Nan::SetPrototypeMethod(localRef, "readAsync", ReadAsync);
          



        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IInputStream").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IInputStream(::Windows::Storage::Streams::IInputStream^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::IInputStream^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::IInputStream^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IInputStream *wrapperInstance = new IInputStream(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::IInputStream^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::IInputStream^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIInputStream(winRtInstance));
    }

    static void ReadAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      IInputStream *wrapper = IInputStream::Unwrap<IInputStream>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;


      if (info.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])
        && info[1]->IsUint32()
        && info[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          unsigned int arg1 = static_cast<unsigned int>(Nan::To<uint32_t>(info[1]).FromMaybe(0));
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapIBuffer(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }






    private:
      ::Windows::Storage::Streams::IInputStream^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIInputStream(::Windows::Storage::Streams::IInputStream^ wintRtInstance);
      friend ::Windows::Storage::Streams::IInputStream^ UnwrapIInputStream(Local<Value> value);
  };

  Persistent<FunctionTemplate> IInputStream::s_constructorTemplate;

  v8::Local<v8::Value> WrapIInputStream(::Windows::Storage::Streams::IInputStream^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IInputStream::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::IInputStream^ UnwrapIInputStream(Local<Value> value) {
     return IInputStream::Unwrap<IInputStream>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIInputStream(Local<Object> exports) {
    IInputStream::Init(exports);
  }

  class IInputStreamReference : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IInputStreamReference").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;


          
            Nan::SetPrototypeMethod(localRef, "openSequentialReadAsync", OpenSequentialReadAsync);
          



        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IInputStreamReference").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IInputStreamReference(::Windows::Storage::Streams::IInputStreamReference^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::IInputStreamReference^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStreamReference^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::IInputStreamReference^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IInputStreamReference *wrapperInstance = new IInputStreamReference(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStreamReference^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::IInputStreamReference^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::IInputStreamReference^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIInputStreamReference(winRtInstance));
    }

    static void OpenSequentialReadAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStreamReference^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      IInputStreamReference *wrapper = IInputStreamReference::Unwrap<IInputStreamReference>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IInputStream^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->OpenSequentialReadAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IInputStream^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapIInputStream(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }






    private:
      ::Windows::Storage::Streams::IInputStreamReference^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIInputStreamReference(::Windows::Storage::Streams::IInputStreamReference^ wintRtInstance);
      friend ::Windows::Storage::Streams::IInputStreamReference^ UnwrapIInputStreamReference(Local<Value> value);
  };

  Persistent<FunctionTemplate> IInputStreamReference::s_constructorTemplate;

  v8::Local<v8::Value> WrapIInputStreamReference(::Windows::Storage::Streams::IInputStreamReference^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IInputStreamReference::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::IInputStreamReference^ UnwrapIInputStreamReference(Local<Value> value) {
     return IInputStreamReference::Unwrap<IInputStreamReference>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIInputStreamReference(Local<Object> exports) {
    IInputStreamReference::Init(exports);
  }

  class IOutputStream : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IOutputStream").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;


          
            Nan::SetPrototypeMethod(localRef, "writeAsync", WriteAsync);
            Nan::SetPrototypeMethod(localRef, "flushAsync", FlushAsync);
          



        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IOutputStream").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IOutputStream(::Windows::Storage::Streams::IOutputStream^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::IOutputStream^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::IOutputStream^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IOutputStream *wrapperInstance = new IOutputStream(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::IOutputStream^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::IOutputStream^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIOutputStream(winRtInstance));
    }

    static void WriteAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      IOutputStream *wrapper = IOutputStream::Unwrap<IOutputStream>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void FlushAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      IOutputStream *wrapper = IOutputStream::Unwrap<IOutputStream>(info.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Boolean>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }






    private:
      ::Windows::Storage::Streams::IOutputStream^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIOutputStream(::Windows::Storage::Streams::IOutputStream^ wintRtInstance);
      friend ::Windows::Storage::Streams::IOutputStream^ UnwrapIOutputStream(Local<Value> value);
  };

  Persistent<FunctionTemplate> IOutputStream::s_constructorTemplate;

  v8::Local<v8::Value> WrapIOutputStream(::Windows::Storage::Streams::IOutputStream^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IOutputStream::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::IOutputStream^ UnwrapIOutputStream(Local<Value> value) {
     return IOutputStream::Unwrap<IOutputStream>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIOutputStream(Local<Object> exports) {
    IOutputStream::Init(exports);
  }

  class IRandomAccessStream : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IRandomAccessStream").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);


          
            Nan::SetPrototypeMethod(localRef, "getInputStreamAt", GetInputStreamAt);
            Nan::SetPrototypeMethod(localRef, "getOutputStreamAt", GetOutputStreamAt);
            Nan::SetPrototypeMethod(localRef, "seek", Seek);
            Nan::SetPrototypeMethod(localRef, "cloneStream", CloneStream);
          



          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("canRead").ToLocalChecked(), CanReadGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("canWrite").ToLocalChecked(), CanWriteGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("position").ToLocalChecked(), PositionGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("size").ToLocalChecked(), SizeGetter, SizeSetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IRandomAccessStream").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IRandomAccessStream(::Windows::Storage::Streams::IRandomAccessStream^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::IRandomAccessStream^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::IRandomAccessStream^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IRandomAccessStream *wrapperInstance = new IRandomAccessStream(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::IRandomAccessStream^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::IRandomAccessStream^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIRandomAccessStream(winRtInstance));
    }


    static void GetInputStreamAt(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This())) {
        return;
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->GetInputStreamAt(arg0);
          info.GetReturnValue().Set(WrapIInputStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetOutputStreamAt(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This())) {
        return;
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->GetOutputStreamAt(arg0);
          info.GetReturnValue().Set(WrapIOutputStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Seek(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This())) {
        return;
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->Seek(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void CloneStream(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This())) {
        return;
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IRandomAccessStream^ result;
          result = wrapper->_instance->CloneStream();
          info.GetReturnValue().Set(WrapIRandomAccessStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void CanReadGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This())) {
        return;
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      try  {
        bool result = wrapper->_instance->CanRead;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CanWriteGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This())) {
        return;
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      try  {
        bool result = wrapper->_instance->CanWrite;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PositionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This())) {
        return;
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->Position;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SizeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This())) {
        return;
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->Size;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SizeSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsNumber()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This())) {
        return;
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      try {

        unsigned __int64 winRtValue = static_cast<unsigned __int64>(Nan::To<int64_t>(value).FromMaybe(0));

        wrapper->_instance->Size = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      


    private:
      ::Windows::Storage::Streams::IRandomAccessStream^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIRandomAccessStream(::Windows::Storage::Streams::IRandomAccessStream^ wintRtInstance);
      friend ::Windows::Storage::Streams::IRandomAccessStream^ UnwrapIRandomAccessStream(Local<Value> value);
  };

  Persistent<FunctionTemplate> IRandomAccessStream::s_constructorTemplate;

  v8::Local<v8::Value> WrapIRandomAccessStream(::Windows::Storage::Streams::IRandomAccessStream^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IRandomAccessStream::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::IRandomAccessStream^ UnwrapIRandomAccessStream(Local<Value> value) {
     return IRandomAccessStream::Unwrap<IRandomAccessStream>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIRandomAccessStream(Local<Object> exports) {
    IRandomAccessStream::Init(exports);
  }

  class IRandomAccessStreamReference : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IRandomAccessStreamReference").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;


          
            Nan::SetPrototypeMethod(localRef, "openReadAsync", OpenReadAsync);
          



        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IRandomAccessStreamReference").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IRandomAccessStreamReference(::Windows::Storage::Streams::IRandomAccessStreamReference^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::IRandomAccessStreamReference^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStreamReference^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::IRandomAccessStreamReference^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IRandomAccessStreamReference *wrapperInstance = new IRandomAccessStreamReference(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStreamReference^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::IRandomAccessStreamReference^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::IRandomAccessStreamReference^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIRandomAccessStreamReference(winRtInstance));
    }

    static void OpenReadAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStreamReference^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      IRandomAccessStreamReference *wrapper = IRandomAccessStreamReference::Unwrap<IRandomAccessStreamReference>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->OpenReadAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapIRandomAccessStreamWithContentType(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }






    private:
      ::Windows::Storage::Streams::IRandomAccessStreamReference^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIRandomAccessStreamReference(::Windows::Storage::Streams::IRandomAccessStreamReference^ wintRtInstance);
      friend ::Windows::Storage::Streams::IRandomAccessStreamReference^ UnwrapIRandomAccessStreamReference(Local<Value> value);
  };

  Persistent<FunctionTemplate> IRandomAccessStreamReference::s_constructorTemplate;

  v8::Local<v8::Value> WrapIRandomAccessStreamReference(::Windows::Storage::Streams::IRandomAccessStreamReference^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IRandomAccessStreamReference::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::IRandomAccessStreamReference^ UnwrapIRandomAccessStreamReference(Local<Value> value) {
     return IRandomAccessStreamReference::Unwrap<IRandomAccessStreamReference>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIRandomAccessStreamReference(Local<Object> exports) {
    IRandomAccessStreamReference::Init(exports);
  }

  class IRandomAccessStreamWithContentType : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("IRandomAccessStreamWithContentType").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);






        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("IRandomAccessStreamWithContentType").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      IRandomAccessStreamWithContentType(::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::IRandomAccessStreamWithContentType^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      IRandomAccessStreamWithContentType *wrapperInstance = new IRandomAccessStreamWithContentType(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::IRandomAccessStreamWithContentType^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapIRandomAccessStreamWithContentType(winRtInstance));
    }







    private:
      ::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapIRandomAccessStreamWithContentType(::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ wintRtInstance);
      friend ::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ UnwrapIRandomAccessStreamWithContentType(Local<Value> value);
  };

  Persistent<FunctionTemplate> IRandomAccessStreamWithContentType::s_constructorTemplate;

  v8::Local<v8::Value> WrapIRandomAccessStreamWithContentType(::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(IRandomAccessStreamWithContentType::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ UnwrapIRandomAccessStreamWithContentType(Local<Value> value) {
     return IRandomAccessStreamWithContentType::Unwrap<IRandomAccessStreamWithContentType>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitIRandomAccessStreamWithContentType(Local<Object> exports) {
    IRandomAccessStreamWithContentType::Init(exports);
  }

  class InMemoryRandomAccessStream : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("InMemoryRandomAccessStream").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "getInputStreamAt", GetInputStreamAt);
            Nan::SetPrototypeMethod(localRef, "getOutputStreamAt", GetOutputStreamAt);
            Nan::SetPrototypeMethod(localRef, "seek", Seek);
            Nan::SetPrototypeMethod(localRef, "cloneStream", CloneStream);
            Nan::SetPrototypeMethod(localRef, "close", Close);
          

          
            Nan::SetPrototypeMethod(localRef, "readAsync", ReadAsync);
            Nan::SetPrototypeMethod(localRef, "writeAsync", WriteAsync);
            Nan::SetPrototypeMethod(localRef, "flushAsync", FlushAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("size").ToLocalChecked(), SizeGetter, SizeSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("canRead").ToLocalChecked(), CanReadGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("canWrite").ToLocalChecked(), CanWriteGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("position").ToLocalChecked(), PositionGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("InMemoryRandomAccessStream").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      InMemoryRandomAccessStream(::Windows::Storage::Streams::InMemoryRandomAccessStream^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::InMemoryRandomAccessStream^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::InMemoryRandomAccessStream^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
      else if (info.Length() == 0)
      {
        try {
          winRtInstance = ref new ::Windows::Storage::Streams::InMemoryRandomAccessStream();
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      InMemoryRandomAccessStream *wrapperInstance = new InMemoryRandomAccessStream(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::InMemoryRandomAccessStream^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::InMemoryRandomAccessStream^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapInMemoryRandomAccessStream(winRtInstance));
    }

    static void ReadAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;


      if (info.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])
        && info[1]->IsUint32()
        && info[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          unsigned int arg1 = static_cast<unsigned int>(Nan::To<uint32_t>(info[1]).FromMaybe(0));
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapIBuffer(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void WriteAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void FlushAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Boolean>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void GetInputStreamAt(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->GetInputStreamAt(arg0);
          info.GetReturnValue().Set(WrapIInputStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetOutputStreamAt(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->GetOutputStreamAt(arg0);
          info.GetReturnValue().Set(WrapIOutputStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Seek(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->Seek(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void CloneStream(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IRandomAccessStream^ result;
          result = wrapper->_instance->CloneStream();
          info.GetReturnValue().Set(WrapIRandomAccessStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void SizeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->Size;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SizeSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsNumber()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      try {

        unsigned __int64 winRtValue = static_cast<unsigned __int64>(Nan::To<int64_t>(value).FromMaybe(0));

        wrapper->_instance->Size = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void CanReadGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      try  {
        bool result = wrapper->_instance->CanRead;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CanWriteGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      try  {
        bool result = wrapper->_instance->CanWrite;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PositionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This())) {
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->Position;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Storage::Streams::InMemoryRandomAccessStream^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapInMemoryRandomAccessStream(::Windows::Storage::Streams::InMemoryRandomAccessStream^ wintRtInstance);
      friend ::Windows::Storage::Streams::InMemoryRandomAccessStream^ UnwrapInMemoryRandomAccessStream(Local<Value> value);
  };

  Persistent<FunctionTemplate> InMemoryRandomAccessStream::s_constructorTemplate;

  v8::Local<v8::Value> WrapInMemoryRandomAccessStream(::Windows::Storage::Streams::InMemoryRandomAccessStream^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(InMemoryRandomAccessStream::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::InMemoryRandomAccessStream^ UnwrapInMemoryRandomAccessStream(Local<Value> value) {
     return InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitInMemoryRandomAccessStream(Local<Object> exports) {
    InMemoryRandomAccessStream::Init(exports);
  }

  class InputStreamOverStream : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("InputStreamOverStream").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "close", Close);
          

          
            Nan::SetPrototypeMethod(localRef, "readAsync", ReadAsync);
          



        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("InputStreamOverStream").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      InputStreamOverStream(::Windows::Storage::Streams::InputStreamOverStream^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::InputStreamOverStream^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InputStreamOverStream^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::InputStreamOverStream^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      InputStreamOverStream *wrapperInstance = new InputStreamOverStream(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InputStreamOverStream^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::InputStreamOverStream^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::InputStreamOverStream^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapInputStreamOverStream(winRtInstance));
    }

    static void ReadAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InputStreamOverStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      InputStreamOverStream *wrapper = InputStreamOverStream::Unwrap<InputStreamOverStream>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;


      if (info.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])
        && info[1]->IsUint32()
        && info[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          unsigned int arg1 = static_cast<unsigned int>(Nan::To<uint32_t>(info[1]).FromMaybe(0));
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapIBuffer(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InputStreamOverStream^>(info.This())) {
        return;
      }

      InputStreamOverStream *wrapper = InputStreamOverStream::Unwrap<InputStreamOverStream>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }





    private:
      ::Windows::Storage::Streams::InputStreamOverStream^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapInputStreamOverStream(::Windows::Storage::Streams::InputStreamOverStream^ wintRtInstance);
      friend ::Windows::Storage::Streams::InputStreamOverStream^ UnwrapInputStreamOverStream(Local<Value> value);
  };

  Persistent<FunctionTemplate> InputStreamOverStream::s_constructorTemplate;

  v8::Local<v8::Value> WrapInputStreamOverStream(::Windows::Storage::Streams::InputStreamOverStream^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(InputStreamOverStream::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::InputStreamOverStream^ UnwrapInputStreamOverStream(Local<Value> value) {
     return InputStreamOverStream::Unwrap<InputStreamOverStream>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitInputStreamOverStream(Local<Object> exports) {
    InputStreamOverStream::Init(exports);
  }

  class OutputStreamOverStream : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("OutputStreamOverStream").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "close", Close);
          

          
            Nan::SetPrototypeMethod(localRef, "writeAsync", WriteAsync);
            Nan::SetPrototypeMethod(localRef, "flushAsync", FlushAsync);
          



        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("OutputStreamOverStream").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      OutputStreamOverStream(::Windows::Storage::Streams::OutputStreamOverStream^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::OutputStreamOverStream^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::OutputStreamOverStream^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::OutputStreamOverStream^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      OutputStreamOverStream *wrapperInstance = new OutputStreamOverStream(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::OutputStreamOverStream^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::OutputStreamOverStream^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::OutputStreamOverStream^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapOutputStreamOverStream(winRtInstance));
    }

    static void WriteAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::OutputStreamOverStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      OutputStreamOverStream *wrapper = OutputStreamOverStream::Unwrap<OutputStreamOverStream>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void FlushAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::OutputStreamOverStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      OutputStreamOverStream *wrapper = OutputStreamOverStream::Unwrap<OutputStreamOverStream>(info.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Boolean>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }


    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::OutputStreamOverStream^>(info.This())) {
        return;
      }

      OutputStreamOverStream *wrapper = OutputStreamOverStream::Unwrap<OutputStreamOverStream>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }





    private:
      ::Windows::Storage::Streams::OutputStreamOverStream^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapOutputStreamOverStream(::Windows::Storage::Streams::OutputStreamOverStream^ wintRtInstance);
      friend ::Windows::Storage::Streams::OutputStreamOverStream^ UnwrapOutputStreamOverStream(Local<Value> value);
  };

  Persistent<FunctionTemplate> OutputStreamOverStream::s_constructorTemplate;

  v8::Local<v8::Value> WrapOutputStreamOverStream(::Windows::Storage::Streams::OutputStreamOverStream^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(OutputStreamOverStream::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::OutputStreamOverStream^ UnwrapOutputStreamOverStream(Local<Value> value) {
     return OutputStreamOverStream::Unwrap<OutputStreamOverStream>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitOutputStreamOverStream(Local<Object> exports) {
    OutputStreamOverStream::Init(exports);
  }

  class RandomAccessStream : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("RandomAccessStream").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;





        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        func = Nan::GetFunction(Nan::New<FunctionTemplate>(CopyAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("copyAsync").ToLocalChecked(), func);
        func = Nan::GetFunction(Nan::New<FunctionTemplate>(CopyAndCloseAsync)).ToLocalChecked();
        Nan::Set(constructor, Nan::New<String>("copyAndCloseAsync").ToLocalChecked(), func);


        Nan::Set(exports, Nan::New<String>("RandomAccessStream").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      RandomAccessStream(::Windows::Storage::Streams::RandomAccessStream^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::RandomAccessStream^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStream^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::RandomAccessStream^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      RandomAccessStream *wrapperInstance = new RandomAccessStream(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStream^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::RandomAccessStream^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::RandomAccessStream^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapRandomAccessStream(winRtInstance));
    }




    static void CopyAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>^ op;


      if (info.Length() == 3
          && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(info[0])
          && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(info[1]))
      {
        try
        {
          ::Windows::Storage::Streams::IInputStream^ arg0 = UnwrapIInputStream(info[0]);
          ::Windows::Storage::Streams::IOutputStream^ arg1 = UnwrapIOutputStream(info[1]);
            
          op = ::Windows::Storage::Streams::RandomAccessStream::CopyAsync(arg0,arg1);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
      else if (info.Length() == 4
          && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(info[0])
          && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(info[1])
          && info[2]->IsNumber())
      {
        try
        {
          ::Windows::Storage::Streams::IInputStream^ arg0 = UnwrapIInputStream(info[0]);
          ::Windows::Storage::Streams::IOutputStream^ arg1 = UnwrapIOutputStream(info[1]);
          unsigned __int64 arg2 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[2]).FromMaybe(0));
            
          op = ::Windows::Storage::Streams::RandomAccessStream::CopyAsync(arg0,arg1,arg2);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned __int64> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Number>(static_cast<double>(result));
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void CopyAndCloseAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>^ op;


      if (info.Length() == 3
          && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(info[0])
          && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(info[1]))
      {
        try
        {
          ::Windows::Storage::Streams::IInputStream^ arg0 = UnwrapIInputStream(info[0]);
          ::Windows::Storage::Streams::IOutputStream^ arg1 = UnwrapIOutputStream(info[1]);
            
          op = ::Windows::Storage::Streams::RandomAccessStream::CopyAndCloseAsync(arg0,arg1);
        } catch (Platform::Exception ^exception) {
            NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
            return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned __int64> t)
      {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Number>(static_cast<double>(result));
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }




    private:
      ::Windows::Storage::Streams::RandomAccessStream^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapRandomAccessStream(::Windows::Storage::Streams::RandomAccessStream^ wintRtInstance);
      friend ::Windows::Storage::Streams::RandomAccessStream^ UnwrapRandomAccessStream(Local<Value> value);
  };

  Persistent<FunctionTemplate> RandomAccessStream::s_constructorTemplate;

  v8::Local<v8::Value> WrapRandomAccessStream(::Windows::Storage::Streams::RandomAccessStream^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(RandomAccessStream::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::RandomAccessStream^ UnwrapRandomAccessStream(Local<Value> value) {
     return RandomAccessStream::Unwrap<RandomAccessStream>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitRandomAccessStream(Local<Object> exports) {
    RandomAccessStream::Init(exports);
  }

  class RandomAccessStreamOverStream : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("RandomAccessStreamOverStream").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;

          
            Nan::SetPrototypeMethod(localRef, "getInputStreamAt", GetInputStreamAt);
            Nan::SetPrototypeMethod(localRef, "getOutputStreamAt", GetOutputStreamAt);
            Nan::SetPrototypeMethod(localRef, "seek", Seek);
            Nan::SetPrototypeMethod(localRef, "cloneStream", CloneStream);
            Nan::SetPrototypeMethod(localRef, "close", Close);
          

          
            Nan::SetPrototypeMethod(localRef, "readAsync", ReadAsync);
            Nan::SetPrototypeMethod(localRef, "writeAsync", WriteAsync);
            Nan::SetPrototypeMethod(localRef, "flushAsync", FlushAsync);
          


          
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("size").ToLocalChecked(), SizeGetter, SizeSetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("canRead").ToLocalChecked(), CanReadGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("canWrite").ToLocalChecked(), CanWriteGetter);
            Nan::SetAccessor(localRef->PrototypeTemplate(), Nan::New<String>("position").ToLocalChecked(), PositionGetter);

        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);



        Nan::Set(exports, Nan::New<String>("RandomAccessStreamOverStream").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      RandomAccessStreamOverStream(::Windows::Storage::Streams::RandomAccessStreamOverStream^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::RandomAccessStreamOverStream^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::RandomAccessStreamOverStream^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      RandomAccessStreamOverStream *wrapperInstance = new RandomAccessStreamOverStream(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::RandomAccessStreamOverStream^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::RandomAccessStreamOverStream^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapRandomAccessStreamOverStream(winRtInstance));
    }

    static void ReadAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;


      if (info.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0])
        && info[1]->IsUint32()
        && info[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          unsigned int arg1 = static_cast<unsigned int>(Nan::To<uint32_t>(info[1]).FromMaybe(0));
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(Nan::To<int32_t>(info[2]).FromMaybe(0));
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapIBuffer(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void WriteAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;


      if (info.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(info[0]);
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Integer>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }
    static void FlushAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = Nan::New<Boolean>(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }

    static void GetInputStreamAt(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->GetInputStreamAt(arg0);
          info.GetReturnValue().Set(WrapIInputStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void GetOutputStreamAt(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->GetOutputStreamAt(arg0);
          info.GetReturnValue().Set(WrapIOutputStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void Seek(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      if (info.Length() == 1
        && info[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(Nan::To<int64_t>(info[0]).FromMaybe(0));
          
          wrapper->_instance->Seek(arg0);
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }
    static void CloneStream(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      if (info.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IRandomAccessStream^ result;
          result = wrapper->_instance->CloneStream();
          info.GetReturnValue().Set(WrapIRandomAccessStream(result));
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void Close(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      if (info.Length() == 0) {
        try {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return;
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      } else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    static void SizeGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->Size;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void SizeSetter(Local<String> property, Local<Value> value, const Nan::PropertyCallbackInfo<void> &info) {
      HandleScope scope;

      if (!value->IsNumber()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      try {

        unsigned __int64 winRtValue = static_cast<unsigned __int64>(Nan::To<int64_t>(value).FromMaybe(0));

        wrapper->_instance->Size = winRtValue;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
      
    static void CanReadGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      try  {
        bool result = wrapper->_instance->CanRead;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void CanWriteGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      try  {
        bool result = wrapper->_instance->CanWrite;
        info.GetReturnValue().Set(Nan::New<Boolean>(result));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      
    static void PositionGetter(Local<String> property, const Nan::PropertyCallbackInfo<v8::Value> &info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This())) {
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      try  {
        unsigned __int64 result = wrapper->_instance->Position;
        info.GetReturnValue().Set(Nan::New<Number>(static_cast<double>(result)));
        return;
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }
    }
      


    private:
      ::Windows::Storage::Streams::RandomAccessStreamOverStream^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapRandomAccessStreamOverStream(::Windows::Storage::Streams::RandomAccessStreamOverStream^ wintRtInstance);
      friend ::Windows::Storage::Streams::RandomAccessStreamOverStream^ UnwrapRandomAccessStreamOverStream(Local<Value> value);
  };

  Persistent<FunctionTemplate> RandomAccessStreamOverStream::s_constructorTemplate;

  v8::Local<v8::Value> WrapRandomAccessStreamOverStream(::Windows::Storage::Streams::RandomAccessStreamOverStream^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(RandomAccessStreamOverStream::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::RandomAccessStreamOverStream^ UnwrapRandomAccessStreamOverStream(Local<Value> value) {
     return RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitRandomAccessStreamOverStream(Local<Object> exports) {
    RandomAccessStreamOverStream::Init(exports);
  }

  class RandomAccessStreamReference : public WrapperBase {
    public:
      
      static void Init(const Local<Object> exports) {
        HandleScope scope;

        Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(New);
        s_constructorTemplate.Reset(localRef);
        localRef->SetClassName(Nan::New<String>("RandomAccessStreamReference").ToLocalChecked());
        localRef->InstanceTemplate()->SetInternalFieldCount(1);

        Local<Function> func;
        Local<FunctionTemplate> funcTemplate;


          
            Nan::SetPrototypeMethod(localRef, "openReadAsync", OpenReadAsync);
          



        Local<Object> constructor = Nan::To<Object>(Nan::GetFunction(localRef).ToLocalChecked()).ToLocalChecked();
        Nan::SetMethod(constructor, "castFrom", CastFrom);

        Nan::SetMethod(constructor, "createFromFile", CreateFromFile);
        Nan::SetMethod(constructor, "createFromUri", CreateFromUri);
        Nan::SetMethod(constructor, "createFromStream", CreateFromStream);


        Nan::Set(exports, Nan::New<String>("RandomAccessStreamReference").ToLocalChecked(), constructor);
      }

      virtual ::Platform::Object^ GetObjectInstance() const override {
        return _instance;
      }

    private:

      RandomAccessStreamReference(::Windows::Storage::Streams::RandomAccessStreamReference^ instance) {
        _instance = instance;
      }

      
    static void New(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(s_constructorTemplate);

      // in case the constructor was called without the new operator
      if (!localRef->HasInstance(info.This())) {
        if (info.Length() > 0) {
          std::unique_ptr<Local<Value> []> constructorArgs(new Local<Value>[info.Length()]);

          Local<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < info.Length(); i++) {
            argsPtr[i] = info[i];
          }

          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), constructorArgs.get());
          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        } else {
          MaybeLocal<Object> res = Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(), info.Length(), nullptr);

          if (res.IsEmpty()) {
            return;
          }

          info.GetReturnValue().Set(res.ToLocalChecked());
          return;
        }
      }

      ::Windows::Storage::Streams::RandomAccessStreamReference^ winRtInstance;


      if (info.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(info[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamReference^>(info[0])) {
        try {
          winRtInstance = (::Windows::Storage::Streams::RandomAccessStreamReference^) NodeRT::Utils::GetObjectInstance(info[0]);
        } catch (Platform::Exception ^exception) {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return;
      }

      NodeRT::Utils::SetHiddenValue(info.This(), Nan::New<String>("__winRtInstance__").ToLocalChecked(), True());

      RandomAccessStreamReference *wrapperInstance = new RandomAccessStreamReference(winRtInstance);
      wrapperInstance->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }


      
    static void CastFrom(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;
      if (info.Length() < 1 || !NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamReference^>(info[0])) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Invalid arguments, no object provided, or given object could not be casted to requested type")));
        return;
      }

      ::Windows::Storage::Streams::RandomAccessStreamReference^ winRtInstance;
      try {
        winRtInstance = (::Windows::Storage::Streams::RandomAccessStreamReference^) NodeRT::Utils::GetObjectInstance(info[0]);
      } catch (Platform::Exception ^exception) {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return;
      }

      info.GetReturnValue().Set(WrapRandomAccessStreamReference(winRtInstance));
    }

    static void OpenReadAsync(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamReference^>(info.This())) {
        return;
      }

      if (info.Length() == 0 || !info[info.Length() -1]->IsFunction()) {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
        return;
      }

      RandomAccessStreamReference *wrapper = RandomAccessStreamReference::Unwrap<RandomAccessStreamReference>(info.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^>^ op;


      if (info.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->OpenReadAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }

      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(info[info.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^> t) {
        try {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Local<Value> error;
            Local<Value> arg1;
            {
              TryCatch tryCatch;
              arg1 = WrapIRandomAccessStreamWithContentType(result);
              if (tryCatch.HasCaught())
              {
                error = Nan::To<Object>(tryCatch.Exception()).ToLocalChecked();
              }
              else
              {
                error = Undefined();
              }
              if (arg1.IsEmpty()) arg1 = Undefined();
            }
            Local<Value> args[] = {error, arg1};


            invokeCallback(_countof(args), args);
          });
        } catch (Platform::Exception^ exception) {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
            Local<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);

            Local<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }
      });
    }




    static void CreateFromFile(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(info[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = dynamic_cast<::Windows::Storage::IStorageFile^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          ::Windows::Storage::Streams::RandomAccessStreamReference^ result;
          result = ::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromFile(arg0);
          info.GetReturnValue().Set(WrapRandomAccessStreamReference(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateFromUri(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info[0]))
      {
        try
        {
          ::Windows::Foundation::Uri^ arg0 = dynamic_cast<::Windows::Foundation::Uri^>(NodeRT::Utils::GetObjectInstance(info[0]));
          
          ::Windows::Storage::Streams::RandomAccessStreamReference^ result;
          result = ::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromUri(arg0);
          info.GetReturnValue().Set(WrapRandomAccessStreamReference(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }

    static void CreateFromStream(Nan::NAN_METHOD_ARGS_TYPE info) {
      HandleScope scope;

      if (info.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IRandomAccessStream^ arg0 = UnwrapIRandomAccessStream(info[0]);
          
          ::Windows::Storage::Streams::RandomAccessStreamReference^ result;
          result = ::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromStream(arg0);
          info.GetReturnValue().Set(WrapRandomAccessStreamReference(result));
          return;
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return;
        }
      }
 else  {
        Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return;
      }
    }



    private:
      ::Windows::Storage::Streams::RandomAccessStreamReference^ _instance;
      static Persistent<FunctionTemplate> s_constructorTemplate;

      friend v8::Local<v8::Value> WrapRandomAccessStreamReference(::Windows::Storage::Streams::RandomAccessStreamReference^ wintRtInstance);
      friend ::Windows::Storage::Streams::RandomAccessStreamReference^ UnwrapRandomAccessStreamReference(Local<Value> value);
  };

  Persistent<FunctionTemplate> RandomAccessStreamReference::s_constructorTemplate;

  v8::Local<v8::Value> WrapRandomAccessStreamReference(::Windows::Storage::Streams::RandomAccessStreamReference^ winRtInstance) {
    EscapableHandleScope scope;

    if (winRtInstance == nullptr) {
      return scope.Escape(Undefined());
    }

    Local<Value> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Local<Value> args[] = {opaqueWrapper};
    Local<FunctionTemplate> localRef = Nan::New<FunctionTemplate>(RandomAccessStreamReference::s_constructorTemplate);
    return scope.Escape(Nan::NewInstance(Nan::GetFunction(localRef).ToLocalChecked(),_countof(args), args).ToLocalChecked());
  }

  ::Windows::Storage::Streams::RandomAccessStreamReference^ UnwrapRandomAccessStreamReference(Local<Value> value) {
     return RandomAccessStreamReference::Unwrap<RandomAccessStreamReference>(Nan::To<Object>(value).ToLocalChecked())->_instance;
  }

  void InitRandomAccessStreamReference(Local<Object> exports) {
    RandomAccessStreamReference::Init(exports);
  }

} } } }

NAN_MODULE_INIT(init) {
  // We ignore failures for now since it probably means that
  // the initialization already happened for STA, and that's cool

  CoInitializeEx(nullptr, COINIT_MULTITHREADED);

  // if (FAILED(CoInitializeEx(nullptr, COINIT_MULTITHREADED))) {
  //   Nan::ThrowError(Nan::Error(NodeRT::Utils::NewString(L"error in CoInitializeEx()")));
  //   return;
  // }

  // dev.ble
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothAddressTypeEnum(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothCacheModeEnum(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothConnectionStatusEnum(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothErrorEnum(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothMajorClassEnum(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothMinorClassEnum(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothServiceCapabilitiesEnum(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothAdapter(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothClassOfDevice(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothDevice(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothDeviceId(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothLEAppearance(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothLEAppearanceCategories(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothLEAppearanceSubcategories(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothLEDevice(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothSignalStrengthFilter(target);
  NodeRT::Windows::Devices::Bluetooth::InitBluetoothUuidHelper(target);

  NodeRT::Utils::RegisterNameSpace("Windows.Devices.Bluetooth", target);

  // dev.ble.adv
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementFlagsEnum(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementPublisherStatusEnum(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementTypeEnum(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementWatcherStatusEnum(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEScanningModeEnum(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisement(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementBytePattern(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementDataSection(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementDataTypes(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementFilter(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementPublisher(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementPublisherStatusChangedEventArgs(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementReceivedEventArgs(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementWatcher(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEAdvertisementWatcherStoppedEventArgs(target);
  NodeRT::Windows::Devices::Bluetooth::Advertisement::InitBluetoothLEManufacturerData(target);

  NodeRT::Utils::RegisterNameSpace("Windows.Devices.Bluetooth.Advertisement", target);

  // dev.ble.gap
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattCharacteristicPropertiesEnum(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattClientCharacteristicConfigurationDescriptorValueEnum(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattCommunicationStatusEnum(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattOpenStatusEnum(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattProtectionLevelEnum(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattRequestStateEnum(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattServiceProviderAdvertisementStatusEnum(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattSessionStatusEnum(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattSharingModeEnum(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattWriteOptionEnum(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattCharacteristic(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattCharacteristicUuids(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattCharacteristicsResult(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattClientNotificationResult(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattDescriptor(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattDescriptorUuids(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattDescriptorsResult(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattDeviceService(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattDeviceServicesResult(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattLocalCharacteristic(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattLocalCharacteristicParameters(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattLocalCharacteristicResult(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattLocalDescriptor(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattLocalDescriptorParameters(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattLocalDescriptorResult(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattLocalService(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattPresentationFormat(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattPresentationFormatTypes(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattProtocolError(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattReadClientCharacteristicConfigurationDescriptorResult(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattReadRequest(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattReadRequestedEventArgs(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattReadResult(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattReliableWriteTransaction(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattRequestStateChangedEventArgs(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattServiceProvider(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattServiceProviderAdvertisementStatusChangedEventArgs(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattServiceProviderAdvertisingParameters(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattServiceProviderResult(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattServiceUuids(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattSession(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattSessionStatusChangedEventArgs(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattSubscribedClient(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattValueChangedEventArgs(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattWriteRequest(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattWriteRequestedEventArgs(target);
  NodeRT::Windows::Devices::Bluetooth::GenericAttributeProfile::InitGattWriteResult(target);

  NodeRT::Utils::RegisterNameSpace("Windows.Devices.Bluetooth.GenericAttributeProfile", target);

  // dev.enum
  NodeRT::Windows::Devices::Enumeration::InitDeviceAccessStatusEnum(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceClassEnum(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceInformationKindEnum(target);
  NodeRT::Windows::Devices::Enumeration::InitDevicePairingKindsEnum(target);
  NodeRT::Windows::Devices::Enumeration::InitDevicePairingProtectionLevelEnum(target);
  NodeRT::Windows::Devices::Enumeration::InitDevicePairingResultStatusEnum(target);
  NodeRT::Windows::Devices::Enumeration::InitDevicePickerDisplayStatusOptionsEnum(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceUnpairingResultStatusEnum(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceWatcherEventKindEnum(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceWatcherStatusEnum(target);
  NodeRT::Windows::Devices::Enumeration::InitPanelEnum(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceAccessChangedEventArgs(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceAccessInformation(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceConnectionChangeTriggerDetails(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceDisconnectButtonClickedEventArgs(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceInformation(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceInformationCollection(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceInformationCustomPairing(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceInformationPairing(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceInformationUpdate(target);
  NodeRT::Windows::Devices::Enumeration::InitDevicePairingRequestedEventArgs(target);
  NodeRT::Windows::Devices::Enumeration::InitDevicePairingResult(target);
  NodeRT::Windows::Devices::Enumeration::InitDevicePicker(target);
  NodeRT::Windows::Devices::Enumeration::InitDevicePickerAppearance(target);
  NodeRT::Windows::Devices::Enumeration::InitDevicePickerFilter(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceSelectedEventArgs(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceThumbnail(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceUnpairingResult(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceWatcher(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceWatcherEvent(target);
  NodeRT::Windows::Devices::Enumeration::InitDeviceWatcherTriggerDetails(target);
  NodeRT::Windows::Devices::Enumeration::InitEnclosureLocation(target);
  NodeRT::Windows::Devices::Enumeration::InitIDevicePairingSettings(target);

  NodeRT::Utils::RegisterNameSpace("Windows.Devices.Enumeration", target);

  // dev.radios
  NodeRT::Windows::Devices::Radios::InitRadioAccessStatusEnum(target);
  NodeRT::Windows::Devices::Radios::InitRadioKindEnum(target);
  NodeRT::Windows::Devices::Radios::InitRadioStateEnum(target);
  NodeRT::Windows::Devices::Radios::InitRadio(target);

  NodeRT::Utils::RegisterNameSpace("Windows.Devices.Radios", target);

  // foundation
  NodeRT::Windows::Foundation::InitAsyncStatusEnum(target);
  NodeRT::Windows::Foundation::InitPropertyTypeEnum(target);
  NodeRT::Windows::Foundation::InitDeferral(target);
  NodeRT::Windows::Foundation::InitGuidHelper(target);
  NodeRT::Windows::Foundation::InitIAsyncAction(target);
  NodeRT::Windows::Foundation::InitIAsyncInfo(target);
  NodeRT::Windows::Foundation::InitIGetActivationFactory(target);
  NodeRT::Windows::Foundation::InitIMemoryBuffer(target);
  NodeRT::Windows::Foundation::InitIMemoryBufferReference(target);
  NodeRT::Windows::Foundation::InitIStringable(target);
  NodeRT::Windows::Foundation::InitIWwwFormUrlDecoderEntry(target);
  NodeRT::Windows::Foundation::InitMemoryBuffer(target);
  NodeRT::Windows::Foundation::InitPropertyValue(target);
  NodeRT::Windows::Foundation::InitWwwFormUrlDecoder(target);
  NodeRT::Windows::Foundation::InitWwwFormUrlDecoderEntry(target);
  NodeRT::Windows::Foundation::InitIPropertyValue(target);
  NodeRT::Windows::Foundation::InitUri(target);

  NodeRT::Utils::RegisterNameSpace("Windows.Foundation", target);

  // storage.streams
  NodeRT::Windows::Storage::Streams::InitByteOrderEnum(target);
  NodeRT::Windows::Storage::Streams::InitFileOpenDispositionEnum(target);
  NodeRT::Windows::Storage::Streams::InitInputStreamOptionsEnum(target);
  NodeRT::Windows::Storage::Streams::InitUnicodeEncodingEnum(target);
  NodeRT::Windows::Storage::Streams::InitBuffer(target);
  NodeRT::Windows::Storage::Streams::InitDataReader(target);
  NodeRT::Windows::Storage::Streams::InitDataReaderLoadOperation(target);
  NodeRT::Windows::Storage::Streams::InitDataWriter(target);
  NodeRT::Windows::Storage::Streams::InitDataWriterStoreOperation(target);
  NodeRT::Windows::Storage::Streams::InitFileInputStream(target);
  NodeRT::Windows::Storage::Streams::InitFileOutputStream(target);
  NodeRT::Windows::Storage::Streams::InitFileRandomAccessStream(target);
  NodeRT::Windows::Storage::Streams::InitIBuffer(target);
  NodeRT::Windows::Storage::Streams::InitIContentTypeProvider(target);
  NodeRT::Windows::Storage::Streams::InitIDataReader(target);
  NodeRT::Windows::Storage::Streams::InitIDataWriter(target);
  NodeRT::Windows::Storage::Streams::InitIInputStream(target);
  NodeRT::Windows::Storage::Streams::InitIInputStreamReference(target);
  NodeRT::Windows::Storage::Streams::InitIOutputStream(target);
  NodeRT::Windows::Storage::Streams::InitIRandomAccessStream(target);
  NodeRT::Windows::Storage::Streams::InitIRandomAccessStreamReference(target);
  NodeRT::Windows::Storage::Streams::InitIRandomAccessStreamWithContentType(target);
  NodeRT::Windows::Storage::Streams::InitInMemoryRandomAccessStream(target);
  NodeRT::Windows::Storage::Streams::InitInputStreamOverStream(target);
  NodeRT::Windows::Storage::Streams::InitOutputStreamOverStream(target);
  NodeRT::Windows::Storage::Streams::InitRandomAccessStream(target);
  NodeRT::Windows::Storage::Streams::InitRandomAccessStreamOverStream(target);
  NodeRT::Windows::Storage::Streams::InitRandomAccessStreamReference(target);

  NodeRT::Utils::RegisterNameSpace("Windows.Storage.Streams", target);
}



NODE_MODULE(binding, init)
